{"meta":{"title":"Lawson's Blog","subtitle":"尝尽人间百味，方知人间冷暖。","description":"劳生穿的博客。做人最重要的是开心。","author":"Lawson","url":"http://lawsan.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-03T02:32:34.343Z","comments":true,"path":"about/index.html","permalink":"http://lawsan.xyz/about/index.html","excerpt":"","text":".info_content { padding-left: 20px; display: flex; } .info_details ul>li { list-style-type: none; } .text-indent { text-indent: 2em; } 姓名：阿穿 性别：男 职业：前端CV工程师 爱好：玩游戏，看电影,codeing... 英文名：Lawson 年龄：22 学历：本科 我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。 window.onload = function() { var detail = document.getElementById('my_info_details'); var detail1 = document.getElementById('my_info_details1'); var detailText = `我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。`; var detailText1 = `前路漫漫，唯独自己变强才能走到最后，加油！奥利给。`; typing(detail, detailText, 100) .then(()=>{typing(detail1, detailText1, 100)}) .catch((e)=>{ console.log(e) }) function typing(dom, text, time) { return new Promise((resolve, reject) => { var i = 0; var timer = setInterval(function() { if (i"},{"title":"","date":"2020-07-01T11:59:23.000Z","updated":"2020-07-02T04:46:10.999Z","comments":true,"path":"categories/index.html","permalink":"http://lawsan.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-02T09:53:45.042Z","comments":true,"path":"tags/index.html","permalink":"http://lawsan.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"H5中新增的一些特性","slug":"H5","date":"2020-07-02T08:25:24.000Z","updated":"2020-07-02T08:33:14.292Z","comments":true,"path":"2020/07/02/H5/","link":"","permalink":"http://lawsan.xyz/2020/07/02/H5/","excerpt":"","text":"这是大标题小标题123function sayHello()&#123; alert(&#39;Hello&#39;)&#125;","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://lawsan.xyz/tags/HTML5/"}]},{"title":"聊聊几种排序算法","slug":"聊聊几种排序算法","date":"2020-07-02T08:09:54.494Z","updated":"2020-07-03T14:57:34.258Z","comments":true,"path":"2020/07/02/聊聊几种排序算法/","link":"","permalink":"http://lawsan.xyz/2020/07/02/%E8%81%8A%E8%81%8A%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"Javascript API实现排序12let arr = [72, 45, 62, 12, 23, 67, 80, 56, 90, 6, 9];arr.sort((a,b)=&gt;a-b); 冒泡排序基本思路：每次执行循环就把一个最大的数放到最后，就像气泡一样一个一个的冒；第一个循环遍历数组所有元素，第二个循环遍历是找出最大数值然后放在最后，时间复杂度为O(n2)。 1234567891011function bubbleSort(arr) &#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; //两个数比较，i表示数组总个数，j代表第一个数（索引较前）最大就是倒数第二个数 for (let j = 0; j &lt; arrLength - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] //交换两个数值 &#125; &#125; &#125;&#125; 选择排序基本思路： 每次执行循环找出最小值的索引值，并把这个最小放到前面，索引i前面的数组是依次排好的，时间复杂度为O(n2)。 与冒泡排序比较，冒泡排序是每次找出最大值放到最后而选择排序这是每次找出最小值放到前面。每次循环都会从乱序数组中找出最大（最小）值排到有序数组中。 1234567891011121314function selectSort(arr)&#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; let minIndex = i //每次循环找出最小值索引 for(let j = i;j&lt;arrLength;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j &#125; &#125; //把最小值放到前面数组 [arr[i],arr[minIndex]] = [arr[minIndex],arr[i]] &#125;&#125; 插入排序基本思路：在已有排序的数组中找出自己位置，插入其中； 12345678910111213141516function insertSort(arr)&#123; let arrLength = arr.length let preIndex,current for(let i = 1;i&lt;arrLength;i++)&#123; preIndex = i - 1 current = arr[i] //这个循环就是找出自己的位置，然后跳出，比较这个原始和current的大小，大则移后 while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current)&#123; arr[preIndex + 1] = arr[preIndex] 45,72,72 preIndex --; &#125; //插入 arr[preIndex + 1] = current; &#125;&#125; 归并排序基本思路：该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 123456789101112131415161718192021222324252627282930function mergeSort(arr)&#123; let len = arr.length if(len&lt;2)&#123; return arr &#125; //把长度为n的输入序列分成两个长度为n/2的子序列 let mid = Math.floor(len/2) let left = arr.slice(0,mid) let right = arr.slice(mid) //对这两个子序列分别采用归并排序 return merge(mergeSort(left),mergeSort(right))&#125;//将两个排序好的子序列合并成一个最终的排序序列。function merge(left,right)&#123; let result = [] while(left.length &gt; 0 &amp;&amp; right.length &gt; 0)&#123; if(left[0] &lt;= right[0])&#123; result.push(left.shift()) &#125;else&#123; result.push(right.shift()) &#125; &#125; while(left.length)&#123; result.push(left.shift()) &#125; while(right.length)&#123; result.push(right.shift()) &#125; return result&#125; 快速排序基本思路： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。12345678910111213141516171819202122232425function quickSort(arr,left,right)&#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if(left &lt; right)&#123; partitionIndex = partition(arr, left ,right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) &#125; return arr&#125;//分区操作function partition(arr, left ,right)&#123; var pivot = left, index =pivot + 1; for(var i = index;i &lt;= right; i++)&#123; if(arr[i] &lt; arr[pivot])&#123; [arr[i],arr[index]] = [arr[index],arr[i]] index++ &#125; &#125; [arr[pivot],arr[index-1]] = [arr[index-1],arr[pivot]] return index-1&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"Vue监听回车事件@keyup","slug":"Vue监听回车事件keyup","date":"2020-06-30T13:08:05.000Z","updated":"2020-07-03T10:49:37.730Z","comments":true,"path":"2020/06/30/Vue监听回车事件keyup/","link":"","permalink":"http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/","excerpt":"","text":"当我们要在一个输入框中监听回车事件时要绑定keyup事件；keydown当键盘被按下时会触发；keyup当键盘松开时触发； 1&lt;input type=\"text\" value=\"\" id=\"search_input\"/&gt; 原生JavaScript实现;1234567document.getElementById('search_input').onkeyup = function(e)&#123; var theEvent = window.event || e; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; //doSomeThing... &#125;&#125; jQuery实现；12345$(\"#search_input\").keyup(function(e)&#123; if (e.keyCode == 13) &#123; //doSomeThing... &#125;&#125;) Vue事件绑定实现全部键盘别名 enter,tab,delete,esc,space,up,down,left,right;组合按键 ctr,alt,shift,meta(window系统下是win键，mac下是command键) 12345&lt;input type=\"text\" @keyup.enter=\"search\" v-model=\"search_input\"/&gt;//methodssearch()&#123; //doSomeThing...&#125; 如果是封装组件的话，例如element的el-input，要加上native; 1&lt;el-input v-model=\"search_input\" @keyup.enter.native=\"search\"&gt;&lt;/el-input&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}],"categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://lawsan.xyz/tags/HTML5/"},{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}