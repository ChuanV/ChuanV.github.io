{"meta":{"title":"Lawson's Blog","subtitle":"尝尽人间百味，方知人间冷暖。","description":"劳生穿的博客。做人最重要的是开心。","author":"Lawson","url":"http://lawsan.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-03T02:32:34.343Z","comments":true,"path":"about/index.html","permalink":"http://lawsan.xyz/about/index.html","excerpt":"","text":".info_content { padding-left: 20px; display: flex; } .info_details ul>li { list-style-type: none; } .text-indent { text-indent: 2em; } 姓名：阿穿 性别：男 职业：前端CV工程师 爱好：玩游戏，看电影,codeing... 英文名：Lawson 年龄：22 学历：本科 我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。 window.onload = function() { var detail = document.getElementById('my_info_details'); var detail1 = document.getElementById('my_info_details1'); var detailText = `我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。`; var detailText1 = `前路漫漫，唯独自己变强才能走到最后，加油！奥利给。`; typing(detail, detailText, 100) .then(()=>{typing(detail1, detailText1, 100)}) .catch((e)=>{ console.log(e) }) function typing(dom, text, time) { return new Promise((resolve, reject) => { var i = 0; var timer = setInterval(function() { if (i"},{"title":"","date":"2020-07-01T11:59:23.000Z","updated":"2020-07-02T04:46:10.999Z","comments":true,"path":"categories/index.html","permalink":"http://lawsan.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-02T09:53:45.042Z","comments":true,"path":"tags/index.html","permalink":"http://lawsan.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"经典算法以及数据结构","slug":"经典算法以及数据结构","date":"2020-07-07T09:31:21.000Z","updated":"2020-07-07T10:49:35.829Z","comments":true,"path":"2020/07/07/经典算法以及数据结构/","link":"","permalink":"http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"斐波那契数列在算法题中比较经典，故出此文以此铭记。题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&lt;=39 暴力递归实现1234function Fibonacci(n)&#123; if(n == 0 || n == 1) return n return Fibonacci(n-1) + Fibonacci(n-2)&#125; 数组保存计算缓存，减少计算12345678function Fibonacci(n)&#123; let arr = [0,1] return Fib(n) function Fib(n)&#123; if(arr[n] !== undefined ) return arr[n] //计算过的不用再计算 return arr[n] = Fib(n-1) + Fib(n-2) &#125;&#125; 动态规划12345678function Fibonacci(n)&#123; let a = 0 //第一项 let b = 1 //第二项 for(let i = 2;i&lt; n;i++ )&#123; //从第二项开始到n-1项 [a,b] = [b,a+b] &#125; return a+b&#125; 感觉这篇幅有点短，好吧再加几个算法题^_^ 经典算法二分查找题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011121314151617function Find(target,array)&#123; for(let i =0 ;i&lt;array.length;i++)&#123; let low = 0 //每行的开始索引 let height = array[i].length - 1 //每行的最大索引 while(low &lt;= height)&#123; //对每一行的数组进行二分查找 let mid = Math.floor((low+height)/2) if(target &gt; array[i][mid])&#123; low = mid + 1 &#125;else if(target &lt; array[i][mid])&#123; height = mid -1 &#125;else&#123; return true &#125; &#125; &#125; return false //没有找到&#125; 此题还有一种更好的思路：既然是递增数组，那我们就比较一下每一行数组最大的元素，如果此数大于这一行的最大元素则去下一行数组比较，如果此数小于这一行的最大元素则去前一列比较； 123456789101112131415function Find(target,array)&#123; let row = 0 let col = array[0].length -1 let len = array.length while(row &lt; len &amp;&amp; 0 &lt;= col)&#123; //row是索引要小于行数，col要大于0 if(target &gt; array[row][col])&#123; row++ &#125;else if(target &lt; array[row][col])&#123; col-- &#125;else&#123; return true &#125; &#125; return false&#125; 链表链表也是数据结构中的一种，由指针指向。题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 1234567891011121314/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function printListFromTailToHead(head)&#123; let ArrayList = [] while(head)&#123; ArrayList.push(head.val) head = head.next &#125; ArrayList.reverse() return ArrayList&#125; JavaScript实现队列队列是数据结构中的一种，先进先出FIFO,我们用数组来实现它。 123456789101112131415function Queue()&#123; let arr = [] this.pop = function()&#123; if(arr.length &lt;= 0) return return arr.shift() &#125; this.push = function(data)&#123; arr.push(data) &#125;&#125;let queue = new Queue()queue.push(1)queue.push(2)queue.push(3)queue.pop() //1 JavaScript实现栈栈是数据结构中的一种，先进先出FILO,我们用数组来实现它。 12345678910111213141516function Stack()&#123; let value = [] this.pop = function()&#123; if(value.length &lt;= 0) return return value.pop() &#125; this.push = function(data)&#123; value.push(data) &#125;&#125;let stack = new Stack()stack.push(1)stack.push(2)stack.push(3)stack.pop() //3 好了此次的文章就写到这了，祝高三学子高考顺利！！！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://lawsan.xyz/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://lawsan.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://lawsan.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"canvas踩坑日记","slug":"canvas踩坑日记","date":"2020-07-02T08:25:24.000Z","updated":"2020-07-07T05:31:45.698Z","comments":true,"path":"2020/07/02/canvas踩坑日记/","link":"","permalink":"http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"","text":"这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过html2canvas.js转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。 利用canvas的API进行剪切注意：Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。也就是说通过css给canvas添加样式是行不通的（这个坑费了我好多时间)。解决方案：动态添加canvas； 123456&lt;p&gt;图片应用:&lt;/p&gt;&lt;img id=\"scream\" src=\"img_the_scream.jpg\"&gt;&lt;p&gt;画布:&lt;/p&gt;&lt;canvas id=\"myCanvas\" width=\"300\" height=\"150\" style=\"border:1px solid #d3d3d3;\"&gt;您的浏览器不支持 HTML5 canvas 标签。&lt;/canvas&gt; 1234567document.getElementById(\"scream\").onload=function()&#123; var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); var img=document.getElementById(\"scream\"); ctx.drawImage(img,90,130,50,60,10,10,50,60);&#125;; 关于drawImage的使用有三种语法的使用： context.drawImage(img,dx,dy); context.drawImage(img,dx,dy,dw,dh); context.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh); 坐标草图 对图片进行剪切12345678910111213141516let IMG = &#123; file: 0, //图片文件 width: 0, //源图片宽度 height: 0, //源图片高度 firstY: 330, //第一次剪切高度（从0开始） secondY: 410, //第二次剪切高度（第二次开始剪切的y坐标） money: \"-588.00\", //要修改的数字 bg: \"#f7f7f7\", //#f5f5f5 fontSize:'60px',&#125;pic.onload = function() &#123; IMG.height = pic.height; IMG.width = pic.width; ctx1.drawImage(pic, 0, 0, pic.width, IMG.firstY, 0, 0, pic.width, IMG.firstY); ctx2.drawImage(pic, 0, IMG.secondY, pic.width, (IMG.height - IMG.secondY), 0, 0, pic.width, (IMG.height -IMG.secondY));&#125; 对图片要要修改的部分用html代替显示，然后html转图片12345678910111213141516html2canvas(canvasBox, &#123; allowTaint: true, //允许污染 taintTest: true, //在渲染前测试图片 useCORS: true, //使用跨域 background:IMG.bg, dpi: window.devicePixelRatio * 2, //分辨率，是图片清晰点 scale: 2, height: IMG.height - 10, //截图高度 width: IMG.width, //截图宽度&#125;).then(function(canvas) &#123; //显示ps好的图片 let show = document.getElementById('show'); show.style.display = 'block'; show.src = canvas.toDataURL(); canvasBox.style.display = 'none';&#125;) 此次是对支付宝账单详情的金额进行ps，整个源码地址==&gt;canvas对支付宝账单详情进行P图","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"},{"name":"html2canvas","slug":"html2canvas","permalink":"http://lawsan.xyz/tags/html2canvas/"}]},{"title":"聊聊几种排序算法","slug":"聊聊几种排序算法","date":"2020-07-02T08:09:54.494Z","updated":"2020-07-03T14:57:34.258Z","comments":true,"path":"2020/07/02/聊聊几种排序算法/","link":"","permalink":"http://lawsan.xyz/2020/07/02/%E8%81%8A%E8%81%8A%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"Javascript API实现排序12let arr = [72, 45, 62, 12, 23, 67, 80, 56, 90, 6, 9];arr.sort((a,b)=&gt;a-b); 冒泡排序基本思路：每次执行循环就把一个最大的数放到最后，就像气泡一样一个一个的冒；第一个循环遍历数组所有元素，第二个循环遍历是找出最大数值然后放在最后，时间复杂度为O(n2)。 1234567891011function bubbleSort(arr) &#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; //两个数比较，i表示数组总个数，j代表第一个数（索引较前）最大就是倒数第二个数 for (let j = 0; j &lt; arrLength - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] //交换两个数值 &#125; &#125; &#125;&#125; 选择排序基本思路： 每次执行循环找出最小值的索引值，并把这个最小放到前面，索引i前面的数组是依次排好的，时间复杂度为O(n2)。 与冒泡排序比较，冒泡排序是每次找出最大值放到最后而选择排序这是每次找出最小值放到前面。每次循环都会从乱序数组中找出最大（最小）值排到有序数组中。 1234567891011121314function selectSort(arr)&#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; let minIndex = i //每次循环找出最小值索引 for(let j = i;j&lt;arrLength;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j &#125; &#125; //把最小值放到前面数组 [arr[i],arr[minIndex]] = [arr[minIndex],arr[i]] &#125;&#125; 插入排序基本思路：在已有排序的数组中找出自己位置，插入其中； 12345678910111213141516function insertSort(arr)&#123; let arrLength = arr.length let preIndex,current for(let i = 1;i&lt;arrLength;i++)&#123; preIndex = i - 1 current = arr[i] //这个循环就是找出自己的位置，然后跳出，比较这个原始和current的大小，大则移后 while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current)&#123; arr[preIndex + 1] = arr[preIndex] 45,72,72 preIndex --; &#125; //插入 arr[preIndex + 1] = current; &#125;&#125; 归并排序基本思路：该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 123456789101112131415161718192021222324252627282930function mergeSort(arr)&#123; let len = arr.length if(len&lt;2)&#123; return arr &#125; //把长度为n的输入序列分成两个长度为n/2的子序列 let mid = Math.floor(len/2) let left = arr.slice(0,mid) let right = arr.slice(mid) //对这两个子序列分别采用归并排序 return merge(mergeSort(left),mergeSort(right))&#125;//将两个排序好的子序列合并成一个最终的排序序列。function merge(left,right)&#123; let result = [] while(left.length &gt; 0 &amp;&amp; right.length &gt; 0)&#123; if(left[0] &lt;= right[0])&#123; result.push(left.shift()) &#125;else&#123; result.push(right.shift()) &#125; &#125; while(left.length)&#123; result.push(left.shift()) &#125; while(right.length)&#123; result.push(right.shift()) &#125; return result&#125; 快速排序基本思路： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。12345678910111213141516171819202122232425function quickSort(arr,left,right)&#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if(left &lt; right)&#123; partitionIndex = partition(arr, left ,right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) &#125; return arr&#125;//分区操作function partition(arr, left ,right)&#123; var pivot = left, index =pivot + 1; for(var i = index;i &lt;= right; i++)&#123; if(arr[i] &lt; arr[pivot])&#123; [arr[i],arr[index]] = [arr[index],arr[i]] index++ &#125; &#125; [arr[pivot],arr[index-1]] = [arr[index-1],arr[pivot]] return index-1&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"Vue监听回车事件@keyup","slug":"Vue监听回车事件keyup","date":"2020-06-30T13:08:05.000Z","updated":"2020-07-03T10:49:37.730Z","comments":true,"path":"2020/06/30/Vue监听回车事件keyup/","link":"","permalink":"http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/","excerpt":"","text":"当我们要在一个输入框中监听回车事件时要绑定keyup事件；keydown当键盘被按下时会触发；keyup当键盘松开时触发； 1&lt;input type=\"text\" value=\"\" id=\"search_input\"/&gt; 原生JavaScript实现;1234567document.getElementById('search_input').onkeyup = function(e)&#123; var theEvent = window.event || e; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; //doSomeThing... &#125;&#125; jQuery实现；12345$(\"#search_input\").keyup(function(e)&#123; if (e.keyCode == 13) &#123; //doSomeThing... &#125;&#125;) Vue事件绑定实现全部键盘别名 enter,tab,delete,esc,space,up,down,left,right;组合按键 ctr,alt,shift,meta(window系统下是win键，mac下是command键) 12345&lt;input type=\"text\" @keyup.enter=\"search\" v-model=\"search_input\"/&gt;//methodssearch()&#123; //doSomeThing...&#125; 如果是封装组件的话，例如element的el-input，要加上native; 1&lt;el-input v-model=\"search_input\" @keyup.enter.native=\"search\"&gt;&lt;/el-input&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://lawsan.xyz/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://lawsan.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://lawsan.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"},{"name":"html2canvas","slug":"html2canvas","permalink":"http://lawsan.xyz/tags/html2canvas/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}