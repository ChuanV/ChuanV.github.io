{"meta":{"title":"Lawson's Blog","subtitle":"认清现实，你只是看起来很努力。","description":"阿穿的博客。做人最重要的是开心。","author":"Lawson","url":"http://lawsan.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-27T02:45:23.348Z","comments":true,"path":"about/index.html","permalink":"http://lawsan.xyz/about/index.html","excerpt":"","text":".info_content { padding-left: 20px; display: flex; } .info_details ul>li { list-style-type: none; } .text-indent { text-indent: 2em; } 姓名：阿穿 性别：男 职业：前端CV工程师 爱好：玩游戏，看电影,coding... 英文名：Lawson 年龄：22 学历：本科 我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。 window.onload = function() { var detail = document.getElementById('my_info_details'); var detail1 = document.getElementById('my_info_details1'); var detailText = `我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。`; var detailText1 = `前路漫漫，唯独自己变强才能走到最后，加油！奥利给。`; typing(detail, detailText, 100) .then(()=>{typing(detail1, detailText1, 100)}) .catch((e)=>{ console.log(e) }) function typing(dom, text, time) { return new Promise((resolve, reject) => { var i = 0; var timer = setInterval(function() { if (i"},{"title":"","date":"2020-07-01T11:59:23.000Z","updated":"2020-07-02T04:46:10.999Z","comments":true,"path":"categories/index.html","permalink":"http://lawsan.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-02T09:53:45.042Z","comments":true,"path":"tags/index.html","permalink":"http://lawsan.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue全局配置","slug":"Vue全局配置","date":"2020-07-27T02:51:12.000Z","updated":"2020-07-27T05:47:09.637Z","comments":true,"path":"2020/07/27/Vue全局配置/","link":"","permalink":"http://lawsan.xyz/2020/07/27/Vue%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property： silent 类型：boolean 默认值：false 用法：1Vue.config.silent = true 取消 Vue 所有的日志与警告。optionMergeStrategies 类型：{ [key: string]: Function } 默认值：{} 用法：123456789Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123; return child + 1&#125;const Profile = Vue.extend(&#123; _my_option: 1&#125;)// Profile.options._my_option = 2 自定义合并策略的选项。合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。devtools 类型：boolean 默认值：true (生产版为 false) 用法：12// 务必在加载 Vue 之后，立即同步设置以下内容Vue.config.devtools = true 配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。errorHandler 类型：Function 默认值：undefined 用法：12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 undefined 时，被捕获的错误会通过 console.error 输出而避免应用崩溃。从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。 warnHandler 类型：Function 默认值：undefined 用法：123Vue.config.warnHandler = function (msg, vm, trace) &#123; // `trace` 是组件的继承关系追踪&#125; 为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。ignoredElements 类型：Array&lt;string | RegExp&gt; 默认值：[] 用法：1234567Vue.config.ignoredElements = [ 'my-custom-web-component', 'another-web-component', // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/] 须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。keyCodes 类型：{ [key: string]: number | Array&lt;number&gt; } 默认值：{} 用法：123456789Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase 不可用 mediaPlayPause: 179, // 取而代之的是 kebab-case 且用双引号括起来 \"media-play-pause\": 179, up: [38, 87]&#125; 1&lt;input type=\"text\" @keyup.media-play-pause=\"method\"&gt; 给 v-on 自定义键位别名。performance 类型：boolean 默认值：false (自 2.2.3 起) 用法：设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。 productionTip 类型：boolean 默认值：true 用法：设置为 false 以阻止 vue 在启动时生成生产提示。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"}]},{"title":"深入Vue响应式原理","slug":"深入Vue响应式原理","date":"2020-07-25T08:55:08.000Z","updated":"2020-07-26T03:01:23.363Z","comments":true,"path":"2020/07/25/深入Vue响应式原理/","link":"","permalink":"http://lawsan.xyz/2020/07/25/%E6%B7%B1%E5%85%A5Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","excerpt":"","text":"如何追踪变化？当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。数据代理的另一个说法是数据劫持，当我们在访问或者修改对象的某个属性时，数据劫持可以拦截这个行为并进行额外的操作或者修改返回的结果。我们知道Vue响应式系统的核心就是数据代理，代理使得数据在访问时进行依赖收集，在修改更新时对依赖进行更新，这是响应式系统的核心思路。 Object.definePropertyObject.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。基本用法：Object.defineProperty(obj, prop, descriptor)Object.defineProperty()可以用来精确添加或修改对象的属性，只需要在descriptor对象中将属性特性描述清楚，descriptor的属性描述符有两种形式，一种是数据描述符，另一种是存取描述符，我们分别看看各自的特点。数据描述符，它拥有四个属性配置 configurable：数据是否可删除，可配置 enumerable：属性是否可枚举 value：属性值,默认为undefined writable：属性是否可读写存取描述符，它同样拥有四个属性选项 configurable：数据是否可删除，可配置 enumerable：属性是否可枚举 get:一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。 set:一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。 需要注意的是: 数据描述符的value，writable 和 存取描述符中的get, set属性不能同时存在，否则会抛出异常。*123456789101112131415161718192021222324252627282930313233function observe(data)&#123; if(!data || typeof data !== 'object')&#123; return &#125; Object.keys(data).forEach(function(key)&#123; defineReactive(data,key,data[key]) &#125;)&#125;function defineReactive(data,key,val)&#123; Object.defineProperty(data,key,&#123; enumerable:true, configurable:false, get()&#123; console.log('获取值') return val &#125;, set(newVal)&#123; if(val === newVal) return console.log('监听到值变化了',val,'--&gt;',newVal) val = newVal &#125; &#125;)&#125;var arr = [1,2,3]var obj = &#123;name:'lisi'&#125;observe(arr)observe(obj)obj.age = 18 //拦截不到obj.name //获取值obj.name = 'programmer' //监听到值变化了 lisi --&gt;programmerarr[1] //获取值arr[2] = 8 //监听到值变化了 3 --&gt;8arr[4] = 5 //拦截不到 然而Object.defineProperty是有缺陷的，比如添加属性是监听不到对象的添加和删除或者数组的变化是无法拦截的。 Proxy为了解决像数组这类无法进行数据拦截，以及深层次的嵌套问题，es6引入了Proxy的概念，它是真正在语言层面对数据拦截的定义。和Object.defineProperty一样，Proxy可以修改某些操作的默认行为，但是不同的是，Proxy针对目标对象会创建一个新的实例对象，并将目标对象代理到新的实例对象上，。 本质的区别是后者会创建一个新的对象对原对象做代理，外界对原对象的访问，都必须先通过这层代理进行拦截处理。而拦截的结果是我们只要通过操作新的实例对象就能间接的操作真正的目标对象了。针对Proxy，下面是基础的写法:语法：const p = new Proxy(target, handler) target要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。12345678910111213var obj = &#123;b:18&#125;var nobj = new Proxy(obj, &#123; get(target, key, receiver) &#123; console.log('获取值') return Reflect.get(target, key, receiver) &#125;, set(target, key, value, receiver) &#123; console.log('设置值') return Reflect.set(target, key, value, receiver) &#125;&#125;)nobj.a = '代理'console.log(obj) //设置值 &#123;b:18,a: \"代理\"&#125; Proxy能监听数组的变化，添加，删除，修改等。 依赖收集为什么要收集依赖？举个例子： 123&lt;template&gt;&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/template&gt; 该模板中使用了数据name，所以它发生变化时，要向使用了它的地方发送通知。总结一句话就是在getter中收集依赖，在setter中触发依赖 订阅者 Dep我们把依赖收集的代码封装成一个Dep类，它帮助我们管理依赖。 12345678910111213141516class Dep &#123; constructor () &#123; /* 用来存放Watcher对象的数组 */ this.subs = []; &#125; /* 在subs中添加一个Watcher对象 */ addSub (sub) &#123; this.subs.push(sub); &#125; /* 通知所有Watcher对象更新视图 */ notify () &#123; this.subs.forEach((sub) =&gt; &#123; sub.update(); &#125;) &#125;&#125; 用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作；用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。 观察者 Watcher当属性发生变化后，我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch,这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个，再由它负责通知其他地方。依赖收集的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。 12345678910111213141516171819class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null &#125; update() &#123; // 获得新值 this.value = this.obj[this.key] // 我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图 this.cb(this.value) &#125;&#125; 以上就是 Watcher 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 Watcher ,然后执行 update 函数。 收集依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445function observe (obj) &#123; // 判断类型 if (!obj || typeof obj !== 'object') &#123; return &#125; Object.keys(obj).forEach(key =&gt; &#123; defineReactive(obj, key, obj[key]) &#125;) function defineReactive (obj, key, value) &#123; observe(value) // 递归子属性 let dp = new Dep() //新增 Object.defineProperty(obj, key, &#123; enumerable: true, //可枚举（可以遍历） configurable: true, //可配置（比如可以删除） get: function reactiveGetter () &#123; console.log('get', value) // 监听 // 将 Watcher 添加到订阅 if (Dep.target) &#123; dp.addSub(Dep.target) // 新增 &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; observe(newVal) //如果赋值是一个对象，也要递归子属性 if (newVal !== value) &#123; console.log('set', newVal) // 监听 render() value = newVal // 执行 watcher 的 update 方法 dp.notify() //通知更新 &#125; &#125; &#125;) &#125;&#125;class Vue &#123; constructor(options) &#123; this._data = options.data; observer(this._data); /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */ new Watcher(); console.log('模拟视图渲染'); &#125;&#125; 相关流程如下图 在 new Vue() 后， Vue 会调用_init 函数进行初始化，也就是init 过程，在 这个过程Data通过Observer转换成了getter/setter的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行getter 函数，而在当被赋值的时候会执行 setter函数。当render function 执行的时候，因为会读取所需对象的值，所以会触发getter函数从而将Watcher添加到依赖中进行依赖收集。在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update 来更新视图。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"}]},{"title":"关于HTML5中新增的特性","slug":"关于HTML5中新增的特性","date":"2020-07-23T05:05:06.000Z","updated":"2020-07-23T10:58:54.229Z","comments":true,"path":"2020/07/23/关于HTML5中新增的特性/","link":"","permalink":"http://lawsan.xyz/2020/07/23/%E5%85%B3%E4%BA%8EHTML5%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/","excerpt":"","text":"HTML语义化HTML 语义化是指仅仅从 HTML 元素上就能看出页面的大致结构，比如需要强调的内容可以放在 &lt;strong&gt; 标签中，而不是通过样式设置 &lt;span&gt; 标签去做。不同浏览器对 HTML 元素的解析可能有差异，HTML 语义化便是在抛开样式之后，页面能有一个友好的展示效果。我们力求让页面有良好的结构，让页面的元素有含义，同时利于被搜索引擎解析，利于 SEO。HTML 语义化的建议： 少使用无意义的 &lt;div&gt;、&lt;span&gt; 标签； 在 &lt;label&gt; 标签中设置 for 属性和对应的 &lt;input&gt; 关联起来； 设置 &lt;img&gt; 标签的 alt 属性，给 &lt;a&gt; 标签设置 title 属性，利于 SEO； 在页面的标题部分使用 &lt;h1&gt;~&lt;h6&gt; 标签，不需要给它们加多余的样式； 与表单、有序列表、无序列表相关的标签不要单独使用。HTML5 也新增了一些语义化的元素，我们通过标签名就能判断标签内容。使用语义元素的页面大致结构如下 语义元素的名称其实也很好理解，下面是它们的作用和用法： &lt;header&gt; 标签通常放在页面或页面某个区域的顶部，用来设置页眉； &lt;nav&gt;标签可以用来定义导航链接的集合，点击链接可以跳转到其他页面； &lt;article&gt; 标签中的内容比较独立，可以是一篇新闻报道，一篇博客，它可以独立于页面的其他内容进行阅读； &lt;section&gt; 标签表示页面中的一个区域，通常对页面进行分块或对内容进行分段，&lt;section&gt; 标签和 &lt;article&gt; 标签可以互相嵌套； &lt;aside&gt; 标签用来表示除页面主要内容之外的内容，比如侧边栏； &lt;footer&gt; 标签位于页面或页面某个区域的底部，用来设置页脚，通常包含版权信息，联系方式等。还有其他的新增标签： &lt;details&gt; 用于描述文档或文档某个部分的细节。 &lt;summary&gt; 标签包含 details 元素的标题。 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题。 &lt;dialog&gt; 定义对话框，比如提示框。 &lt;bdi&gt; 允许您设置一段文本，使其脱离其父元素的文本方向设置。 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮。 &lt;mark&gt; 定义带有记号的文本。 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。 &lt;progress&gt; 定义任何类型的任务的进度。 &lt;time&gt; 定义日期或时间。 &lt;wbr&gt; 规定在文本中的何处适合添加换行符。 &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音。HTML5 Input类型color,date,datetime,datetime-local,email,month,number,range,search,tel,time,url,weekHTML5 表单元素HTML5 有以下新的表单元素:&lt;datalist&gt;,&lt;keygen&gt;,&lt;output&gt; HTML5 &lt;datalist&gt; 元素*&lt;datalist&gt; 元素规定输入域的选项列表。&lt;datalist&gt; 属性规定 form 或 input 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项：使用 &lt;input&gt; 元素的列表属性与 &lt;datalist&gt;元素绑定。示例 HTML5&lt;keygen&gt;元素*&lt;keygen&gt; 元素的作用是提供一种验证用户的可靠方法。&lt;keygen&gt;标签规定用于表单的密钥对生成器字段。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。示例 HTML5 &lt;output&gt; 元素*&lt;output&gt; 元素用于不同类型的输出，比如计算或脚本输出。示例HTML5事件 contextmenucontextmenu 属性规定了元素的上下文菜单。当用户右击元素时将显示上下文菜单。contextmenu 属性的值是需要打开的 &lt;menu&gt; 元素的 id。示例 DOMContentLoaded当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。load 仅用于检测一个完全加载的页面，页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。 readystatechange可用来判断动态载入的 script、link 标签是否加载完成。123456789const script = document.createElement('script')script.addEventListener('readystatechange', function eventListener(event) &#123; if (event.readyState === 'loaded' || event.readyState === 'complete') &#123; // hack 的手段，浏览器自身的问题 script.removeEventListener('readystatechange', eventListener) &#125;&#125;)script.src = 'example.js'document.body.appendChild(script) hashchange用来监听浏览器链接的hash值变化。123456789101112131415function getUUID () &#123; return Math.floor(Math.random() * 1000000)&#125;window.onload = function () &#123; const el = document.getElementById('toggle') el.onclick = (e) =&gt; &#123; e.preventDefault() const uuid = getUUID() location.hash = '#' + uuid &#125; window.onhashchange = (e) =&gt; &#123; console.log('oldURL:', e.oldURL) console.log('newURL:', e.newURL) &#125;&#125; HTML5 表单属性&lt;form&gt;新属性：autocomplete，novalidate&lt;input&gt;新属性：autocomplete,autofocus,form,formaction,formenctype,formmethod,formnovalidate,formtarget,height 与 width,list,min 与 max,multiple,pattern (regexp),placeholder,required,stepHTML5 存储 sessionStorage: 大小上限为 2.5Mb(不同浏览器会有差异), 页面关闭时便清空; localStorage: 大小上限为 2.5Mb(不同浏览器会有差异), 页面关闭时不会清空;它们的 api 也是一致的, 有如下几个: setItem(key, value) getItem(key) removeItem(key) clear() 在 HTML5 范围之外与存储相关的技术还有 cookie(存放在客户端，可以由客户端也可以由服务端生成, 大小上限为 4 kb)、IndexedDB(大小上限为 5 Mb)、cacheStorage(ServiceWorker)。 HTML5 JavaScript API requestAnimationFrame(callback): 表示在重绘前执行指定的回调函数，下面通过一个简单的 demo 来认识它。1234567891011let framefunction callback(timeStamp) &#123; console.log(timeStamp) // 开始执行回调的时间戳 // 如果想要产生循环动画的效果, 需在回调函数中再次调用 requestAnimationFrame() requestAnimationFrame(callback)&#125;frame = requestAnimationFrame(callback) // 在下次重绘之前调用回调// 可以在销毁期的生命周期函数中执行以下函数componentWillUnMount() &#123; cancelAnimationFrame(frame)&#125; 一帧的时间大致为 16ms。 Web Worker当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 检测浏览器是否支持Web Worker 123456789if(typeof(Worker)!==\"undefined\")&#123; // 是的! Web worker 支持! // 一些代码.....&#125;else&#123; //抱歉! Web Worker 不支持&#125; 创建 Web Worker 对象 1234if(typeof(w)==\"undefined\")&#123; w=new Worker(\"demo_workers.js\");&#125; 终止 Web Worker 1w.terminate(); Worker.onmessage 当MessageEvent类型的事件冒泡到 worker 时，事件监听函数 EventListener 被调用.Worker.onmessageerror 当messageerror 类型的事件发生时，对应的EventHandler 代码被调用。Worker.postMessage() 发送一条消息到最近的外层对象，消息可由任何 JavaScript 对象组成。Worker.terminate() 立即终止 worker。该方法不会给 worker 留下任何完成操作的机会；就是简单的立即停止。 例子： 12345&lt;body&gt; &lt;p&gt;计数： &lt;output id=\"result\"&gt;&lt;/output&gt;&lt;/p&gt; &lt;button onclick=\"startWorker()\"&gt;开始工作&lt;/button&gt; &lt;button onclick=\"stopWorker()\"&gt;停止工作&lt;/button&gt;&lt;/body&gt; 123456789//这是demo_workers.js里面的内容var i=0;function timedCount()&#123; i=i+1; postMessage(i); //用于向 HTML 页面传回一段消息 setTimeout(\"timedCount()\",500);&#125;timedCount(); 123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; var w; function startWorker() &#123; if(typeof(Worker) !== \"undefined\") &#123; if(typeof(w) == \"undefined\") &#123; w = new Worker(\"demo_workers.js\"); &#125; w.onmessage = function(event) &#123; //接收postMessage的数据 document.getElementById(\"result\").innerHTML = event.data; &#125;; &#125; else &#123; document.getElementById(\"result\").innerHTML = \"抱歉，你的浏览器不支持 Web Workers...\"; &#125; &#125; function stopWorker() &#123; w.terminate(); w = undefined; &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://lawsan.xyz/tags/HTML5/"}]},{"title":"CSS盒模型与BFC","slug":"CSS盒模型与BFC","date":"2020-07-23T02:33:57.000Z","updated":"2020-07-23T04:52:06.237Z","comments":true,"path":"2020/07/23/CSS盒模型与BFC/","link":"","permalink":"http://lawsan.xyz/2020/07/23/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8EBFC/","excerpt":"","text":"所有HTML元素可以看作盒子，在CSS中，box model这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。下面的图片说明了盒子模型(Box Model)： 不同部分的说明： Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 注意：我们用盒子的宽高来衡量盒子的大小，可以看做总元素的宽度和高度，和元素本身设置的宽度和高度（width，height）不是同一个概念。标准盒模型 元素的 width、height 只包含内容 content，不包含 border 和 padding 值； 盒子的大小由元素的宽高、边框和内边距决定。 盒子的宽/高 = width/height + border + padding + margin模型如下图： IE盒模型 元素的 width、height 不仅包括 content，还包括 border 和 padding； 盒子的大小取决于 width、height，修改 border 和 padding 值不能改变盒子的大小 盒子宽/高=width/height + margin = 内容区宽度/高度 + padding + border + margin盒型如下图： 兼容 标准盒模型和IE盒模型就在内容content的区别，标准盒模型的content只包括width/height，而IE盒模型的content包括width/height+border+padding。 标准盒模型下元素的 box-sizing 属性（IE8+）默认值为 content-box，将它设置成 border-box 可转换为 IE 盒模型。在实际应用场景中，若想控制元素总宽高保持固定，这个设置很有用。 元素的宽（width）、高（height）、边框（border）、内边距（padding）、外边距（margin）都是盒子模型的重要组成部分，但是盒子模型的大小只与元素的宽高、边框、内间距有关，外边距只影响盒子所占外围空间的大小。边距重叠解决方案(BFC)首先要明确BFC是什么意思，其全英文拼写为 Block Formatting Context 直译为块级格式化上下文。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 Block-level box:display 属性为 block, list-item, table 的元素。 inline-level box:display 属性为 inline, inline-block, inline-table的元素。BFC布局规则 内部的box会在垂直方向，一个接一个的放置 每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反） box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠 BFC的区域不会与浮动区域的box重叠 BFC是一个页面上的独立的容器，外面的元素不会影响BFC里的元素，反过来，里面的也不会影响外面的 计算BFC高度的时候，浮动元素也会参与计算如何创建BFC float属性不为none（脱离文档流） position为absolute或fixed display为inline-block,table-cell,table-caption,flex,inline-flex overflow不为visible 根元素, 即HTML元素BFC的作用 利用BFC避免margin重叠 自适应两栏布局 清除内部浮动例子如下：避免margin重叠123456789101112&lt;style&gt;.pOne&#123; margin: 10px 0;&#125;.pTwo&#123; margin: 30px 0;&#125;&lt;/style&gt;&lt;body&gt;&lt;p class=\"pOne\"&gt;文本1&lt;/p&gt;&lt;p class=\"pTwo\"&gt;文本2&lt;/p&gt;&lt;/body&gt; 在上面的例子中，margin会重叠，会以最大的margin为准。也就是两个p元素的外边距为30px。当我们利用BFC时1234567891011121314151617&lt;style&gt;.pOne&#123; margin: 10px 0;&#125;.pTwo&#123; margin: 30px 0;&#125;div&#123; overflow: hidden;&#125;&lt;/style&gt;&lt;body&gt;&lt;p class=\"pOne\"&gt;文本1&lt;/p&gt;&lt;div &gt; &lt;p class=\"pTwo\"&gt;文本2&lt;/p&gt;&lt;/div&gt;&lt;/body&gt; 利用BFC消除了margin重叠问题，这样的话两个p元素的外边距为30+10=40px。自适应两栏布局根据BFC的布局规则：每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反）。12345678910111213141516&lt;style&gt;.left&#123; height: 300px; width: 200px; background-color: #00FFFF; float: left;&#125;.right&#123; height: 500px; background-color: #F5F5DC;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;LEFT&lt;/div&gt; &lt;div class=\"right\"&gt;RIGHT&lt;/div&gt;&lt;/body&gt; 效果如下图： 根据BFC的布局规则：BFC的区域不会与浮动区域的box重叠。所以我们要创建一个BFC，避免left和right重叠。1234567891011121314151617&lt;style&gt;.left&#123; height: 300px; width: 200px; background-color: #00FFFF; float: left;&#125;.right&#123; height: 500px; overflow: hidden; /*right变为BFC*/ background-color: #F5F5DC;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"left\"&gt;LEFT&lt;/div&gt; &lt;div class=\"right\"&gt;RIGHT&lt;/div&gt;&lt;/body&gt; 清除内部浮动当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。123456789101112131415161718&lt;style&gt;.parent&#123; width: 300px; border: 5px solid darkgoldenrod;&#125;.child&#123; height: 100px; width: 100px; float: left; border: 5px solid #00FFFF;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 效果如下，父节点高度塌陷： 根据BFC布局规则：计算BFC高度的时候，浮动元素也会参与计算。因此我们把父节点设置为BFC就可以解决高度塌陷。12345678910111213141516171819&lt;style&gt;.parent&#123; width: 300px; border: 5px solid darkgoldenrod; overflow: hidden; /*BFC*/&#125;.child&#123; height: 100px; width: 100px; float: left; border: 5px solid #00FFFF;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 关于解决父节点高度塌陷问题给父元素末尾添加一个空元素，并设置成清除浮动1&lt;div style=\"clear:both;\"&gt;&lt;/div&gt; 缺点：添加了无意义标签，不易于后期维护，违背了结构和表现分离的标准 给父元素添加 overflow：auto;让父元素也浮动缺点：影响整体页面布局，若父元素也有父元素呢？总不能一直浮动到body吧？ 使用after伪元素给父元素添加一个类，来添加一个看不见的块元素，以实现清除浮动。 12345678.clearfix:after&#123;content: '';height: 0;display: block;visibility: hidden;clear: both;&#125; BFC也就是BFC的布局规则：计算BFC高度的时候，浮动元素也会参与计算。上面的方法也用到了这条规则。下面这个方法是一个不错的方法。 12345678910.clearfix:after,.clearfix:before&#123; content: \" \"; display:table;&#125;.clearfix:after&#123; clear:both;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://lawsan.xyz/tags/CSS/"}]},{"title":"一文带你深入了解Promise","slug":"一文带你深入了解Promise","date":"2020-07-20T07:03:28.000Z","updated":"2020-07-22T01:51:34.472Z","comments":true,"path":"2020/07/20/一文带你深入了解Promise/","link":"","permalink":"http://lawsan.xyz/2020/07/20/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Promise/","excerpt":"","text":"什么是Promise？Promise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一。从语法上来说:Promise是一个构造函数。从功能上来说：promise对象是用来封装一个异步操作并可以获取其结果。 Promises/A+ 规范为实现者提供一个健全的、可互操作的 JavaScript promise 的开放标准。 相关术语 解决 (fulfill) : 指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。 拒绝（reject): 指一个 promise 失败时进行的一系列操作。 拒因 (reason) : 也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。 终值（eventual value） : 所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。 Promise : promise 是一个拥有 then 方法的对象或函数，其行为符合本规范。 thenable : 是一个定义了 then 方法的对象或函数。 异常（exception） : 是使用 throw 语句抛出的一个值。 Promise使用Promise状态一个Promise的当前状态必须是以下三种状态中的一种: 等待状态（Pending）、** 执行状态（Fulfilled）** 和 拒绝状态（Rejected）。一旦状态改变就不能再次改变。 语法1new Promise( function(resolve, reject) &#123;...&#125; /* executor */ ); Promise接收一个参数executor，executor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。相关流程如下图： 1234const promise = new Promise((resolve, reject) =&gt; &#123; // 异步处理 // 处理结束后、调用resolve 或 reject&#125;); then方法一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因，只有状态改变为Fulfilled或者Rejected时才会调用then方法，如果状态为Pending则不调用。promise 的 then 方法接受两个参数： 1promise.then(onFulfilled, onRejected) onFulfilled 和 onRejected 都是可选参数;如果 onFulfilled 不是函数，其必须被忽略;如果 onRejected 不是函数，其必须被忽略。then 方法可以被同一个 promise 调用多次，then方法必须返回一个promise对象。 race方法Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。 all方法Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中 promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。 reject方法Promise.reject()方法返回一个带有拒绝原因的Promise对象。 resolve方法Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。如果这个值是一个 promise ，那么将返回这个 promise ；如果这个值是thenable（即带有”then” 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。 手写Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161(function()&#123; const PENDING = 'pending' //初始状态 const RESOLVED = 'resolved' //成功状态 const REJECTED = 'rejected' //失败状态 //Promise构造函数 function MyPromise(excutor)&#123; const self = this //初始化状态 self.status = PENDING self.data = undefined self.callbacks = [] //每个元素的结构: &#123;onResolved(value)&#123;&#125;, onRejected(reason)&#123;&#125; &#125; //resolve方法 function resolve(value)&#123; if(self.status !== PENDING)&#123; return &#125; //改变状态，保存数据 self.status = RESOLVED self.data = value //如果有待执行回调函数，立即异步执行异步回调函数 if(self.callbacks.length &gt; 0)&#123; setTimeout(()=&gt;&#123; self.callbacks.forEach(item=&gt;&#123; item.onResolved(value) &#125;) &#125;) &#125; &#125; //reject方法 function reject(reason)&#123; if(self.status !== PENDING)&#123; return &#125; //改变状态，保存数据 self.status = REJECTED self.data = reason //如果有待执行回调函数，立即异步执行异步回调函数 if(self.callbacks.length &gt; 0)&#123; setTimeout(()=&gt;&#123; self.callbacks.forEach(item=&gt;&#123; item.onRejected(reason) &#125;) &#125;) &#125; &#125; //立即执行excutor函数 try&#123; excutor(resolve,reject) &#125;catch(error)&#123; reject(error) &#125; &#125; //Promise对象的then方法 MyPromise.prototype.then = function(onResolved,onRejected)&#123; onResolved = typeof onResolved === 'function' ?onResolved : value =&gt; value, //不写默认undefined //指定默认是失败回调 onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123; throw reason &#125; const self = this //返回一个新的promise对象 return new MyPromise((resolve,reject)=&gt;&#123; function handle(callback)&#123; try&#123; //回调函数返回的结果 const result = callback(self.data) if(result instanceof MyPromise)&#123; //返回的数据是Promise result.then(resolve,reject)//返回新的promise对象 &#125;else&#123; resolve(result) &#125; &#125;catch(error)&#123; reject(error) &#125; &#125; if(self.status === PENDING)&#123; self.callbacks.push(&#123; onResolved(value)&#123; handle(value) &#125;, onRejected(reason)&#123; handle(reason) &#125; &#125;) &#125;else if(self.status === RESOLVED)&#123; setTimeout(()=&gt;&#123; handle(onResolved) &#125;) &#125;else&#123; setTimeout(()=&gt;&#123; handle(onRejected) &#125;) &#125; &#125;) &#125; //Promise对象的catch方法 MyPromise.prototype.catch = function(onRejected)&#123; return this.then(undefined, onRejected) &#125; //Promise的resolve方法 MyPromise.resolve = function(value)&#123; return new MyPromise((resolve,reject)=&gt;&#123; if(result instanceof MyPromise)&#123; //返回的数据是Promise result.then(resolve,reject)//返回新的promise对象 &#125;else&#123; resolve(result) &#125; &#125;) &#125; //Promise的reject方法 MyPromise.reject = function(reason)&#123; return new MyPromise((resolve,reject)=&gt;&#123; reject(reason) &#125;) &#125; //Promise的all方法 MyPromise.all = function(promises)&#123; const values = new Array(promises.length) //保存成功的数据数据 let resolvedCount = 0 //成功的数量 return new MyPromise((resolve,reject)=&gt;&#123; //遍历执行promises promises.forEach((item,index)=&gt;&#123; MyPromise.resolve(item).then( value=&gt;&#123; reslovedCount++ values[index] = value if(reslovedCount === promises.length)&#123; resolve(values) &#125; &#125;, reason=&gt;&#123; reject(reason) &#125; ) &#125;) &#125;) &#125; //Promise的race方法 MyPromise.race = function(promises)&#123; return new MyPromise((resolve,reject)=&gt;&#123; promises.forEach((item,index)=&gt;&#123; MyPromise.resolve(item).then( value=&gt;&#123; resolve(value) &#125;, reason=&gt;&#123; reject(reason) &#125; ) &#125;) &#125;) &#125; window.MyPromise = MyPromise&#125;)()//使用var p = new MyPromise((resolve,reject)=&gt;&#123; resolve(1) &#125;)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lawsan.xyz/tags/JavaScript/"}]},{"title":"一文带你了解JavaScript深拷贝","slug":"一文带你了解JavaScript深拷贝","date":"2020-07-20T04:29:42.000Z","updated":"2020-07-20T06:33:40.618Z","comments":true,"path":"2020/07/20/一文带你了解JavaScript深拷贝/","link":"","permalink":"http://lawsan.xyz/2020/07/20/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"拷贝是啥？顾名思义也就是复制，我们知道在JavaScript中基本数据类型都是保存在栈中的，而复杂数据类型（object）是保存在堆中的，在栈中不过是保存了堆的地址（引用）。 浅拷贝与深拷贝浅深拷贝都是对引用类型的数据而言的，基本数据类型一赋值就开辟了独立的栈空间，互不影响。 浅拷贝：当我们对基本数据类型复制，会把值全部复制过去的。如果是引用类型，也是把值复制过去，不过这个值是地址引用。这样如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝：是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。12345678//基本数据类型let a = 1let b = ab = 2 //b的值为2，a的值为1互不影响//基本数据类型let a = [1,2,3]let b = ab[0] = 2 //b的值为[2,2,3]，a的值为[2,2,3]引用了同一个对象 赋值&amp;&amp;浅拷贝&amp;&amp;深拷贝的区别赋值：只是在栈中新建一个变量，指向同一个堆内存,也就是把地址复制过来。浅拷贝：会新建个一对象，如果属性是基本类型，则拷贝基本数据类型的值，如果是引用数据类型，则拷贝内存地址。因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。来看看下面的例子123456789//赋值let a = &#123; name:'lisi', hobby:[1,2,[3,4],5,6]&#125;let b = ab.name = 'zhangsan'b.hobby = [3,4,10]//a和b的值都为&#123;name:'zhansan',hobby:[3,4,10]&#125; 12345678910111213141516171819//浅拷贝let a = &#123; name:'lisi', hobby:[1,2,[3,4],5,6]&#125;let b = shallowClone(a)b.name = 'zhangsan'b.hobby[1] = 10 // 新旧对象还是共享同一块内存//a的值为&#123;name:'lisi',hobby:[1,10,[3,4],5,6]&#125;//b的值为&#123;name:'zhangsan',hobby:[1,10,[3,4],5,6]&#125;function shallowClone(source) &#123; var target = &#123;&#125;; for(var i in source) &#123; if (source.hasOwnProperty(i)) &#123; target[i] = source[i]; &#125; &#125; return target;&#125; 12345678910//深拷贝let a = &#123; name:'lisi', hobby:[1,2,[3,4],5,6]&#125;let b = JSON.parse(JSON.stringify(a)) //比较简单地实现深拷贝b.name = 'zhangsan'b.hobby[1] = 10 // 新旧对象不是同一块内存//a的值为&#123;name:'lisi',hobby:[1,2,[3,4],5,6]&#125;//b的值为&#123;name:'zhangsan',hobby:[1,10,[3,4],5,6]&#125; 浅拷贝实现Object.assign()Object.assign()方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 123456let obj1 = &#123;person:&#123;name:'lisi',age:18&#125;,money:666&#125;let obj2 = Object.assign(&#123;&#125;,obj1)obj2.person.age = 20obj2.money = 777console.log(obj1) //&#123;person:&#123;name:'lisi',age:20&#125;,money:666&#125;console.log(obj2) //&#123;person:&#123;name:'lisi',age:20&#125;,money:777&#125; 注意：当object只有一层的时候，是深拷贝 Array.prototype.concat()123456let arr1 = [1,2,&#123;name:'lisi',age:18&#125;,3,4]let arr2 = arr1.concat()arr2[1] = 10arr2[2].name = 'zhangsan'console.log(arr1)//[1,2,&#123;name:'zhangsan',age:18&#125;,3,4]console.log(arr2)//[1,10,&#123;name:'zhangsan',age:18&#125;,3,4] Array.prototype.slice()123456let arr1 = [1,2,&#123;name:'lisi',age:18&#125;,3,4]let arr2 = arr1.slice()arr2[1] = 10arr2[2].name = 'zhangsan'console.log(arr1)//[1,2,&#123;name:'zhangsan',age:18&#125;,3,4]console.log(arr2)//[1,10,&#123;name:'zhangsan',age:18&#125;,3,4] 展开运算符…123456let obj1 = &#123;person:&#123;name:'lisi',age:18&#125;,money:666&#125;let obj2 = &#123;...obj1&#125;obj2.person.age = 20obj2.money = 777console.log(obj1) //&#123;person:&#123;name:'lisi',age:20&#125;,money:666&#125;console.log(obj2) //&#123;person:&#123;name:'lisi',age:20&#125;,money:777&#125; 函数库lodash的_.clone方法123456let obj1 = &#123;person:&#123;name:'lisi',age:18&#125;,money:666&#125;let obj2 = _.clone(obj1)obj2.person.age = 20obj2.money = 777console.log(obj1) //&#123;person:&#123;name:'lisi',age:20&#125;,money:666&#125;console.log(obj2) //&#123;person:&#123;name:'lisi',age:20&#125;,money:777&#125; 深拷贝实现JSON.parse12345678910//浅拷贝let a = &#123; name:'lisi', hobby:[1,2,[3,4],5,6]&#125;let b = JSON.parse(JSON.stringify(a)) //比较简单地实现深拷贝b.name = 'zhangsan'b.hobby[1] = 10 // 新旧对象不是同一块内存//a的值为&#123;name:'lisi',hobby:[1,2,[3,4],5,6]&#125;//b的值为&#123;name:'zhangsan',hobby:[1,10,[3,4],5,6]&#125; 这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。 jQuery.extend()方法jquery 有提供一個$.extend可以用来做 Deep Copy;$.extend(deepCopy, target, object1, [objectN])//第一个参数为true,就是深拷贝 123let obj1 = &#123;person:&#123;name:'lisi',age:18&#125;,money:666&#125;let obj2 = $.extend(true,&#123;&#125;,obj1)console.log(obj1.person === obj2.person) //false 函数库lodash的_.cloneDeep方法123let obj1 = &#123;person:&#123;name:'lisi',age:18&#125;,money:666&#125;let obj2 = _.cloneDeep(obj1)console.log(obj1.person === obj2.person) //false 手写深拷贝123456789101112131415function deepClone(obj)&#123; if(obj === null) return obj //如果是null返回空 if(typeof obj !== 'object') return obj //如果是基本数据类型或者函数，直接返回 //返回新的日期或者正则对象 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); //新建一个对象，如果是数组就是new Array() 否则是 new Object() let cloneObj = new obj.constructor(); for(let key in obj)&#123; if(obj.hasOwnProperty(key))&#123; cloneObj[key] = deepClone(obj[key]); //递归调用 &#125; &#125; return cloneObj;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lawsan.xyz/tags/JavaScript/"}]},{"title":"Vue开发指南之可复用性与组合","slug":"Vue开发指南之可复用性与组合","date":"2020-07-19T04:43:24.000Z","updated":"2020-07-19T06:15:46.047Z","comments":true,"path":"2020/07/19/Vue开发指南之可复用性与组合/","link":"","permalink":"http://lawsan.xyz/2020/07/19/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E4%B8%8E%E7%BB%84%E5%90%88/","excerpt":"","text":"混入基础混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 12345678910111213141516171819202122232425262728var mixin = &#123; data: function () &#123; return &#123; message: 'hello', foo: 'abc' &#125; &#125;, created: function () &#123; console.log('混入对象的钩子被调用') &#125;&#125;new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: 'goodbye', bar: 'def' &#125; &#125;, created: function () &#123; console.log(this.$data) console.log('组件钩子被调用') //混入对象的钩子被调用 // =&gt; &#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125; //组件钩子被调用 &#125;&#125;) 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 全局混入混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。 1234567891011121314// 为自定义的选项 'myOption' 注入一个处理器。Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;)// =&gt; \"hello!\" 请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。 自定义选项合并策略自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数： 12345678910const merge = Vue.config.optionMergeStrategies.computedVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) &#123; if (!toVal) return fromVal if (!fromVal) return toVal return &#123; getters: merge(toVal.getters, fromVal.getters), state: merge(toVal.state, fromVal.state), actions: merge(toVal.actions, fromVal.actions) &#125;&#125; 自定义命令自定义指令全局注册12345678// 注册一个全局自定义指令 `v-focus`Vue.directive('focus', &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;) 局部注册12345678910111213export default&#123; data()&#123; return&#123;&#125; &#125;, directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() &#125; &#125; &#125;&#125; 钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。钩子函数参数指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v-前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。这是一个使用了这些 property 的自定义钩子样例： 1&lt;div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"&gt;&lt;/div&gt; 12345678910111213141516171819Vue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;) 动态指令参数*指令的参数可以是动态的。例如，在 v-mydirective:[argument]=&quot;value&quot; 中，argument 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。函数简写在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写：123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。1&lt;div v-demo=\"&#123; color: 'white', text: 'hello!' &#125;\"&gt;&lt;/div&gt; 1234Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"&#125;) 渲染函数与JSX1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // 标签名称 this.$slots.default // 子节点数组 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 虚拟 DOMVue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：1return createElement('h1', this.blogTitle) createElement 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。createElement 参数 一个 HTML 标签名、组件选项对象，或者resolve 了上述任何一种的一个 async 函数。必填项。 一个与模板中 attribute 对应的数据对象。可选。 子级虚拟节点 (VNodes)，由 createElement() 构建而成，也可以使用字符串来生成“文本虚拟节点”。可选。 见官方文档 插件使用插件通过全局方法 Vue.use() 使用插件。它需要在你调用 new Vue()启动应用之前完成：Vue.use 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。 开发插件Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： 123456789101112131415161718192021222324252627MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive('my-directive', &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 过滤器Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示： 12345&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 你可以在一个组件的选项中定义本地的过滤器（局部）： 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 或者在创建 Vue 实例之前全局定义过滤器： 123456789Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123; // ...&#125;) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。过滤器可以串联： 1&#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。过滤器是 JavaScript 函数，因此可以接收参数： 1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 这里，filterA 被定义为接收三个参数的过滤器函数。其中 message 的值作为第一个参数，普通字符串 &#39;arg1&#39; 作为第二个参数，表达式 arg2 的值作为第三个参数。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"}]},{"title":"Vue开发指南之过渡与动画","slug":"Vue开发指南之过渡与动画","date":"2020-07-18T09:23:27.000Z","updated":"2020-07-19T04:32:39.024Z","comments":true,"path":"2020/07/18/Vue开发指南之过渡与动画/","link":"","permalink":"http://lawsan.xyz/2020/07/18/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/","excerpt":"","text":"前言这篇文章是关于组件/单元素的过渡效果和动画效果，也是上一篇文章的续篇。 进入/离开&amp;列表过渡单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡: 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点这里是一个典型的例子：12345678&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter。CSS过渡常用的过渡都是使用 CSS 过渡。1234567891011121314//html 和 js 部分看上面的代码/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.fade-enter-active &#123; transition: all .3s ease;&#125;.fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.fade-enter, .fade-leave-to/* .fade-leave-active for below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; CSS动画CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。123456789101112131415161718//html 和 js 部分看上面的代码.fade-enter-active &#123; animation: fade-in .5s;&#125;.fade-leave-active &#123; animation: fade-in .5s reverse;&#125;@keyframes fade-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡的类名我们可以通过以下 attribute 来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+)他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。1234567891011121314&lt;link href=\"https://cdn.jsdelivr.net/npm/animate.css@3.5.1\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"example-3\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" //自定义过渡类名 leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 同时使用过渡和动画Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用type attribute 并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。显性的过渡持续时间你可以用 &lt;transition&gt; 组件上的 duration prop 定制一个显性的过渡持续时间 (以毫秒计)：1&lt;transition :duration=\"1000\"&gt;...&lt;/transition&gt; 你也可以定制进入和移出的持续时间：1&lt;transition :duration=\"&#123; enter: 500, leave: 800 &#125;\"&gt;...&lt;/transition&gt; JavaScript钩子12345678910111213&lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 除了enter和leave可以接受el、done两个参数外，其他的都只接受el一个参数; 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=&quot;false&quot;，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 初始渲染的过渡可以通过 appear attribute 设置节点在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。12345678&lt;transition appear appear-class=\"custom-appear-class\" appear-to-class=\"custom-appear-to-class\" (2.1.8+) appear-active-class=\"custom-appear-active-class\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子：123456789&lt;transition appear v-on:before-appear=\"customBeforeAppearHook\" v-on:appear=\"customAppearHook\" v-on:after-appear=\"customAfterAppearHook\" v-on:appear-cancelled=\"customAppearCancelledHook\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 在上面的例子中，无论是 appear attribute 还是 v-on:appear 钩子都会生成初始渲染过渡。多个元素的过渡我们之后讨论多个组件的过渡，对于原生标签可以使用 v-if/v-else。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=\"items.length &gt; 0\"&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 当有相同标签名的元素切换时，需要通过 key attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition&gt; 组件中的多个元素设置 key 是一个更好的实践。示例： 12345678&lt;transition&gt; &lt;button v-if=\"isEditing\" key=\"save\"&gt; Save &lt;/button&gt; &lt;button v-else key=\"edit\"&gt; Edit &lt;/button&gt;&lt;/transition&gt; 在一些场景中，也可以通过给同一个元素的 key attribute 设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：12345&lt;transition&gt; &lt;button v-bind:key=\"isEditing\"&gt; &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 过渡模式（mode） in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。用 out-in 重写之前的开关按钮过渡：123&lt;transition name=\"fade\" mode=\"out-in\"&gt; &lt;!-- ... the buttons ... --&gt;&lt;/transition&gt; 多个组件的过渡多个组件的过渡简单很多 - 我们不需要使用 key attribute。相反，我们只需要使用动态组件：123&lt;transition name=\"component-fade\" mode=\"out-in\"&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt;&lt;/transition&gt; 列表过渡使用&lt;transition-group&gt; 组件可以进行列表渲染动画。在我们深入例子之前，先了解关于这个组件的几个特点： 不同于 &lt;transition&gt;，它会以一个真实元素呈现：默认为一个 &lt;span&gt;。你也可以通过 tag attribute 更换为其他元素。 过渡模式不可用，因为我们不再相互切换特有的元素。 内部元素总是需要提供唯一的 key attribute 值。 CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。列表的进入/离开过渡12345&lt;transition-group name=\"list\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-item\"&gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt; 12345678.list-enter-active, .list-leave-active &#123; transition: all 1s;&#125;.list-enter, .list-leave-to/* .list-leave-active for below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125; 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move class，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name attribute 来自定义前缀，也可以通过 move-class attribute 手动设置。可复用的过渡过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 &lt;transition&gt; 或者 &lt;transition-group&gt;作为根组件，然后将任何子组件放置在其中就可以了。动态过渡在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 name attribute 来绑定动态值。123&lt;transition v-bind:name=\"transitionName\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 状态过渡见官方文档此篇完结","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"}]},{"title":"Vue中的$attrs和$listeners","slug":"Vue中的$attrs和$listeners","date":"2020-07-15T10:46:04.000Z","updated":"2020-07-16T03:22:39.944Z","comments":true,"path":"2020/07/15/Vue中的$attrs和$listeners/","link":"","permalink":"http://lawsan.xyz/2020/07/15/Vue%E4%B8%AD%E7%9A%84$attrs%E5%92%8C$listeners/","excerpt":"","text":"$attrs如果向一个子组件传递数据attribute时，该子组件并没有相应prop定义的attribute时。这些 attribute 会被添加到这个组件的根元素上。示例： 12345678910111213141516171819//父组件&lt;template&gt; &lt;div class=\"home\"&gt; 以下为组件S1的内容 &lt;S1 :foo='foo' :eoo='eoo'/&gt; &lt;/div&gt;&lt;/template&gt;...import S1 from '@/components/S1.vue'data()&#123; return&#123; foo:'I am foo', eoo:'I am eoo', &#125;&#125;,components:&#123; S1&#125;,... 123456789101112//子组件 S1&lt;template&gt; &lt;div&gt; &#123;&#123;foo&#125;&#125; &lt;/div&gt;&lt;/template&gt;...data()&#123; return&#123;&#125;&#125;,props:['foo'],... 我们可以看到只有foo才会显示，而eoo则被添加到根元素中了，即便页面添加了也不会显示的。如果不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。再配合实例的 $attrs property 使用。 1234567891011121314//修改后的子组件S1，添加$attrs，并查看其值&lt;template&gt; &lt;div&gt; &lt;p&gt;foo:&#123;&#123;foo&#125;&#125;&lt;/p&gt; &lt;p&gt;attrs:&#123;&#123;$attrs&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;...data()&#123; return&#123;&#125;&#125;,props:['foo'],inheritAttrs: false,... 我们可以看到在组件的选项中设置 inheritAttrs: false后，组件没有相应prop定义的attribute将会被绑定到$attrs上。 通过对象取值的方法是行不通的，比如$attrs.eoo,但是我们可以通过v-bind=&quot;$attrs&quot;传入其内部组件。 1234567891011121314151617181920212223242526272829//修改后的子组件S1,引入子组件S1Child&lt;template&gt; &lt;div&gt; &lt;p&gt;foo:&#123;&#123;foo&#125;&#125;&lt;/p&gt; &lt;p&gt;attrs:&#123;&#123;$attrs&#125;&#125;&lt;/p&gt; 以下为组件S1Child的内容 &lt;s1-child v-bind=\"$attrs\"&gt;&lt;/s1-child&gt; &lt;/div&gt;&lt;/template&gt;...import S1Child from '@/components/S1Child.vue'data()&#123; return&#123;&#125;&#125;,components:&#123; S1Child,&#125;,props:['foo'],inheritAttrs: false,...//子组件S1Child&lt;template&gt; &lt;div&gt; &lt;p&gt;eoo:&#123;&#123;eoo&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;...props:['eoo'],... 我们可以看到，通过$attrs可以接收组件没有相应prop定义的attribute，并通过prop让其子子组件接收到。那么组件S1Child的信息怎么传递给其父父组件呐？$listeners。 $listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。 123456789101112131415161718192021222324//修改后的父组件，添加绑定事件@upData&lt;template&gt; &lt;div class=\"home\"&gt; 以下为组件S1的内容 &lt;S1 :foo='foo' :eoo='eoo' @upData=\"getS1ChidData\"/&gt; &lt;/div&gt;&lt;/template&gt;...import S1 from '@/components/S1.vue'data()&#123; return&#123; foo:'I am foo', eoo:'I am eoo', &#125;&#125;,components:&#123; S1&#125;,methods:&#123; getS1ChidData(value)&#123; console.log('这是组件S1Chid传过来的数据：',value) &#125;&#125;... 1234567891011121314151617181920212223242526272829303132333435//修改后的子组件S1,绑定$listeners&lt;template&gt; &lt;div&gt; &lt;p&gt;foo:&#123;&#123;foo&#125;&#125;&lt;/p&gt; &lt;p&gt;attrs:&#123;&#123;$attrs&#125;&#125;&lt;/p&gt; 以下为组件S1Child的内容 &lt;s1-child v-bind=\"$attrs\" v-on=\"$listeners\"&gt;&lt;/s1-child&gt; &lt;/div&gt;&lt;/template&gt;...import S1Child from '@/components/S1Child.vue'data()&#123; return&#123;&#125;&#125;,components:&#123; S1Child,&#125;,props:['foo'],inheritAttrs: false,...//子组件S1Child&lt;template&gt; &lt;div&gt; &lt;p&gt;eoo:&#123;&#123;eoo&#125;&#125;&lt;/p&gt; &lt;button @click=\"startUpData\"&gt;upData&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;...props:['eoo'],methods:&#123; startUpData()&#123; this.$emit('upData','我是S1Child传过来的数据！') &#125;&#125;... 通过点击组件S1Child中的按钮触发当前实例上的upData事件,但是并不能直接触发非父组件的upData事件，需要通过v-on=&quot;$listeners&quot;也就通过$listeners接收了父组件的事件监听器并传给内部组件。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"}]},{"title":"Vue开发指南之深入了解组件","slug":"Vue开发指南之深入了解组件","date":"2020-07-14T10:46:04.000Z","updated":"2020-07-18T09:19:44.196Z","comments":true,"path":"2020/07/14/Vue开发指南之深入了解组件/","link":"","permalink":"http://lawsan.xyz/2020/07/14/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/","excerpt":"","text":"前言这篇文章是上一篇文章的续文，让我们一起了解组件吧。 组件注册全局组件与局部组件组件名称首字母大写命名（MyComponentName）或者短横线分隔命名（my-component-name）全局组件： 1Vue.component('my-component-name', &#123; /* ... */ &#125;) 局部组件注意一点：局部注册的组件在其子组件中不可用(也就是说局部组件只在当前注册的组件中可用，当前注册的组件的子组件不可用，要在子组件重新注册)。 1234567var ComponentA = &#123; /* ... */ &#125;new Vue(&#123; el: '#app', components: &#123; 'component-a': ComponentA, &#125;&#125;) 为什么需要局部组件？全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。 模块系统在读下文之前，先来了解一些前端模块化的知识吧一文带你了解前端模块化在模块系统中局部注册在模块系统中，组件总是以单文件的形式存在，而这些单文件我们习惯把它们放在components文件夹下。如果你是有vue-cli构建的项目，你们就会发现此规范。 12345678910import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default &#123; components: &#123; ComponentA, ComponentC &#125;, // ...&#125; 基础组件的自动化全局注册可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。如果你恰好使用了 webpack (或在内部使用了 webpack 的 Vue CLI 3+)，那么就可以使用 require.context 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码： 1234567891011121314151617181920212223import Vue from 'vue'const requireComponent = require.context( // 其组件目录的相对路径 './components', // 是否查询其子目录 false, // 匹配基础组件文件名的正则表达式 /Base[A-Z]\\w+\\.(vue|js)$/)requireComponent.keys().forEach((fileName) =&gt; &#123; // 获取组件配置 const componentConfig = requireComponent(fileName) // 获取组件的 PascalCase 命名 const componentName = fileName .replace(/^\\.\\/_/, '') .replace(/\\.\\w+$/, '') .split('-') .map((kebab) =&gt; kebab.charAt(0).toUpperCase() + kebab.slice(1)) .join('') // 全局注册组件 Vue.component(componentName, componentConfig.default || componentConfig)&#125;) require.context是啥？一个webpack的api,通过执行require.context函数获取一个特定的上下文,主要用来实现自动化导入模块,在前端工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个api,它会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用import导入模块;require.context函数接受三个参数: directory {String} -读取文件的路径 useSubdirectories {Boolean} -是否遍历文件的子目录 regExp {RegExp} -匹配文件的正则 PropProp的大小写驼峰命名和短横线分隔命名，两个是可以互用的，相互等价。如果使用字符串模板就没有这个限制。 12345Vue.component('blog-post', &#123; // 在 JavaScript 中是 camelCase 的 props: ['postTitle'], template: '&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'&#125;) 12&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title&#x3D;&quot;hello!&quot;&gt;&lt;&#x2F;blog-post&gt; Prop类型没有指定类型的情况： 1props: ['title', 'likes', 'isPublished', 'commentIds', 'author'] 通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型,type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。 123456789props: &#123; title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor&#125; 传递静态或动态 Prop静态传值 1&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt; 动态态传值 1&lt;blog-post :title=\"post.title\"&gt;&lt;/blog-post&gt; 可传值的类型有 数字、布尔值、数组、对象等 Prop的单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。这里有两种常见的试图变更一个 prop 的情形： 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。123456props: ['initialCounter'],data: function () &#123; return &#123; counter: this.initialCounter &#125;&#125; 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：123456props: ['size'],computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125;&#125; 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。 Prop验证多种验证方式如下：123456789101112131415161718192021222324252627282930313233Vue.component('my-component', &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;) 非 Prop 的 Attribute如果在一个组件中传递数据，二组件没有用prop去接收，那么这个数据就会成为非 Prop 的 Attribute。而这些 attribute 会被添加到这个组件的根元素上。 替换/合并已有的 Attribute想象一下 &lt;bootstrap-date-input&gt; 的模板是这样的： 1&lt;input type=\"date\" class=\"form-control\"&gt; 为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名： 1234&lt;bootstrap-date-input data-date-picker=\"activated\" class=\"date-picker-theme-dark\"&gt;&lt;/bootstrap-date-input&gt; 在这种情况下，我们定义了两个不同的 class 的值：form-control 和 date-picker-theme-dark;对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type=”text” 就会替换掉 type=”date”,但是class 和 style attribute 两边的值会被合并起来，从而得到最终的值：form-control date-picker-theme-dark。禁用 Attribute 继承如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如： 1234Vue.component('my-component', &#123; inheritAttrs: false, // ...&#125;) 这尤其适合配合实例的 $attrs property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如： 1234&#123; required: true, placeholder: 'Enter your username'&#125; 有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写基础组件的时候是常会用到的： 1234567891011121314Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; &lt;/label&gt; `&#125;) 注意 inheritAttrs: false 选项不会影响 style 和 class 的绑定。 自定义事件事件名事件名遵循完全匹配的机制，v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。因此，我们推荐你始终使用 kebab-case 的事件名。 自定义v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `&#125;) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model=\"lovingVue\"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 将原生事件绑定到组件你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符： 12345678910&lt;base-input v-on:focus.native=\"onFocus\"&gt;&lt;/base-input&gt;//根元素是label&lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt;&lt;/label&gt; v-on=&quot;$listeners&quot;将所有的事件监听器指向这个组件的某个特定的子元素 1234567891011121314151617181920212223242526272829303132Vue.component('base-input', &#123; inheritAttrs: false, props: ['label', 'value'], computed: &#123; inputListeners: function () &#123; var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign(&#123;&#125;, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 &#123; // 这里确保组件配合 `v-model` 的工作 input: function (event) &#123; vm.$emit('input', event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on=\"inputListeners\" &gt; &lt;/label&gt; `&#125;) .sync 修饰符prop的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图： 1this.$emit('update:title', newTitle) 然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如： 1234&lt;text-document v-bind:title=\"doc.title\" v-on:update:title=\"doc.title = $event\"&gt;&lt;/text-document&gt; 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符： 1&lt;text-document v-bind:title.sync=\"doc.title\"&gt;&lt;/text-document&gt; 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’”是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 v-model。当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用： 1&lt;text-document v-bind.sync=\"doc\"&gt;&lt;/text-document&gt; 这样会把 doc 对象中的每一个 property (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。 插槽 在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的 attribute。 插槽内容Vue 实现了一套内容分发的 API，将 &lt;slot&gt; 元素作为承载分发内容的出口。它允许你像这样合成组件： 123&lt;navigation-link url=\"/profile\"&gt; Your Profile&lt;/navigation-link&gt; 然后你在 &lt;navigation-link&gt; 的模板中可能会写为： 123456&lt;a v-bind:href=\"url\" class=\"nav-link\"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/a&gt; 当组件渲染的时候，&lt;slot&gt;&lt;/slot&gt; 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML。 如果 &lt;navigation-link&gt; 的 template 中没有包含一个 &lt;slot&gt; 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。 编译作用域当你想在一个插槽中使用数据时，例如： 1234&lt;navigation-link url=\"/profile\"&gt; Logged in as &#123;&#123; user.name &#125;&#125; &#123;&#123;url&#125;&#125; //这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是传递给`&lt;navigation-link&gt;`的而不是在 `&lt;navigation-link&gt;` 组件*内部*定义的。&lt;/navigation-link&gt; 该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问 &lt;navigation-link&gt;的作用域。例如 url 是访问不到的。 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 后备内容（默认内容）有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 &lt;submit-button&gt; 组件中： 123&lt;button type=\"submit\"&gt; &lt;slot&gt;Submit&lt;/slot&gt;&lt;/button&gt; 现在当我在一个父级组件中使用 &lt;submit-button&gt; 并且不提供任何插槽内容时： 12&lt;submit-button&gt;&lt;/submit-button&gt;//内容默认为Submit&lt;submit-button&gt;Save&lt;/submit-button&gt;//内容替换为Save 具名插槽具名插槽:有时我们需要多个插槽，这样就可以使用&lt;slot&gt;元素中的一个特殊的 attribute：name,这个 attribute 可以用来定义额外的插槽。一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。 1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt; 在向具名插槽提供内容的时候，我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称： 1234567891011121314151617&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; //上面这两行代码相当于下面的&lt;template&gt;的内容 &lt;template v-slot:default&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; 现在 &lt;template&gt; 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 v-slot 的 &lt;template&gt; 中的内容都会被视为默认插槽的内容(也就是没有没有名称的插槽 name=&quot;default&quot;)。 注意 v-slot 只能添加在 &lt;template&gt; 上 (只有一种例外情况)，这一点和已经废弃的 slot attribute 不同。 作用域插槽有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 &lt;current-user&gt; 组件： 123&lt;span&gt; &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt;&lt;/span&gt; 我们可能想换掉备用内容，用名而非姓来显示。如下： 123&lt;current-user&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。然而上述代码不会正常工作，因为只有 &lt;current-user&gt; 组件可以访问到 user 而我们提供的内容是在父级渲染的。为了让 user 在父级的插槽内容中可用，我们可以将 user 作为 &lt;slot&gt; 元素的一个 attribute 绑定上去： 12345&lt;span&gt; &lt;slot v-bind:user=\"user\"&gt; &#123;&#123; user.lastName &#125;&#125; &lt;/slot&gt;&lt;/span&gt; 绑定在 &lt;slot&gt; 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字： 12345&lt;current-user&gt; &lt;template v-slot:default=\"slotProps\"&gt; //slotProps可以任意取名称的 &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt;&lt;/current-user&gt; 独占默认插槽的缩写语法在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 v-slot直接用在组件上： 123&lt;current-user v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125;&lt;/current-user&gt; 这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 v-slot 被假定对应默认插槽： 123&lt;current-user v-slot=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125;&lt;/current-user&gt; 注意默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确： 1234567&lt;!-- 无效，会导致警告 --&gt;&lt;current-user v-slot=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;template v-slot:other=\"otherSlotProps\"&gt; slotProps is NOT available here &lt;/template&gt;&lt;/current-user&gt; 只要出现多个插槽，请始终为所有的插槽使用完整的基于 &lt;template&gt; 的语法： 123456789&lt;current-user&gt; &lt;template v-slot:default=\"slotProps\"&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/template&gt; &lt;template v-slot:other=\"otherSlotProps\"&gt; ... &lt;/template&gt;&lt;/current-user&gt; 解构插槽 PropES6的解构赋值语法 1234//&#123; user: person &#125; 可以将user重名为person ；&#123; user = &#123; firstName: 'Guest' &#125; &#125; 定义默认值&lt;current-user v-slot=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125; //&#123;&#123;person.firstname&#125;&#125;&lt;/current-user&gt; 动态插槽名动态参数:从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数.比如，当 eventName 的值为 “focus” 时，v-on:[eventName] 将等价于 v-on:focus。动态指令参数也可以用在 v-slot 上，来定义动态的插槽名： 12345&lt;base-layout&gt; &lt;template v-slot:[dynamicSlotName]&gt; ... &lt;/template&gt;&lt;/base-layout&gt; 具名插槽的缩写跟 v-on 和v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header： 12345&lt;base-layout&gt; &lt;template #header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt;&lt;/base-layout&gt; 然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的： 1234&lt;!-- 这样会触发一个警告 --&gt;&lt;current-user #=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 如果你希望使用缩写的话，你必须始终以明确插槽名取而代之： 123&lt;current-user #default=\"&#123; user &#125;\"&gt; &#123;&#123; user.firstName &#125;&#125;&lt;/current-user&gt; 废弃了的语法 v-slot 指令自 Vue 2.6.0 起被引入，提供更好的支持 slot 和 slot-scope attribute 的 API 替代方案。在接下来所有的 2.x 版本中 slot 和 slot-scope attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。带有 slot attribute 的具名插槽 12345678//slot &lt;template slot=\"header\"&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; //v-slot &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; 有 slot-scope attribute 的作用域插槽在 &lt;template&gt; 上使用特殊的 slot-scope attribute，可以接收传递给插槽的 prop ： 1234567891011&lt;slot-example&gt; &lt;template slot=\"default\" slot-scope=\"slotProps\"&gt; &#123;&#123; slotProps.msg &#125;&#125; &lt;/template&gt;&lt;/slot-example&gt;//v-slot&lt;slot-example&gt; &lt;template v-slot:default=\"&#123;msg&#125;\"&gt; &#123;&#123; msg &#125;&#125; &lt;/template&gt;&lt;/slot-example&gt; slot-scope attribute 也可以直接用于非 &lt;template&gt; 元素 (包括组件)： 12345&lt;slot-example&gt; &lt;span slot-scope=\"&#123; msg &#125;\"&gt; &#123;&#123; msg &#125;&#125; &lt;/span&gt;&lt;/slot-example&gt; 动态组件 &amp; 异步组件在动态组件上使用 keep-alive当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。多标签界面是典型的切换问题。次切换新标签的时候，Vue 都创建了一个新的 currentTabComponent 实例。重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 &lt;keep-alive&gt; 元素将其动态组件包裹起来。 1234&lt;!-- 失活的组件将会被缓存！--&gt;&lt;keep-alive&gt; &lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件异步从服务器获取组件： 1234567891011121314Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;)//ES6 +webpackVue.component( 'async-webpack-example', // 这个动态导入会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component')) 当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数： 123456new Vue(&#123; // ... components: &#123; 'my-component': () =&gt; import('./my-async-component') &#125;&#125;) 处理加载状态这里的异步组件工厂函数也可以返回一个如下格式的对象： 12345678910111213const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;) 写在最后Vue开发指南之深入了解组件篇整理完了，下一篇过渡动画。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"}]},{"title":"Vue开发指南之基础篇","slug":"Vue开发指南之基础篇","date":"2020-07-13T11:43:34.000Z","updated":"2020-07-18T09:11:47.709Z","comments":true,"path":"2020/07/13/Vue开发指南之基础篇/","link":"","permalink":"http://lawsan.xyz/2020/07/13/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"","text":"前言写这编文章也是为了回顾之前学的Vue，查漏补缺。此篇文章涵盖Vue的基本知识以及开发技巧等。这篇文章不讲Vue的相关原理，只会讲Vue 2.0在开发中常见的知识点。你准备好了吗？ 安装CDN引入1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; NPM1npm install vue 命令行工具（CLI）安装Vue-cli npm install -g @vue/cli利用脚手架创建一个Vue项目 vue create 项目名称 这是vue-cli3创建项目的命令；vue-cli2创建一个Vue项目 vue init webpack 项目名称； Vue实例实例&amp;&amp;数据&amp;&amp;方法当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 12345678910111213141516var data = &#123;a:1&#125;var vm = new Vue(&#123; el:'#app', data:data, methods:&#123;&#125;, props:[], components:&#123;&#125;, created:function()&#123;&#125; ....&#125;)vm.a == data.a //truevm.a = 2; data.a == 2 //true //反之亦然data.a = 3; vm.a == 3 //true vm.$data === data // =&gt; truevm.$el === document.getElementById('app') // =&gt; true 当数据被Object.freeze()时，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。 生命周期beforeCreate：只是初始化一些生命周期函数和默认事件，其他的均未创建。created：初始化data和methods了。beforeMount：数据已经准备好了，还没渲染到页面。mounted：将编译好的HTML挂载到页面，完成了渲染。beforeUpdate：数据被修改，当是还没被重新渲染到页面。updated：重新渲染页面，页面已经是修改后的了。beforeDestroy：Vue实例进入销毁状态，data、methods，以及过滤器和指令都是可以用的。destroyed：Vue实例已经被销毁。看懂下面这张图就行 模板语法插值文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值。 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt; 无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定： 1&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt; 原始HTML 1&lt;p&gt;Using v-html directive: &lt;span v-html&#x3D;&quot;rawHtml&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; v-html可能会引发XSS攻击，因此绝不要对用户提供的内容使用插值。Attribute &amp;&amp; 表达式 12&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125; 指令v-if:判断true或者flase，是否插入元素。v-else:经常和v-if一起用,还有v-else-if。v-for:遍历循环，注意要绑定:key。v-on:处理事件，v-on:事件名=&quot;表达式||函数名&quot;,简写@事件名=&quot;函数名&quot;。v-bind:绑定属性，v-bind:属性名=&quot;属性值&quot;简写:属性名=&quot;属性值&quot;。v-show:原始的显示与隐藏，与v-if不同，v-if是插入元素或者删除元素，开销大。v-html:插人原始HTML，插入的元素要用 &gt;&gt;&gt; css选择器渲染。v-text:插入文本。v-cloak:解决vue解析时出现页面闪烁问题。v-model:双向数据绑定。 修饰符@submit.prevent=&quot;fName&quot;:.prevent阻止事件默认行为。@click.stop=&quot;fName&quot;:.stop阻止事件冒泡,.capture可以发生事件捕获，.self只触发本身。@keyup.enter=&quot;fName&quot;:.enter键盘回车事件，当然还有很多按键，请看我的另一篇文章Vue监听回车事件@keyup。@click.once=&quot;fName&quot;:.once事件只触发一次。&lt;el-input @keyup.enter.native=&quot;search&quot;&gt;&lt;/el-input&gt;:.native在自定义组件中，要加native才能监听原生的事件。&lt;input v-model.lazy=&quot;msg&quot; &gt;:.lazy惰性更新，也就是说不会更新那么快，等输入完成后才更新。&lt;input v-model.trim=&quot;msg&quot;&gt;:.trim去除前后空格。&lt;input v-model.number=&quot;msg&quot;&gt;:.number将输入的字符串变成数字。.sync:对prop进行双向绑定,用法如下 1234&#x2F;&#x2F;父组件&lt;fa-comp :fatest.sync&#x3D;&quot;test&quot;&gt;&lt;&#x2F;fa-comp&gt;&#x2F;&#x2F;子组件this.$emit(&#39;update:fatest,sontest); .passive:提升移动端的性能，大概解释就是每次滚动都会有一个默认事件触发，加了这个就是告诉浏览器，不需要查询，不需要触发这个默认事件。利用vue中的修饰符能让你的开发事倍功半。 计算属性和侦听器基础实例模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护，所以，对于任何复杂逻辑，你都应当使用计算属性。 1&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;&#x2F;p&gt; 1234567computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125;&#125; 计算属性缓存 vs 方法123456// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。 计算属性 vs 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。 123456789101112131415&#x2F;&#x2F;computed实现属性计算computed: &#123; fullName: function () &#123; return this.firstName + &#39; &#39; + this.lastName &#125; &#125;, &#x2F;&#x2F;watch实现属性计算 watch: &#123; firstName: function (val) &#123; this.fullName &#x3D; val + &#39; &#39; + this.lastName &#125;, lastName: function (val) &#123; this.fullName &#x3D; this.firstName + &#39; &#39; + val &#125; &#125; 计算属性的 setter计算属性默认只有 getter，不过在需要时你也可以提供一个 setter： 1234567891011121314computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; 监听器虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。除了 watch 选项之外，您还可以使用命令式的 vm.$watch。 Class 与 Style 绑定绑定 HTML Class对象语法我们可以传给 v-bind:class 一个对象，以动态地切换 class： 12345678&lt;div :class&#x3D;&quot;&#123; active: isActive &#125;&quot; :class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F;两种形式&#x2F;&#x2F;...data: &#123; classObject: &#123; active: true, &#39;text-danger&#39;: false &#125;&#125; 上面的语法表示 active 这个 class 存在与否将取决于数据 property isActive 的布尔值。数组语法 1234567&lt;div :class&#x3D;&quot;[activeClass, errorClass]&quot; :class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F;也可以使用三元表达式&#x2F;&#x2F;...data: &#123; isActive:false, activeClass: &#39;active&#39;, errorClass: &#39;text-danger&#39;&#125; 绑定内联样式对象语法 1&lt;div :style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt; 数组语法 1&lt;div v-bind:style&#x3D;&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;&#x2F;div&gt; 和绑定HTML Class 大同小异，这里就不做多描述了。注意：当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，Vue.js 会自动侦测并添加相应的前缀。前缀多重值你可以为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值,如下 1&lt;div :style&#x3D;&quot;&#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &#125;&quot;&gt;&lt;&#x2F;div&gt; 这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。 条件渲染123456789101112&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt; A&lt;&#x2F;div&gt;&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt; B&lt;&#x2F;div&gt;&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt; C&lt;&#x2F;div&gt;&lt;div v-else&gt; Not A&#x2F;B&#x2F;C&lt;&#x2F;div&gt; v-if,v-else,v-else-if,v-for,v-show在前面的指令那里都有解释，这里就不做多描述了。 不推荐同时使用 v-if 和 v-for;当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级,这意味着 v-if 将分别重复运行于每个 v-for 循环中。注意Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外。也就是说v-if切换是，复用了已有元素。要用key 管理可复用的元素。 列表渲染在 v-for 里使用对象123&lt;div v-for&#x3D;&quot;(value, name, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;&#x2F;div&gt; 在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。 维护状态当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute： 123&lt;div v-for&#x3D;&quot;item in items&quot; v-bind:key&#x3D;&quot;item.id&quot;&gt; &lt;!-- 内容 --&gt;&lt;&#x2F;div&gt; 不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。 数组更新检测Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括(可以改变原数组的方法)：push,pop,shift,unshift,splice,sort,reverse;当然也可以使用数组替换，用新数组替换原来的旧数组，达到数据变化以驱动视图更新。例如 filter()、concat() 和 slice(),虽然不能改变原数组，但是可以赋值替换的方式来改变原数组。 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。 在 v-for 里使用值范围v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。 1234&lt;div&gt; &lt;span v-for&#x3D;&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&#x2F;&#x2F;结果：1,2,3...10 事件处理可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。 1&lt;button v-on:click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;button&gt; 除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法： 1&lt;button v-on:click&#x3D;&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;&#x2F;button&gt; 事件修饰符，在前面有说了，这里就不做多描述。 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。.exact修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt; 鼠标按钮修饰符.left,.right,.middle; 表单输入绑定基础用法v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源，v-model是双向数据绑定的；v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。绑定文本：&lt;input v-model=&quot;message&quot; &gt;多行文本：&lt;textarea v-model=&quot;message&quot; &gt;&lt;/textarea&gt;复选框:&lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;单选框：12&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt; 选择框：123456&lt;select v-model&#x3D;&quot;selected&quot; multiple&gt; &#x2F;&#x2F;如果可以多选，加上multiple &lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt; &lt;option&gt;A&lt;&#x2F;option&gt; &lt;option&gt;B&lt;&#x2F;option&gt; &lt;option&gt;C&lt;&#x2F;option&gt;&lt;&#x2F;select&gt; 值绑定12345678910&lt;!-- 当选中时，&#96;picked&#96; 为字符串 &quot;a&quot; --&gt;&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;picked&quot; value&#x3D;&quot;a&quot;&gt;&lt;!-- &#96;toggle&#96; 为 true 或 false --&gt;&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;toggle&quot;&gt;&lt;!-- 当选中第一个选项时，&#96;selected&#96; 为字符串 &quot;abc&quot; --&gt;&lt;select v-model&#x3D;&quot;selected&quot;&gt; &lt;option value&#x3D;&quot;abc&quot;&gt;ABC&lt;&#x2F;option&gt;&lt;&#x2F;select&gt; 修饰符.trim,.lazy,number;在模板语法里面有讲解了，这里就不做多描述。组件组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。 （单个根元素）*示例：123456789&#x2F;&#x2F; 定义一个名为 button-counter 的新组件Vue.component(&#39;button-counter&#39;, &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: &#39;&lt;button v-on:click&#x3D;&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;&#x2F;button&gt;&#39;&#125;) 组件复用你可以将组件进行任意次数的复用：12345&lt;div id&#x3D;&quot;components-demo&quot;&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt; &lt;button-counter&gt;&lt;&#x2F;button-counter&gt;&lt;&#x2F;div&gt; 注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。组件之间是独立的，复用的时候也会产生独立的作用域。 data 必须是一个函数*一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：12345data: function () &#123; return &#123; count: 0 &#125;&#125; 这也就是为什么，组件复用的时候，复用组件之间的数据是不互通的，作用域相互独立。为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：全局注册和局部注册。至此，我们的组件都只是通过 Vue.component 全局注册的：组件通信父向子传props：1234567&#x2F;&#x2F;...父组件&lt;son :title&#x3D;&quot;hello&quot; &gt;&lt;&#x2F;son&gt;&#x2F;&#x2F;...&#x2F;&#x2F;...子组件&#123;&#123;title&#125;&#125;props:[title]&#x2F;&#x2F;... 子传父$emit:子组件通过$emit触发父组件的事件，而达到数据传递的效果。12345678910111213141516&#x2F;&#x2F;...父组件&lt;son @getSonData&#x3D;&quot;sonData&quot; &gt;&lt;&#x2F;son&gt;methods:&#123; sonData(data)&#123; console.log(data) &#x2F;&#x2F;data为子组件传递过来的数据 &#125;&#125;&#x2F;&#x2F;...&#x2F;&#x2F;...子组件&lt;button @click&#x3D;&quot;sendData&quot;&gt;向父组件传数据&lt;&#x2F;button&gt;methods:&#123; sendData()&#123; this.$emit(&#39;getSonData&#39;,&#39;我是子组件传递过来的数据&#39;) &#125;&#125;&#x2F;&#x2F;... EventBus 事件总线传递数据…在组件上使用v-model1&lt;input v-model&#x3D;&quot;searchText&quot;&gt; 等价于1234&lt;input v-bind:value&#x3D;&quot;searchText&quot; v-on:input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;&gt; 当用在组件上时，v-model 则会这样：1234&lt;custom-input v-bind:value&#x3D;&quot;searchText&quot; v-on:input&#x3D;&quot;searchText &#x3D; $event&quot;&gt;&lt;&#x2F;custom-input&gt; 为了让它正常工作，这个组件内的 必须： 将其 value attribute 绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出。写成代码之后是这样的：123456789Vue.component('custom-input', &#123; props: ['value'], template: ` &lt;input v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; `&#125;) 现在 v-model 就应该可以在这个组件上完美地工作起来了：1&lt;custom-input v-model&#x3D;&quot;searchText&quot;&gt;&lt;&#x2F;custom-input&gt; 通过插槽分发内容：和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样： 123&lt;alert-box&gt; Something bad happened.&lt;&#x2F;alert-box&gt; 幸好，Vue 自定义的 &lt;slot&gt;元素让这变得非常简单： 12345678Vue.component('alert-box', &#123; template: ` &lt;div class=\"demo-alert-box\"&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 动态组件有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里：上述内容可以通过 Vue 的 元素加一个特殊的 is attribute 来实现： 12&lt;!-- 组件会在 &#96;currentTabComponent&#96; 改变时改变 --&gt;&lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt; 在上述示例中，currentTabComponent 可以包括:已注册组件的名字，或一个组件的选项对象 解析 DOM 模板时的注意事项有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部。这会导致我们使用这些有约束条件的元素时遇到一些问题。例如： 123&lt;table&gt; &lt;blog-post-row&gt;&lt;&#x2F;blog-post-row&gt;&lt;&#x2F;table&gt; 这个自定义组件 &lt;blog-post-row&gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法： 123&lt;table&gt; &lt;tr is&#x3D;&quot;blog-post-row&quot;&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的： 字符串 (例如：template: &#39;...&#39;) 单文件组件 (.vue) &lt;script type=&quot;text/x-template&quot;&gt; 写在最后 Vue的基础篇就到这里结束，下篇深入了解组件。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"}]},{"title":"HTTP1.0、HTTP1.1与HTTP2.0有啥变化？","slug":"HTTP1.0、HTTP1.1与HTTP2.0有啥变化？","date":"2020-07-13T04:25:45.000Z","updated":"2020-07-13T05:34:13.400Z","comments":true,"path":"2020/07/13/HTTP1.0、HTTP1.1与HTTP2.0有啥变化？/","link":"","permalink":"http://lawsan.xyz/2020/07/13/HTTP1.0%E3%80%81HTTP1.1%E4%B8%8EHTTP2.0%E6%9C%89%E5%95%A5%E5%8F%98%E5%8C%96%EF%BC%9F/","excerpt":"","text":"前言计算机网络是一个开发人员的基础知识，今天我们就来聊聊HTTP的发展历史吧。影响一个网络的因素有：带宽：带宽的大小决定你网络的速率，比如100Mbps的宽带，理论上每秒下载量100Mbps/8 = 12.5m;上行一般都较小，大概30Mbps左右。延迟：有时候你打游戏的时候，打的正爽，然后网络延时了（460）；在浏览器中，可能是以下原因： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 6个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。HTTP协议是啥？ HTTP协议 ：Hyper Text Transfer Protocol（超文本传输协议）,是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP 0.9HTTP/0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP/0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。HTTP/0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。一次HTTP/0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。 HTTP 1.0在HTTP 1.0中对上一代的版本添加了很多功能： 请求与响应支持头域 响应对象以一个响应状态行开始 响应对象不只限于超文本 开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法 支持长连接（但默认还是使用短连接），缓存机制，以及身份认证 缺点：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。 HTTP 1.1 是目前使用最广泛的协议版本，相对于HTTP/1.0新增了以下内容： 引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接； 多了一些缓存处理字段HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。 1.1版还新增了许多请求方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。 引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。 采用分块传输编码，对于一些很耗时的动态操作，服务器需要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer），这是支持文件断点续传的基础。缺点：虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。 HTTP 2.0HTTP 2.0 主要基于SPDY协议。HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。SPDY协议是啥？它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是尽量减少TCP连接数。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。 HTTP 1.x协议的缺陷 HTTP 1.0 一个TCP连接只能发起一个HTTP请求，在资源多面前，每次连接都要3次TCP握手还有断开的4次握手，非常费时间。 HTTP 1.1 一个TCP连接能发起多个HTTP请求，但是会出现队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。 单向请求，只能由客户端发起。 请求报文与响应报文首部信息冗余量大。 数据未压缩，导致数据的传输量大。HTTP1.1与HTTP2.0速度比较HTTP 2.0的特点HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。 二进制分帧：HTTP 2.0 的所有帧都采用二进制编码；在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。 为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。 多路复用：多路复用允许同时通过单一的HTTP/2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2.0不再依赖多个TCP 连接去处理更多并发的请求。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端根据每个帧首部的流标识符把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。 头部压缩：随着web功能越来越复杂，请求数量越来越多，随之而来的就是头部的流量越来越多，并且在建立初次链接之后的链接也要发送user-agent等信息，是在是一种浪费。因此，http2提出了对请求和响应的头部进行压缩，即不再只是压缩主题部分，这种压缩方式就是HAPCK — 其设计简单而灵活。 服务器推送：服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。 更多安全：HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。 写在最后版本更新都是为了解决上一代的棘手问题，HTTP3.0协议基于QUIC，（Quick UDP Internet Connections)基于UDP的传输层协议。计算机网络在发明至今发展飞快，技术迭代迅速，科技的进步也给我们的生活带来了便利。好了，就写到这了！","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://lawsan.xyz/tags/HTTP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://lawsan.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"函数柯里化","slug":"函数柯里化","date":"2020-07-12T15:03:50.000Z","updated":"2020-07-13T05:41:01.730Z","comments":true,"path":"2020/07/12/函数柯里化/","link":"","permalink":"http://lawsan.xyz/2020/07/12/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/","excerpt":"","text":"什么是柯里化？在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。举个例子: 1234567function addFn(a,b)&#123; return a + b&#125;add(1,2)//3//如果现在有一个柯里化函数curriedAddlet add= curriedAdd(1）add(2)//3 满足以上条件的curriedAdd 的函数可以用以下代码段实现： 12345function curriedAdd(x)&#123; return function(y)&#123; return x + y &#125;&#125; 柯里化函数实现函数柯里化的好处：参数复用。本质上是降低通用性，提高适用性。这个curriedAdd 的实现表明了实现 Currying 的一个基础 —— Currying 延迟求值的特性需要用到 JavaScript 中的作用域——说得更通俗一些，我们需要使用作用域来保存上一次传进来的参数(闭包)。对curriedAdd抽象化： 123456789//ES5function curring(fn)&#123; var args = [].slice.call(arguments,1)//类数组对象转数组，截取参数 return function()&#123; var newArgs = args.concat([].slice.call(arguments)) //合并参数 return fn.apply(this.newArgs) &#125;&#125;var addCurry = curry(add, 1);addCurry(2) // 3 123456//ES6function curring(fn,...args1)&#123; return function(...args2)&#123; fn(...args1,...args2) &#125;&#125; 以上实现也只是一个简单的curring，而且只适用于两个参数的函数。让我们用递归来实现自动Curring化。 12345678910111213141516//ES5function trueCurring(fn,args)&#123; length = fn.length args = args || [] return function()&#123; var _agrs = args.slice(0), for(var i = 0;i&lt;arguments.length;i++)&#123; _args.push(arguments[i]) &#125; if(_args.length &lt; length)&#123; return trueCurring.call(this,fn,_args) &#125;else&#123; return fn.apply(this._args) &#125; &#125;&#125; 12345678910//ES6function trueCurring(fn,...args)&#123; //...args 剩余全部参数 if(args.length &gt;= fn.length)&#123; //一次全部传完 return fn(...args) &#125; return function(...args2)&#123; return trueCurring(fn,...args,...args2) &#125;&#125; 实现基本思路：比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。 写在最后工具库Lodsh函数的bind方法和curring在功能上有很大的相似。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lawsan.xyz/tags/JavaScript/"}]},{"title":"一文带你了解前端模块化","slug":"一文带你了解前端模块化","date":"2020-07-12T10:05:20.000Z","updated":"2020-07-12T13:31:40.456Z","comments":true,"path":"2020/07/12/一文带你了解前端模块化/","link":"","permalink":"http://lawsan.xyz/2020/07/12/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"前言随着项目越来越复杂，我们写的代码也越来越多了。代码越来越难维护，全局的命名污染，依赖不明确等等。为了解决此问题，衍生有许多模块化规范。前端模块化发展历程： 无模块化 ==&gt; CommonJS规范 ==&gt; AMD规范 ==&gt; CMD规范 ==&gt; ES6模块化 模块化是个啥？在ES5中，只有全局作用域和函数作用域，一旦在函数体中声明变量没有添加 var，就会造成全局污染。在ES6中有了let，const，这样就有了块作用域。模块化：指解决一个复杂的问题时自顶向下把系统划分成若干模块的过程，有多种属性，分别反映其内部特性；将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起；块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信；模块化组成：数据（内部属性），操作数据的行为（内部函数）。ES5中怎么实现模块化？ 原始写法：无模块可言，会污染全局作用域，看不出依赖关系。123456function foo()&#123; //doSomethings&#125;function bar()&#123; //doSomethings&#125; 对象写法：对象会暴露所有模块成员，内部状态可以被外部改写。123456789var myModule = new Object(&#123; count:0, foo:function()&#123; //doSomethings &#125;, bar:function()&#123; //doSomethings &#125;&#125;) 立即执行函数(IIFE):避免暴露私有成员，数据是私有的, 外部只能通过暴露的方法操作。123456789101112var myModule = (function()&#123; var count = 0 var increaseCount = function()&#123; count++ //doSomethings &#125;, var decreaseCount = function()&#123; count-- //doSomethings &#125; return &#123;increaseCount,decreaseCount&#125; //ES6简写，ES5 ==&gt; &#123;increaseCount:increaseCount,...&#125;&#125;)() **IIFE的增强（依赖引入）12345678var myModule = (function($)&#123; var _$body = $(\"body\") var logBody = function()&#123; console.log(_$body) //doSomethings &#125; return &#123;logBody&#125;&#125;)(jQuery) 无模块化比如以下代码：1234&lt;script src=\"jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"bootstrap.min.js\"&gt;&lt;/script&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;script src=\"do.js\"&gt;&lt;/script&gt; 简单粗暴引入文件即可，但是顺序不能错，因为后面的代码依赖着前面的代码。而且代码变量的命名可能冲突，可能在main.js里面声明了变量foo在do.js文件里面又声明了，或者直接用了该变量，又或者修改了该变量。无模块化带来的问题： 污染全局作用域 依赖关系不明显 维护成本高 CommonJS规范该规范最初是用在服务器端的node的，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块（同步）。注意这是同步加载，在浏览器同步加载是会阻塞的，所以在浏览器不用此规范。优点：解决了依赖、全局变量污染的问题；CommonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，CommonJS不适合浏览器端模块module.exports 和 exports的区别：module.exports导出一个对象，exports可以导出多个对象。不过 module.exports.foo == exports.foo也就说exports.属性会自动挂载到没有命名冲突的module.exports.属性,但是不要给exports赋值，一旦有了新值，它就不再绑定到module.exports； 123module.exports = &#123;foo: 'bar'&#125; //正确module.exports.foo = 'bar' //正确exports = &#123;foo: 'bar'&#125; //error 这种方式是错误的，相当于重新定义了exports 123456// 这是add.js文件const c = 5const add = function(a,b)&#123; return a + b + c&#125;module.exports = &#123;Add:add,c&#125; 123456// 这是main.js文件const addFn = require('./add')console.log(addFn.Add(5,9),addFn.c)//19,5//ES6解构赋值，导入const &#123;Add,c&#125; = require('./add')console.log(Add(5,9),c)//19,5 AMD规范AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。AMD也采用require()语句加载模块，但是不同于CommonJS;基本语法： 定义暴露模块: define([依赖模块名], function(){return 模块对象}); 引入模块: require([&#39;模块1&#39;, &#39;模块2&#39;, &#39;模块3&#39;], function(m1, m2){//使用模块对象}) 指定引用路径:require.config()require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写；1234567891011121314151617//页面引入 打印I am LiSi;I am 18 years old&lt;script data-main=\"js/main.js\" src=\"https://cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.min.js\"&gt;&lt;/script&gt;js/logFn.js文件define(function()&#123; var logName = function(name)&#123; console.log(`I am $&#123;name&#125;`) &#125; var logAge = age =&gt; &#123; console.log(`I am $&#123;age&#125; years old`) &#125; return &#123;logName,logAge&#125;&#125;)js/main.js文件require(['logFn'],function(logFn)&#123; logFn.logName('LiSi') logFn.logAge(18)&#125;) 优点：适合在浏览器环境中异步加载模块、并行加载多个模块；缺点：不能按需加载、开发成本大； CMD规范AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。说白了就是AMD引入依赖要先执行依赖再跳出执行主程序，而CMD则需要的时候引入，执行完主程序再回来执行依赖；CMD是按需加载，就近原则。 123456789101112131415161718192021222324252627282930313233//页面引入 //module1 show() this is module1 msg//异步引入依赖模块1 this is module1 msg&lt;script src=\"https://cdn.bootcdn.net/ajax/libs/seajs/3.0.3/sea.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; seajs.use('./js/main.js')&lt;/script&gt;js/module1.js文件define(function (require, exports, module) &#123; //内部变量数据 var data = 'this is module1' var msg = 'this is module1 msg' //内部函数 function show() &#123; console.log('module1 show() ' + data) &#125; //向外暴露 exports.show = show exports.msg = msg&#125;)js/main.js文件define(function (require, exports, module) &#123; //引入依赖模块(同步) var module1 = require('./module1') function show() &#123; console.log('module1 show() ' + module1.msg) &#125; show() //引入依赖模块(异步) require.async('./module1', function () &#123; console.log('异步引入依赖模块1 ' + module1.msg) &#125;)&#125;) ES6模块化在ES6中，我们可以使用 import 关键字引入模块，通过 exprot 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的；但是由于ES6在一些浏览器中无法执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。基本用法： export 命令用于规定模块的对外接口； import 命令用于输入其他模块提供的功能。 export default 暴露一个对象 export暴露多个对象es6在导出的时候有一个默认导出，export default,使用它导出后，在import的时候，不需要加上{}，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。12345678910//add.jsexport const add = (a,b) =&gt;&#123; return a + b&#125;import &#123;add&#125; from 'add.js'//add.jsexport default const add = (a,b) =&gt;&#123; return a + b&#125;import add from 'add.js' CommonJS规范和 ES6的区别 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。","categories":[],"tags":[{"name":"模块化","slug":"模块化","permalink":"http://lawsan.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"}]},{"title":"HTTP缓存","slug":"HTTP缓存","date":"2020-07-10T08:10:27.000Z","updated":"2020-07-10T09:16:10.919Z","comments":true,"path":"2020/07/10/HTTP缓存/","link":"","permalink":"http://lawsan.xyz/2020/07/10/HTTP%E7%BC%93%E5%AD%98/","excerpt":"","text":"只有不断的学习，才会发现自己是多么无知。 不过如果站在巨人的肩膀上的话，我就比别人看的更高更远。今天就来谈谈HTTP缓存机制。 缓存是啥？在浏览一些网站的时候，你有没有发现第二次浏览的时候比一开始的快很多。其实这就是缓存的结果，把第一次加载的网络资源缓存下来，以后请求的时候不用再去服务器获取，直接在本地获取即可。这样可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力，可谓是一石多鸟啊。 HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。我们来看一个缓存的流程图 每次浏览器发起GET请求(POST请求不能缓存)都会判断是否有缓存，首先判断的是强缓存，有则返回资源给浏览器渲染；否则判断是否有协商缓存，有返回资源给浏览器渲染，否则向服务器请求资源。 强缓存当有强缓存在时不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 。强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。优先级：Pragma &gt; Cache-Control &gt; Expires; ExpiresExpires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。Expires有一个很大的弊端，就是它返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，Expires是HTTP1.0的产物，现在大多数使用Cache-Control替代。 Cache-ControlCache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有： max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效 no-cache：不使用强缓存，需要与服务器验证缓存是否可用 no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源 private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应 public：响应可以被中间代理、CDN 等缓存 must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证1Cache-Control: max-age&#x3D;100, must-revalidate, public 上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。 PragmaPragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否可用；当 Pragma 和 Cache-Control 同时存在的时候，Pragma 的优先级高于 Cache-Control。Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上上面这段meta元标签。 1&lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot;&gt; 协商缓存当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。 Last-Modified/If-Modified-Since在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。 1Last-Modified : Fri , 11 May 2019 18:53:33 GMT 当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。 1If-Modified-Since : Fri , 11 May 2019 18:53:33 GMT 服务端通过If-Modified-Since字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。 ETag/If-None-Match代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。If-None-Match和If-Modified-Since同时存在的时候If-None-Match优先级更高。ETag/If-None-Match 的出现主要解决了 Last-Modified/If-Modified-Since 所解决不了的问题：如果文件的修改频率在秒级以下，Last-Modified/If-Modified-Since 会错误地返回 304如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304好了，HTTP缓存就说到这了，虽然还有很多字段没说，比如 Vary、Date、Age","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://lawsan.xyz/tags/HTTP/"}]},{"title":"浏览器渲染原理你了解多少","slug":"浏览器渲染原理你了解多少","date":"2020-07-10T04:21:03.000Z","updated":"2020-07-10T07:24:44.742Z","comments":true,"path":"2020/07/10/浏览器渲染原理你了解多少/","link":"","permalink":"http://lawsan.xyz/2020/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/","excerpt":"","text":"通过这篇文章，能够让你重新认识浏览器，并把JavaScript，网络，页面渲染，浏览器安全等知识串联起来，从而让你对整个前端体系有全新的认识。这篇文章是上篇文章的追加从输入URL到页面展示，这中间发生了啥 渲染流程渲染引擎 渲染引擎：它是浏览器最核心的部分是 “Rendering Engine”，不过我们一般习惯将之称为 “浏览器内核”； 渲染引擎主要包括的线程：GUI渲染线程、JavaScript引擎线程、事件触发线程、定时器触发线程、HTTP异步请求线程；如下图 GUI渲染线程：GUI 渲染线程负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行。 JavaScript引擎线程: JavaScript 引擎线程主要负责解析 JavaScript 脚本并运行相关代码。 JavaScript 引擎在一个Tab页（Renderer 进程）中无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序。需要提起一点就是，GUI线程与JavaScript引擎线程是互斥的，这也是就是为什么JavaScript操作时间过长，会造成页面渲染不连贯，导致页面出现阻塞的原理。 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。 通常JavaScript引擎是单线程的，所以这些事件都会排队等待JS执行。 定时器触发器：我们日常使用的setInterval 和 setTimeout 就在该线程中，原因可能就是：由于JS引擎是单线程的，如果处于阻塞线程状态就会影响记时的准确，所以需要通过单独的线程来记时并触发响应的事件这样子更为合理。 Http请求线程：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，这个线程就Http请求线程，它 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。简略的渲染流程 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。流程如下图： 相关说明： 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。 Load 和 DOMContentLoaded 区别Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。 通过以下几个常用属性可以生成新图层： 变换：translate3d、translateZ； will-change； video、iframe 标签； 通过动画实现的 opacity 动画转换； position: fixed；重绘（Repaint）和回流（Reflow） 回流是布局或者几何属性需要改变就称为回流。另外一个叫法是重排，回流触发的条件就是:对 DOM 结构的修改引发 DOM 几何尺寸变化的时候,会发生回流过程。会发生回流的情况有如下： 一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等； 使 DOM 节点发生增减或者移动； 读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。 调用 window.getComputedStyle 方法。 回流的过程依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。根据概念，我们知道由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，流程如下： 跳过了布局树和建图层树,直接去绘制列表，然后在去分块,生成位图等一系列操作。 可以看到，重绘不一定导致回流，但回流一定发生了重绘。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 很多人不知道的是，重绘和回流其实和Event loop 有关。 Event loop 执行完微任务（Microtasks ）后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每(1000/60) = 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 减少重绘和回流 使用 translate 替代 top，在修改定位时，使用translate代替； 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）； 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来； 不要把DOM结点的属性值放在一个循环里当成循环里的变量;1234for(let i &#x3D; 0; i &lt; 1000; i++) &#123; &#x2F;&#x2F; 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(&#39;.test&#39;).style.offsetTop)&#125; 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局; 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame; CSS 选择符从右往左匹配查找，避免 DOM 深度过深; 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。详细的渲染流程构建DOM树 ==&gt; 样式计算 ==&gt; 布局阶段 ==&gt; 分层 ==&gt; 绘制 ==&gt; 分块 ==&gt; 光栅化 ==&gt; 合成;从0，1字节流到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程中化为很多的子阶段，渲染引擎从网络进程拿到字节流数据后，经过这些子阶段的处理，最后输出像素，这个过程可以称为渲染流水线 ，我们从一张图上来看👇 构建DOM树 数据类型改变： 字节 ==&gt; 字符 ==&gt; 令牌 ==&gt; 节点 ==&gt; 对象模型转化过程： 转换:浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。 令牌化：浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“html”、“head”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。 词法分析：发出的令牌转换成定义其属性和规则的“对象”。 DOM构建：最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。样式计算 格式化样式表*我们拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构styleSheets；通过浏览器的控制台document.styleSheets可以来查看这个最终结果。通过JavaScript可以完成查询和修改功能,或者说这个阶段为后面的样式操作提供基石。 标准化样式表*有些时候，我们写CSS 样式的时候，会写font-size:2em;color:red;font-weight:bold,像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如em-&gt;px,red-&gt;rgba(255,0,0,0),bold-&gt;700等等。我们来看看标准化的变化过程，如下图 计算每个DOM节点具体样式*通过之前的格式化和标准化后，接下来就是计算每个节点具体样式信息了。计算规则：继承和层叠 继承*：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫UserAgent样式。 层叠*：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到window.getComputedStyle当中，也就是可以通过JS来获取计算后的样式，非常方便。这个阶段，完成了DOM节点中每个元素的具体样式，计算过程中要遵循CSS的继承和层叠两条规则，最终输出的内容是每个节点DOM的样式，被保存在ComputedStyle中。 生成布局树上述过程已经完成DOM树（DOM树）构建，以及样式计算（DOM样式），接下来就是要通过浏览器的布局系统确定元素位置，也就是生成一颗布局树（Layout Tree）,之前说法叫渲染树。创建布局树在DOM树上不可见的元素，head元素，meta元素等，以及使用display:none属性的元素，最后都不会出现在布局树上，所以浏览器布局系统需要额外去构建一棵只包含可见元素布局树。我们直接结合图来看看这个布局树构建过程： 主要流程： 遍历DOM树可见节点，并把这些节点加到布局树中； 对于不可见的节点，head,meta标签等都会被忽略。对于body.p.span 这个元素，它的属性包含display:none,所以这个元素没有被包含进布局树。 布局计算这个请看从Chrome源码看浏览器如何layout布局一张图看懂渲染前三步流程： 分层首先需要知道的就是，浏览器在构建完布局树后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，比如一些些复杂的 3D 变换、页面滚动，或者使用 z-index做 z 轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。生成图层树浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。我们来看看图层与布局树之间关系，如下图👇 通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那什么情况下，渲染引擎会为特定的节点创建新图层呢？有两种情况需要分别讨论，一种是显式合成，一种是隐式合成。显式合成需要剪裁(clip)的地方或者拥有层叠上下文的节点。层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况: HTML根元素本身就具有层叠上下文。 普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文。 元素的 opacity 值不是 1 元素的 transform 值不是 none 元素的 filter 值不是 none 元素的 isolation 值是isolate will-change指定的属性值为上面任意一个。 隐式合成这是一种什么样的情况呢，通俗意义上来说，就是z-index比较低的节点会提升为一个单独的途图层，那么层叠等级比它高的节点都会成为一个独立的图层。在一个大型的项目中，一个z-index比较低的节点被提升为单独图层后，层叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃。这就是层爆炸; 绘制完成了图层的构建，接下来要做的工作就是图层的绘制了。图层的绘制跟我们日常的绘制一样，每次都会把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个绘制列表，类似于下图👇 分块接下来我们就要开始绘制操作了，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫合成线程。绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。接下来就是合成线程一展宏图的时候啦。 你想呀，有时候，你的图层很大，或者说你的页面需要使用滚动条，然后页面的内容太多，多的无法想象，这个时候需要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于上面的原因，合成线程会讲图层划分为图块(tile);这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。首屏渲染加速：因为后面图块（非视口内的图块）数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。 光栅化接着上面的步骤，有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。 图块是栅格化执行的最小单位 渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据 合成线程会选择视口附近的图块(tile)，把它交给栅格化线程池生成位图 生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。 合成和显示栅格化操作完成后，合成线程会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡两张图总结渲染过程，如下图： 感觉好多东西还没有接触，越细越多，此时我的心情如下","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"从输入URL到页面展示，这中间发生了啥","slug":"从输入URL到页面展示，这中间发生了啥","date":"2020-07-09T13:48:16.000Z","updated":"2020-07-09T15:19:36.140Z","comments":true,"path":"2020/07/09/从输入URL到页面展示，这中间发生了啥/","link":"","permalink":"http://lawsan.xyz/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/","excerpt":"","text":"这道题应该是一个非常经典的题目，包括了HTTP、TCP连接、浏览器缓存、浏览器渲染等等。用户输入URL后，向服务器端发起请求、如果顺利，得到网络响应之后，浏览器对资源进行解析、最后将其渲染到页面上。具体步骤如下👇 首先构建请求 查找缓存，如果命中缓存，直接使用缓存资源(包括DNS缓存) 否则进行DNS解析，将域名转换成对应的IP地址 建立TCP连接 发送HTTP请求 如果顺利得到网络响应，浏览器开始解析和渲染 HTML解释器 解析HTML 为 DOM树 同时CSS解释器 解析CSS文档 为 styleSheets 创建布局树，进行布局计算 整合图层，展示页面我们先来分析一下HTTP请求，请求流程如下👇 首先构建请求首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。1GET &#x2F;index.html HTTP1.1 查找缓存在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有： 缓解服务器端压力，提升性能（获取资源的耗时更短了）； 对于网站来说，缓存是实现快速资源加载的重要组成部分。当然，如果缓存查找失败，就会进入网络请求过程了。 DNS解析，将域名转换成对应的IP地址默认端口 http为80，https为443。DNS解析：将域名映射成对应的IP地址，这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）DNS数据缓存服务：浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。 建立TCP连接网络OSI七层架构(从低到高)：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。计算机网络知识：HTTP在应用层，TCP在传输层，IP在网络层。浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。 等待TCP队列：在建立TCP建立之前，可能要进入TCP队列。因为浏览器的限制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然如果少于6个就不用进入队列等待。浏览器通过TCP3次握手和服务器建立连接，建立连接后进行数据传输，传输完成后，经过4次TCP握手断开连接。如下图👇 TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输。 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层。 底层通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层。 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 说白就是从网络底层到高层就是对数据脱外套，相反就是穿外套。Connection:Keep-Alive:如果请求头里面有这个属性，数据传输完成后，不会断开TCP的。 发送HTTP请求上面大概讲完了建立TCP连接，你可以理解TCP的连接，是为了保证浏览器跟服务器更好的通信。当然了有了上面的这个过程中， HTTP 中的数据也正是在这个通信过程中传输的。那么我们从一张图片中来看，浏览器是如何发送信息给服务器的👇 请求行：请求方法，请求URL HTTP协议版本； 请求行大概意思就是告诉服务器，我需要做上面，比如GET方法，我需要向你拿资源，POST方法通常也就是我需要向服务器提交什么数据，需要注意的就是如果是POST方法，浏览器还需要准备好数据，通过请求体发送给服务器。 请求头：把浏览器的基础信息告诉服务器，比如包含了浏览器所使用的操作系统，浏览器的内核信息等，还有请求的域名信息，浏览器的Cookie信息等等。 请求体：一些业务逻辑需要的数据。 得到网络响应，浏览器开始解析和渲染我们也来看一看响应的报文吧👇 响应行：HTTP协议版本 状态码，通过常见的状态码，就可以知道处理的结果。 响应头：你可以理解成包含服务器自身的一些信息，比如服务器生成数据的时间，返回数据的类型（HTML，流媒体，JSON，XHTML等等）以及服务器在客户端保存的Cookie等信息。响应头中 Cache-Control 字段也很重要，这个涉及到了HTTP缓存，这个字段涵义就是设置缓存资源的时间的 响应体：请求返回的内容。返回的状态码中有301或者302即可发生重定向；302为临时重定向，301为永久重定向。Content-Type:浏览器会按照这个内容类型来解析。HTML解释器 解析HTML 为 DOM树渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。哎！，感觉后面的内容有点多，再新建一篇文章讲讲后面的内容（浏览器的渲染机制）。","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://lawsan.xyz/tags/HTTP/"},{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器架构你了解多少？","slug":"浏览器架构你了解多少","date":"2020-07-08T02:45:05.000Z","updated":"2020-07-09T13:14:51.049Z","comments":true,"path":"2020/07/08/浏览器架构你了解多少/","link":"","permalink":"http://lawsan.xyz/2020/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/","excerpt":"","text":"作为前端cv仔和浏览器打交道是最多的，浏览器对我们来说可以说是个黑盒，今天我们就来聊聊浏览器的架构。首先了解一下必要的知识进程和线程。 进程与线程 进程是资源分配的最小单位,线程是程序执行的最小单位。 同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，而进程共享进程中的数据的，使用相同的地址空间； 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 单进程浏览器时代顾名思义，单进程浏览器是指浏览器所以模块都运行再同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。单进程浏览器的架构如下图所示👇 如此多的功能模块运行在一个进程里，肯定有着不足的： 不稳定性：只要一个线程崩溃，这个进程就崩溃，浏览就用不了了。 不流畅： 多个任务共用一个线程，比如页面线程。 不安全：没有沙箱机制。 多进程浏览器时代早期多进程架构 从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分） 解决早期浏览器不稳定问题：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。 解决早期浏览器不流畅问题：JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。 解决早期浏览器不安全问题：用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。 目前多进程架构 从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。下面我们来逐个分析下这几个进程的功能👇 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU进程。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 多进程带来的问题： 更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。 更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了 面向未来的架构为了解决上面的问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型。 试题 为什么单进程浏览器当时不可以采用安全沙箱？如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。 打开Chrome浏览器一个Tab页面，至少会出现几个进程？最新的Chrome浏览器包括至少四个:1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程,当然还有复杂的情况； 页面中有iframe的话,iframe会单独在进程中 有插件的话，插件也会开启进程 多个页面属于同一站点，并且从a打开b页面，会共用一个渲染进程 装了扩展的话，扩展也会占用进程这些进程都可以通过Chrome任务管理器来查看 即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。更加简单的来说，就是如果多个页面符合同一站点，这几个页面会分配到一个渲染进程中去,所以有这样子的一种情况,一个页面崩溃了，会导致同一个站点的其他页面也奔溃，这是因为它们使用的是同一个渲染进程。它们在一个渲染进程中的话，它们就会共享JS执行环境，也就是A页面可以直接在B页面中执行脚本了。","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"经典算法以及数据结构","slug":"经典算法以及数据结构","date":"2020-07-07T09:31:21.000Z","updated":"2020-07-12T15:06:48.241Z","comments":true,"path":"2020/07/07/经典算法以及数据结构/","link":"","permalink":"http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"斐波那契数列在算法题中比较经典，故出此文以此铭记。题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&lt;=39 暴力递归实现1234function Fibonacci(n)&#123; if(n == 0 || n == 1) return n return Fibonacci(n-1) + Fibonacci(n-2)&#125; 数组保存计算缓存，减少计算12345678function Fibonacci(n)&#123; let arr = [0,1] return Fib(n) function Fib(n)&#123; if(arr[n] !== undefined ) return arr[n] //计算过的不用再计算 return arr[n] = Fib(n-1) + Fib(n-2) &#125;&#125; 动态规划12345678function Fibonacci(n)&#123; let a = 0 //第一项 let b = 1 //第二项 for(let i = 2;i&lt; n;i++ )&#123; //从第二项开始到n-1项 [a,b] = [b,a+b] &#125; return a+b&#125; 感觉这篇幅有点短，好吧再加几个算法题^_^ 经典算法二分查找题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011121314151617function Find(target,array)&#123; for(let i =0 ;i&lt;array.length;i++)&#123; let low = 0 //每行的开始索引 let height = array[i].length - 1 //每行的最大索引 while(low &lt;= height)&#123; //对每一行的数组进行二分查找 let mid = Math.floor((low+height)/2) if(target &gt; array[i][mid])&#123; low = mid + 1 &#125;else if(target &lt; array[i][mid])&#123; height = mid -1 &#125;else&#123; return true &#125; &#125; &#125; return false //没有找到&#125; 此题还有一种更好的思路：既然是递增数组，那我们就比较一下每一行数组最大的元素，如果此数大于这一行的最大元素则去下一行数组比较，如果此数小于这一行的最大元素则去前一列比较； 123456789101112131415function Find(target,array)&#123; let row = 0 let col = array[0].length -1 let len = array.length while(row &lt; len &amp;&amp; 0 &lt;= col)&#123; //row是索引要小于行数，col要大于0 if(target &gt; array[row][col])&#123; row++ &#125;else if(target &lt; array[row][col])&#123; col-- &#125;else&#123; return true &#125; &#125; return false&#125; 链表链表也是数据结构中的一种，由指针指向。题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 1234567891011121314/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function printListFromTailToHead(head)&#123; let ArrayList = [] while(head)&#123; ArrayList.push(head.val) head = head.next &#125; ArrayList.reverse() return ArrayList&#125; JavaScript实现队列队列是数据结构中的一种，先进先出FIFO,我们用数组来实现它。 123456789101112131415function Queue()&#123; let arr = [] this.pop = function()&#123; if(arr.length &lt;= 0) return return arr.shift() &#125; this.push = function(data)&#123; arr.push(data) &#125;&#125;let queue = new Queue()queue.push(1)queue.push(2)queue.push(3)queue.pop() //1 JavaScript实现栈栈是数据结构中的一种，先进先出FILO,我们用数组来实现它。 12345678910111213141516function Stack()&#123; let value = [] this.pop = function()&#123; if(value.length &lt;= 0) return return value.pop() &#125; this.push = function(data)&#123; value.push(data) &#125;&#125;let stack = new Stack()stack.push(1)stack.push(2)stack.push(3)stack.pop() //3 好了此次的文章就写到这了，祝高三学子高考顺利！！！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"canvas踩坑日记","slug":"canvas踩坑日记","date":"2020-07-02T08:25:24.000Z","updated":"2020-07-12T15:07:41.675Z","comments":true,"path":"2020/07/02/canvas踩坑日记/","link":"","permalink":"http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"","text":"这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过html2canvas.js转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。 利用canvas的API进行剪切注意：Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。也就是说通过css给canvas添加样式是行不通的（这个坑费了我好多时间)。解决方案：动态添加canvas； 123456&lt;p&gt;图片应用:&lt;/p&gt;&lt;img id=\"scream\" src=\"img_the_scream.jpg\"&gt;&lt;p&gt;画布:&lt;/p&gt;&lt;canvas id=\"myCanvas\" width=\"300\" height=\"150\" style=\"border:1px solid #d3d3d3;\"&gt;您的浏览器不支持 HTML5 canvas 标签。&lt;/canvas&gt; 1234567document.getElementById(\"scream\").onload=function()&#123; var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); var img=document.getElementById(\"scream\"); ctx.drawImage(img,90,130,50,60,10,10,50,60);&#125;; 关于drawImage的使用有三种语法的使用： context.drawImage(img,dx,dy); context.drawImage(img,dx,dy,dw,dh); context.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh); 坐标草图 对图片进行剪切12345678910111213141516let IMG = &#123; file: 0, //图片文件 width: 0, //源图片宽度 height: 0, //源图片高度 firstY: 330, //第一次剪切高度（从0开始） secondY: 410, //第二次剪切高度（第二次开始剪切的y坐标） money: \"-588.00\", //要修改的数字 bg: \"#f7f7f7\", //#f5f5f5 fontSize:'60px',&#125;pic.onload = function() &#123; IMG.height = pic.height; IMG.width = pic.width; ctx1.drawImage(pic, 0, 0, pic.width, IMG.firstY, 0, 0, pic.width, IMG.firstY); ctx2.drawImage(pic, 0, IMG.secondY, pic.width, (IMG.height - IMG.secondY), 0, 0, pic.width, (IMG.height -IMG.secondY));&#125; 对图片要要修改的部分用html代替显示，然后html转图片12345678910111213141516html2canvas(canvasBox, &#123; allowTaint: true, //允许污染 taintTest: true, //在渲染前测试图片 useCORS: true, //使用跨域 background:IMG.bg, dpi: window.devicePixelRatio * 2, //分辨率，是图片清晰点 scale: 2, height: IMG.height - 10, //截图高度 width: IMG.width, //截图宽度&#125;).then(function(canvas) &#123; //显示ps好的图片 let show = document.getElementById('show'); show.style.display = 'block'; show.src = canvas.toDataURL(); canvasBox.style.display = 'none';&#125;) 此次是对支付宝账单详情的金额进行ps，整个源码地址==&gt;canvas对支付宝账单详情进行P图","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"}]},{"title":"聊聊几种排序算法","slug":"聊聊几种排序算法","date":"2020-07-02T08:09:54.494Z","updated":"2020-07-03T14:57:34.258Z","comments":true,"path":"2020/07/02/聊聊几种排序算法/","link":"","permalink":"http://lawsan.xyz/2020/07/02/%E8%81%8A%E8%81%8A%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"Javascript API实现排序12let arr = [72, 45, 62, 12, 23, 67, 80, 56, 90, 6, 9];arr.sort((a,b)=&gt;a-b); 冒泡排序基本思路：每次执行循环就把一个最大的数放到最后，就像气泡一样一个一个的冒；第一个循环遍历数组所有元素，第二个循环遍历是找出最大数值然后放在最后，时间复杂度为O(n2)。 1234567891011function bubbleSort(arr) &#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; //两个数比较，i表示数组总个数，j代表第一个数（索引较前）最大就是倒数第二个数 for (let j = 0; j &lt; arrLength - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] //交换两个数值 &#125; &#125; &#125;&#125; 选择排序基本思路： 每次执行循环找出最小值的索引值，并把这个最小放到前面，索引i前面的数组是依次排好的，时间复杂度为O(n2)。 与冒泡排序比较，冒泡排序是每次找出最大值放到最后而选择排序这是每次找出最小值放到前面。每次循环都会从乱序数组中找出最大（最小）值排到有序数组中。 1234567891011121314function selectSort(arr)&#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; let minIndex = i //每次循环找出最小值索引 for(let j = i;j&lt;arrLength;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j &#125; &#125; //把最小值放到前面数组 [arr[i],arr[minIndex]] = [arr[minIndex],arr[i]] &#125;&#125; 插入排序基本思路：在已有排序的数组中找出自己位置，插入其中； 12345678910111213141516function insertSort(arr)&#123; let arrLength = arr.length let preIndex,current for(let i = 1;i&lt;arrLength;i++)&#123; preIndex = i - 1 current = arr[i] //这个循环就是找出自己的位置，然后跳出，比较这个原始和current的大小，大则移后 while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current)&#123; arr[preIndex + 1] = arr[preIndex] 45,72,72 preIndex --; &#125; //插入 arr[preIndex + 1] = current; &#125;&#125; 归并排序基本思路：该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 123456789101112131415161718192021222324252627282930function mergeSort(arr)&#123; let len = arr.length if(len&lt;2)&#123; return arr &#125; //把长度为n的输入序列分成两个长度为n/2的子序列 let mid = Math.floor(len/2) let left = arr.slice(0,mid) let right = arr.slice(mid) //对这两个子序列分别采用归并排序 return merge(mergeSort(left),mergeSort(right))&#125;//将两个排序好的子序列合并成一个最终的排序序列。function merge(left,right)&#123; let result = [] while(left.length &gt; 0 &amp;&amp; right.length &gt; 0)&#123; if(left[0] &lt;= right[0])&#123; result.push(left.shift()) &#125;else&#123; result.push(right.shift()) &#125; &#125; while(left.length)&#123; result.push(left.shift()) &#125; while(right.length)&#123; result.push(right.shift()) &#125; return result&#125; 快速排序基本思路： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。12345678910111213141516171819202122232425function quickSort(arr,left,right)&#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if(left &lt; right)&#123; partitionIndex = partition(arr, left ,right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) &#125; return arr&#125;//分区操作function partition(arr, left ,right)&#123; var pivot = left, index =pivot + 1; for(var i = index;i &lt;= right; i++)&#123; if(arr[i] &lt; arr[pivot])&#123; [arr[i],arr[index]] = [arr[index],arr[i]] index++ &#125; &#125; [arr[pivot],arr[index-1]] = [arr[index-1],arr[pivot]] return index-1&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"Vue监听回车事件@keyup","slug":"Vue监听回车事件keyup","date":"2020-06-30T13:08:05.000Z","updated":"2020-07-03T10:49:37.730Z","comments":true,"path":"2020/06/30/Vue监听回车事件keyup/","link":"","permalink":"http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/","excerpt":"","text":"当我们要在一个输入框中监听回车事件时要绑定keyup事件；keydown当键盘被按下时会触发；keyup当键盘松开时触发； 1&lt;input type=\"text\" value=\"\" id=\"search_input\"/&gt; 原生JavaScript实现;1234567document.getElementById('search_input').onkeyup = function(e)&#123; var theEvent = window.event || e; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; //doSomeThing... &#125;&#125; jQuery实现；12345$(\"#search_input\").keyup(function(e)&#123; if (e.keyCode == 13) &#123; //doSomeThing... &#125;&#125;) Vue事件绑定实现全部键盘别名 enter,tab,delete,esc,space,up,down,left,right;组合按键 ctr,alt,shift,meta(window系统下是win键，mac下是command键) 12345&lt;input type=\"text\" @keyup.enter=\"search\" v-model=\"search_input\"/&gt;//methodssearch()&#123; //doSomeThing...&#125; 如果是封装组件的话，例如element的el-input，要加上native; 1&lt;el-input v-model=\"search_input\" @keyup.enter.native=\"search\"&gt;&lt;/el-input&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}],"categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"HTML5","slug":"HTML5","permalink":"http://lawsan.xyz/tags/HTML5/"},{"name":"CSS","slug":"CSS","permalink":"http://lawsan.xyz/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://lawsan.xyz/tags/JavaScript/"},{"name":"HTTP","slug":"HTTP","permalink":"http://lawsan.xyz/tags/HTTP/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://lawsan.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"模块化","slug":"模块化","permalink":"http://lawsan.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}