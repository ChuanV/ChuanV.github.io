{"meta":{"title":"Lawson's Blog","subtitle":"尝尽人间百味，方知人间冷暖。","description":"劳生穿的博客。做人最重要的是开心。","author":"Lawson","url":"http://lawsan.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-03T02:32:34.343Z","comments":true,"path":"about/index.html","permalink":"http://lawsan.xyz/about/index.html","excerpt":"","text":".info_content { padding-left: 20px; display: flex; } .info_details ul>li { list-style-type: none; } .text-indent { text-indent: 2em; } 姓名：阿穿 性别：男 职业：前端CV工程师 爱好：玩游戏，看电影,codeing... 英文名：Lawson 年龄：22 学历：本科 我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。 window.onload = function() { var detail = document.getElementById('my_info_details'); var detail1 = document.getElementById('my_info_details1'); var detailText = `我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。`; var detailText1 = `前路漫漫，唯独自己变强才能走到最后，加油！奥利给。`; typing(detail, detailText, 100) .then(()=>{typing(detail1, detailText1, 100)}) .catch((e)=>{ console.log(e) }) function typing(dom, text, time) { return new Promise((resolve, reject) => { var i = 0; var timer = setInterval(function() { if (i"},{"title":"","date":"2020-07-01T11:59:23.000Z","updated":"2020-07-02T04:46:10.999Z","comments":true,"path":"categories/index.html","permalink":"http://lawsan.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-02T09:53:45.042Z","comments":true,"path":"tags/index.html","permalink":"http://lawsan.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从输入URL到页面展示，这中间发生了啥","slug":"从输入URL到页面展示，这中间发生了啥","date":"2020-07-09T13:48:16.000Z","updated":"2020-07-09T15:19:36.140Z","comments":true,"path":"2020/07/09/从输入URL到页面展示，这中间发生了啥/","link":"","permalink":"http://lawsan.xyz/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/","excerpt":"","text":"这道题应该是一个非常经典的题目，包括了HTTP、TCP连接、浏览器缓存、浏览器渲染等等。用户输入URL后，向服务器端发起请求、如果顺利，得到网络响应之后，浏览器对资源进行解析、最后将其渲染到页面上。具体步骤如下👇 首先构建请求 查找缓存，如果命中缓存，直接使用缓存资源(包括DNS缓存) 否则进行DNS解析，将域名转换成对应的IP地址 建立TCP连接 发送HTTP请求 如果顺利得到网络响应，浏览器开始解析和渲染 HTML解释器 解析HTML 为 DOM树 同时CSS解释器 解析CSS文档 为 styleSheets 创建布局树，进行布局计算 整合图层，展示页面我们先来分析一下HTTP请求，请求流程如下👇 首先构建请求首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。1GET &#x2F;index.html HTTP1.1 查找缓存在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有： 缓解服务器端压力，提升性能（获取资源的耗时更短了）； 对于网站来说，缓存是实现快速资源加载的重要组成部分。当然，如果缓存查找失败，就会进入网络请求过程了。 DNS解析，将域名转换成对应的IP地址默认端口 http为80，https为443。DNS解析：将域名映射成对应的IP地址，这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）DNS数据缓存服务：浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。 建立TCP连接网络OSI七层架构(从低到高)：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。计算机网络知识：HTTP在应用层，TCP在传输层，IP在网络层。浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。 等待TCP队列：在建立TCP建立之前，可能要进入TCP队列。因为浏览器的限制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然如果少于6个就不用进入队列等待。浏览器通过TCP3次握手和服务器建立连接，建立连接后进行数据传输，传输完成后，经过4次TCP握手断开连接。如下图👇 TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输。 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层。 底层通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层。 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 说白就是从网络底层到高层就是对数据脱外套，相反就是穿外套。Connection:Keep-Alive:如果请求头里面有这个属性，数据传输完成后，不会断开TCP的。 发送HTTP请求上面大概讲完了建立TCP连接，你可以理解TCP的连接，是为了保证浏览器跟服务器更好的通信。当然了有了上面的这个过程中， HTTP 中的数据也正是在这个通信过程中传输的。那么我们从一张图片中来看，浏览器是如何发送信息给服务器的👇 请求行：请求方法，请求URL HTTP协议版本； 请求行大概意思就是告诉服务器，我需要做上面，比如GET方法，我需要向你拿资源，POST方法通常也就是我需要向服务器提交什么数据，需要注意的就是如果是POST方法，浏览器还需要准备好数据，通过请求体发送给服务器。 请求头：把浏览器的基础信息告诉服务器，比如包含了浏览器所使用的操作系统，浏览器的内核信息等，还有请求的域名信息，浏览器的Cookie信息等等。 请求体：一些业务逻辑需要的数据。 得到网络响应，浏览器开始解析和渲染我们也来看一看响应的报文吧👇 响应行：HTTP协议版本 状态码，通过常见的状态码，就可以知道处理的结果。 响应头：你可以理解成包含服务器自身的一些信息，比如服务器生成数据的时间，返回数据的类型（HTML，流媒体，JSON，XHTML等等）以及服务器在客户端保存的Cookie等信息。响应头中 Cache-Control 字段也很重要，这个涉及到了HTTP缓存，这个字段涵义就是设置缓存资源的时间的 响应体：请求返回的内容。返回的状态码中有301或者302即可发生重定向；302为临时重定向，301为永久重定向。Content-Type:浏览器会按照这个内容类型来解析。HTML解释器 解析HTML 为 DOM树渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。哎！，感觉后面的内容有点多，再新建一篇文章讲讲后面的内容（浏览器的渲染机制）。","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"HTTP","slug":"HTTP","permalink":"http://lawsan.xyz/tags/HTTP/"}]},{"title":"浏览器架构你了解多少？","slug":"浏览器架构你了解多少","date":"2020-07-08T02:45:05.000Z","updated":"2020-07-09T13:14:51.049Z","comments":true,"path":"2020/07/08/浏览器架构你了解多少/","link":"","permalink":"http://lawsan.xyz/2020/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/","excerpt":"","text":"作为前端cv仔和浏览器打交道是最多的，浏览器对我们来说可以说是个黑盒，今天我们就来聊聊浏览器的架构。首先了解一下必要的知识进程和线程。 进程与线程 进程是资源分配的最小单位,线程是程序执行的最小单位。 同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，而进程共享进程中的数据的，使用相同的地址空间； 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 单进程浏览器时代顾名思义，单进程浏览器是指浏览器所以模块都运行再同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。单进程浏览器的架构如下图所示👇 如此多的功能模块运行在一个进程里，肯定有着不足的： 不稳定性：只要一个线程崩溃，这个进程就崩溃，浏览就用不了了。 不流畅： 多个任务共用一个线程，比如页面线程。 不安全：没有沙箱机制。 多进程浏览器时代早期多进程架构 从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分） 解决早期浏览器不稳定问题：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。 解决早期浏览器不流畅问题：JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。 解决早期浏览器不安全问题：用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。 目前多进程架构 从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。下面我们来逐个分析下这几个进程的功能👇 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU进程。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 多进程带来的问题： 更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。 更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了 面向未来的架构为了解决上面的问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型。 试题 为什么单进程浏览器当时不可以采用安全沙箱？如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。 打开Chrome浏览器一个Tab页面，至少会出现几个进程？最新的Chrome浏览器包括至少四个:1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程,当然还有复杂的情况； 页面中有iframe的话,iframe会单独在进程中 有插件的话，插件也会开启进程 多个页面属于同一站点，并且从a打开b页面，会共用一个渲染进程 装了扩展的话，扩展也会占用进程这些进程都可以通过Chrome任务管理器来查看 即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。更加简单的来说，就是如果多个页面符合同一站点，这几个页面会分配到一个渲染进程中去,所以有这样子的一种情况,一个页面崩溃了，会导致同一个站点的其他页面也奔溃，这是因为它们使用的是同一个渲染进程。它们在一个渲染进程中的话，它们就会共享JS执行环境，也就是A页面可以直接在B页面中执行脚本了。","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"经典算法以及数据结构","slug":"经典算法以及数据结构","date":"2020-07-07T09:31:21.000Z","updated":"2020-07-07T10:49:35.829Z","comments":true,"path":"2020/07/07/经典算法以及数据结构/","link":"","permalink":"http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"斐波那契数列在算法题中比较经典，故出此文以此铭记。题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&lt;=39 暴力递归实现1234function Fibonacci(n)&#123; if(n == 0 || n == 1) return n return Fibonacci(n-1) + Fibonacci(n-2)&#125; 数组保存计算缓存，减少计算12345678function Fibonacci(n)&#123; let arr = [0,1] return Fib(n) function Fib(n)&#123; if(arr[n] !== undefined ) return arr[n] //计算过的不用再计算 return arr[n] = Fib(n-1) + Fib(n-2) &#125;&#125; 动态规划12345678function Fibonacci(n)&#123; let a = 0 //第一项 let b = 1 //第二项 for(let i = 2;i&lt; n;i++ )&#123; //从第二项开始到n-1项 [a,b] = [b,a+b] &#125; return a+b&#125; 感觉这篇幅有点短，好吧再加几个算法题^_^ 经典算法二分查找题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011121314151617function Find(target,array)&#123; for(let i =0 ;i&lt;array.length;i++)&#123; let low = 0 //每行的开始索引 let height = array[i].length - 1 //每行的最大索引 while(low &lt;= height)&#123; //对每一行的数组进行二分查找 let mid = Math.floor((low+height)/2) if(target &gt; array[i][mid])&#123; low = mid + 1 &#125;else if(target &lt; array[i][mid])&#123; height = mid -1 &#125;else&#123; return true &#125; &#125; &#125; return false //没有找到&#125; 此题还有一种更好的思路：既然是递增数组，那我们就比较一下每一行数组最大的元素，如果此数大于这一行的最大元素则去下一行数组比较，如果此数小于这一行的最大元素则去前一列比较； 123456789101112131415function Find(target,array)&#123; let row = 0 let col = array[0].length -1 let len = array.length while(row &lt; len &amp;&amp; 0 &lt;= col)&#123; //row是索引要小于行数，col要大于0 if(target &gt; array[row][col])&#123; row++ &#125;else if(target &lt; array[row][col])&#123; col-- &#125;else&#123; return true &#125; &#125; return false&#125; 链表链表也是数据结构中的一种，由指针指向。题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 1234567891011121314/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function printListFromTailToHead(head)&#123; let ArrayList = [] while(head)&#123; ArrayList.push(head.val) head = head.next &#125; ArrayList.reverse() return ArrayList&#125; JavaScript实现队列队列是数据结构中的一种，先进先出FIFO,我们用数组来实现它。 123456789101112131415function Queue()&#123; let arr = [] this.pop = function()&#123; if(arr.length &lt;= 0) return return arr.shift() &#125; this.push = function(data)&#123; arr.push(data) &#125;&#125;let queue = new Queue()queue.push(1)queue.push(2)queue.push(3)queue.pop() //1 JavaScript实现栈栈是数据结构中的一种，先进先出FILO,我们用数组来实现它。 12345678910111213141516function Stack()&#123; let value = [] this.pop = function()&#123; if(value.length &lt;= 0) return return value.pop() &#125; this.push = function(data)&#123; value.push(data) &#125;&#125;let stack = new Stack()stack.push(1)stack.push(2)stack.push(3)stack.pop() //3 好了此次的文章就写到这了，祝高三学子高考顺利！！！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://lawsan.xyz/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://lawsan.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://lawsan.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"canvas踩坑日记","slug":"canvas踩坑日记","date":"2020-07-02T08:25:24.000Z","updated":"2020-07-07T05:31:45.698Z","comments":true,"path":"2020/07/02/canvas踩坑日记/","link":"","permalink":"http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"","text":"这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过html2canvas.js转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。 利用canvas的API进行剪切注意：Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。也就是说通过css给canvas添加样式是行不通的（这个坑费了我好多时间)。解决方案：动态添加canvas； 123456&lt;p&gt;图片应用:&lt;/p&gt;&lt;img id=\"scream\" src=\"img_the_scream.jpg\"&gt;&lt;p&gt;画布:&lt;/p&gt;&lt;canvas id=\"myCanvas\" width=\"300\" height=\"150\" style=\"border:1px solid #d3d3d3;\"&gt;您的浏览器不支持 HTML5 canvas 标签。&lt;/canvas&gt; 1234567document.getElementById(\"scream\").onload=function()&#123; var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); var img=document.getElementById(\"scream\"); ctx.drawImage(img,90,130,50,60,10,10,50,60);&#125;; 关于drawImage的使用有三种语法的使用： context.drawImage(img,dx,dy); context.drawImage(img,dx,dy,dw,dh); context.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh); 坐标草图 对图片进行剪切12345678910111213141516let IMG = &#123; file: 0, //图片文件 width: 0, //源图片宽度 height: 0, //源图片高度 firstY: 330, //第一次剪切高度（从0开始） secondY: 410, //第二次剪切高度（第二次开始剪切的y坐标） money: \"-588.00\", //要修改的数字 bg: \"#f7f7f7\", //#f5f5f5 fontSize:'60px',&#125;pic.onload = function() &#123; IMG.height = pic.height; IMG.width = pic.width; ctx1.drawImage(pic, 0, 0, pic.width, IMG.firstY, 0, 0, pic.width, IMG.firstY); ctx2.drawImage(pic, 0, IMG.secondY, pic.width, (IMG.height - IMG.secondY), 0, 0, pic.width, (IMG.height -IMG.secondY));&#125; 对图片要要修改的部分用html代替显示，然后html转图片12345678910111213141516html2canvas(canvasBox, &#123; allowTaint: true, //允许污染 taintTest: true, //在渲染前测试图片 useCORS: true, //使用跨域 background:IMG.bg, dpi: window.devicePixelRatio * 2, //分辨率，是图片清晰点 scale: 2, height: IMG.height - 10, //截图高度 width: IMG.width, //截图宽度&#125;).then(function(canvas) &#123; //显示ps好的图片 let show = document.getElementById('show'); show.style.display = 'block'; show.src = canvas.toDataURL(); canvasBox.style.display = 'none';&#125;) 此次是对支付宝账单详情的金额进行ps，整个源码地址==&gt;canvas对支付宝账单详情进行P图","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"},{"name":"html2canvas","slug":"html2canvas","permalink":"http://lawsan.xyz/tags/html2canvas/"}]},{"title":"聊聊几种排序算法","slug":"聊聊几种排序算法","date":"2020-07-02T08:09:54.494Z","updated":"2020-07-03T14:57:34.258Z","comments":true,"path":"2020/07/02/聊聊几种排序算法/","link":"","permalink":"http://lawsan.xyz/2020/07/02/%E8%81%8A%E8%81%8A%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"Javascript API实现排序12let arr = [72, 45, 62, 12, 23, 67, 80, 56, 90, 6, 9];arr.sort((a,b)=&gt;a-b); 冒泡排序基本思路：每次执行循环就把一个最大的数放到最后，就像气泡一样一个一个的冒；第一个循环遍历数组所有元素，第二个循环遍历是找出最大数值然后放在最后，时间复杂度为O(n2)。 1234567891011function bubbleSort(arr) &#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; //两个数比较，i表示数组总个数，j代表第一个数（索引较前）最大就是倒数第二个数 for (let j = 0; j &lt; arrLength - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] //交换两个数值 &#125; &#125; &#125;&#125; 选择排序基本思路： 每次执行循环找出最小值的索引值，并把这个最小放到前面，索引i前面的数组是依次排好的，时间复杂度为O(n2)。 与冒泡排序比较，冒泡排序是每次找出最大值放到最后而选择排序这是每次找出最小值放到前面。每次循环都会从乱序数组中找出最大（最小）值排到有序数组中。 1234567891011121314function selectSort(arr)&#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; let minIndex = i //每次循环找出最小值索引 for(let j = i;j&lt;arrLength;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j &#125; &#125; //把最小值放到前面数组 [arr[i],arr[minIndex]] = [arr[minIndex],arr[i]] &#125;&#125; 插入排序基本思路：在已有排序的数组中找出自己位置，插入其中； 12345678910111213141516function insertSort(arr)&#123; let arrLength = arr.length let preIndex,current for(let i = 1;i&lt;arrLength;i++)&#123; preIndex = i - 1 current = arr[i] //这个循环就是找出自己的位置，然后跳出，比较这个原始和current的大小，大则移后 while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current)&#123; arr[preIndex + 1] = arr[preIndex] 45,72,72 preIndex --; &#125; //插入 arr[preIndex + 1] = current; &#125;&#125; 归并排序基本思路：该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 123456789101112131415161718192021222324252627282930function mergeSort(arr)&#123; let len = arr.length if(len&lt;2)&#123; return arr &#125; //把长度为n的输入序列分成两个长度为n/2的子序列 let mid = Math.floor(len/2) let left = arr.slice(0,mid) let right = arr.slice(mid) //对这两个子序列分别采用归并排序 return merge(mergeSort(left),mergeSort(right))&#125;//将两个排序好的子序列合并成一个最终的排序序列。function merge(left,right)&#123; let result = [] while(left.length &gt; 0 &amp;&amp; right.length &gt; 0)&#123; if(left[0] &lt;= right[0])&#123; result.push(left.shift()) &#125;else&#123; result.push(right.shift()) &#125; &#125; while(left.length)&#123; result.push(left.shift()) &#125; while(right.length)&#123; result.push(right.shift()) &#125; return result&#125; 快速排序基本思路： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。12345678910111213141516171819202122232425function quickSort(arr,left,right)&#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if(left &lt; right)&#123; partitionIndex = partition(arr, left ,right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) &#125; return arr&#125;//分区操作function partition(arr, left ,right)&#123; var pivot = left, index =pivot + 1; for(var i = index;i &lt;= right; i++)&#123; if(arr[i] &lt; arr[pivot])&#123; [arr[i],arr[index]] = [arr[index],arr[i]] index++ &#125; &#125; [arr[pivot],arr[index-1]] = [arr[index-1],arr[pivot]] return index-1&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"Vue监听回车事件@keyup","slug":"Vue监听回车事件keyup","date":"2020-06-30T13:08:05.000Z","updated":"2020-07-03T10:49:37.730Z","comments":true,"path":"2020/06/30/Vue监听回车事件keyup/","link":"","permalink":"http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/","excerpt":"","text":"当我们要在一个输入框中监听回车事件时要绑定keyup事件；keydown当键盘被按下时会触发；keyup当键盘松开时触发； 1&lt;input type=\"text\" value=\"\" id=\"search_input\"/&gt; 原生JavaScript实现;1234567document.getElementById('search_input').onkeyup = function(e)&#123; var theEvent = window.event || e; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; //doSomeThing... &#125;&#125; jQuery实现；12345$(\"#search_input\").keyup(function(e)&#123; if (e.keyCode == 13) &#123; //doSomeThing... &#125;&#125;) Vue事件绑定实现全部键盘别名 enter,tab,delete,esc,space,up,down,left,right;组合按键 ctr,alt,shift,meta(window系统下是win键，mac下是command键) 12345&lt;input type=\"text\" @keyup.enter=\"search\" v-model=\"search_input\"/&gt;//methodssearch()&#123; //doSomeThing...&#125; 如果是封装组件的话，例如element的el-input，要加上native; 1&lt;el-input v-model=\"search_input\" @keyup.enter.native=\"search\"&gt;&lt;/el-input&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}],"categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"HTTP","slug":"HTTP","permalink":"http://lawsan.xyz/tags/HTTP/"},{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://lawsan.xyz/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://lawsan.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://lawsan.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"},{"name":"html2canvas","slug":"html2canvas","permalink":"http://lawsan.xyz/tags/html2canvas/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}