{"meta":{"title":"Lawson's Blog","subtitle":"尝尽人间百味，方知人间冷暖。","description":"劳生穿的博客。做人最重要的是开心。","author":"Lawson","url":"http://lawsan.xyz","root":"/"},"pages":[{"title":"关于","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-03T02:32:34.343Z","comments":true,"path":"about/index.html","permalink":"http://lawsan.xyz/about/index.html","excerpt":"","text":".info_content { padding-left: 20px; display: flex; } .info_details ul>li { list-style-type: none; } .text-indent { text-indent: 2em; } 姓名：阿穿 性别：男 职业：前端CV工程师 爱好：玩游戏，看电影,codeing... 英文名：Lawson 年龄：22 学历：本科 我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。 window.onload = function() { var detail = document.getElementById('my_info_details'); var detail1 = document.getElementById('my_info_details1'); var detailText = `我是一个热爱钻研计算机技术的青少年，从小就对搞IT的人(黑客)特别崇拜，因此总是对一些游戏破解、互联网技术着迷。最开始接触编程还得有了设备(电脑)说起，应该是高二（2015年）吧，那是并不知道什么C、Java等编程语言只知道一门易语言，电脑安装易语言程序后开始了coding...。要说真正了解计算机还得从我的入门语言C语言开始，然后后面就是一大堆技术，Java、SQL、PHP、Python、JavaScript、数据结构、算法、计算机组成原理等等。 入门前端方向开始于我的第一个登陆页面，用Dreamweaver编写的登陆页面，页面简陋也没有请求拦截。再后来会用jQuery、Ajax、JSON数据和后台交互，使用Bootstrap以及相关的jQuery插件编写页面。再后来学习了Vue框架结合各种UI(Elemment、iView )进行开发组件化地开发页面，真香！JavaScript发展到了服务端，我也开始了在服务端coding，Node+websocket开发实时聊天程序，Node+express开发博客网站，jQuery+Bootstrap个人展示网站，公众号开发等等。`; var detailText1 = `前路漫漫，唯独自己变强才能走到最后，加油！奥利给。`; typing(detail, detailText, 100) .then(()=>{typing(detail1, detailText1, 100)}) .catch((e)=>{ console.log(e) }) function typing(dom, text, time) { return new Promise((resolve, reject) => { var i = 0; var timer = setInterval(function() { if (i"},{"title":"","date":"2020-07-01T11:59:23.000Z","updated":"2020-07-02T04:46:10.999Z","comments":true,"path":"categories/index.html","permalink":"http://lawsan.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-01T11:58:40.000Z","updated":"2020-07-02T09:53:45.042Z","comments":true,"path":"tags/index.html","permalink":"http://lawsan.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浏览器架构你了解多少？","slug":"浏览器架构你了解多少","date":"2020-07-08T02:45:05.000Z","updated":"2020-07-09T10:44:13.821Z","comments":true,"path":"2020/07/08/浏览器架构你了解多少/","link":"","permalink":"http://lawsan.xyz/2020/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/","excerpt":"","text":"进程与线程 进程是资源分配的最小单位,线程是程序执行的最小单位。 同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，而进程共享进程中的数据的，使用相同的地址空间； 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 单进程浏览器时代顾名思义，单进程浏览器是指浏览器所以模块都运行再同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。单进程浏览器的架构如下图所示👇 如此多的功能模块运行在一个进程里，肯定有着不足的： 不稳定性：只要一个线程崩溃，这个进程就崩溃，浏览就用不了了。 不流畅： 多个任务共用一个线程，比如页面线程。 不安全：没有沙箱机制。 多进程浏览器时代早期多进程架构 从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分） 解决早期浏览器不稳定问题：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。 解决早期浏览器不流畅问题：JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。 解决早期浏览器不安全问题：用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。 目前多进程架构 从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。下面我们来逐个分析下这几个进程的功能👇 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。 GPU进程。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 多进程带来的问题： 更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。 更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了 面向未来的架构为了解决上面的问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型。 试题 为什么单进程浏览器当时不可以采用安全沙箱？如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。 打开Chrome浏览器一个Tab页面，至少会出现几个进程？最新的Chrome浏览器包括至少四个:1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程,当然还有复杂的情况； 页面中有iframe的话,iframe会单独在进程中 有插件的话，插件也会开启进程 多个页面属于同一站点，并且从a打开b页面，会共用一个渲染进程 装了扩展的话，扩展也会占用进程这些进程都可以通过Chrome任务管理器来查看 即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。更加简单的来说，就是如果多个页面符合同一站点，这几个页面会分配到一个渲染进程中去,所以有这样子的一种情况,一个页面崩溃了，会导致同一个站点的其他页面也奔溃，这是因为它们使用的是同一个渲染进程。它们在一个渲染进程中的话，它们就会共享JS执行环境，也就是A页面可以直接在B页面中执行脚本了。","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"经典算法以及数据结构","slug":"经典算法以及数据结构","date":"2020-07-07T09:31:21.000Z","updated":"2020-07-07T10:49:35.829Z","comments":true,"path":"2020/07/07/经典算法以及数据结构/","link":"","permalink":"http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"斐波那契数列在算法题中比较经典，故出此文以此铭记。题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&lt;=39 暴力递归实现1234function Fibonacci(n)&#123; if(n == 0 || n == 1) return n return Fibonacci(n-1) + Fibonacci(n-2)&#125; 数组保存计算缓存，减少计算12345678function Fibonacci(n)&#123; let arr = [0,1] return Fib(n) function Fib(n)&#123; if(arr[n] !== undefined ) return arr[n] //计算过的不用再计算 return arr[n] = Fib(n-1) + Fib(n-2) &#125;&#125; 动态规划12345678function Fibonacci(n)&#123; let a = 0 //第一项 let b = 1 //第二项 for(let i = 2;i&lt; n;i++ )&#123; //从第二项开始到n-1项 [a,b] = [b,a+b] &#125; return a+b&#125; 感觉这篇幅有点短，好吧再加几个算法题^_^ 经典算法二分查找题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1234567891011121314151617function Find(target,array)&#123; for(let i =0 ;i&lt;array.length;i++)&#123; let low = 0 //每行的开始索引 let height = array[i].length - 1 //每行的最大索引 while(low &lt;= height)&#123; //对每一行的数组进行二分查找 let mid = Math.floor((low+height)/2) if(target &gt; array[i][mid])&#123; low = mid + 1 &#125;else if(target &lt; array[i][mid])&#123; height = mid -1 &#125;else&#123; return true &#125; &#125; &#125; return false //没有找到&#125; 此题还有一种更好的思路：既然是递增数组，那我们就比较一下每一行数组最大的元素，如果此数大于这一行的最大元素则去下一行数组比较，如果此数小于这一行的最大元素则去前一列比较； 123456789101112131415function Find(target,array)&#123; let row = 0 let col = array[0].length -1 let len = array.length while(row &lt; len &amp;&amp; 0 &lt;= col)&#123; //row是索引要小于行数，col要大于0 if(target &gt; array[row][col])&#123; row++ &#125;else if(target &lt; array[row][col])&#123; col-- &#125;else&#123; return true &#125; &#125; return false&#125; 链表链表也是数据结构中的一种，由指针指向。题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 1234567891011121314/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function printListFromTailToHead(head)&#123; let ArrayList = [] while(head)&#123; ArrayList.push(head.val) head = head.next &#125; ArrayList.reverse() return ArrayList&#125; JavaScript实现队列队列是数据结构中的一种，先进先出FIFO,我们用数组来实现它。 123456789101112131415function Queue()&#123; let arr = [] this.pop = function()&#123; if(arr.length &lt;= 0) return return arr.shift() &#125; this.push = function(data)&#123; arr.push(data) &#125;&#125;let queue = new Queue()queue.push(1)queue.push(2)queue.push(3)queue.pop() //1 JavaScript实现栈栈是数据结构中的一种，先进先出FILO,我们用数组来实现它。 12345678910111213141516function Stack()&#123; let value = [] this.pop = function()&#123; if(value.length &lt;= 0) return return value.pop() &#125; this.push = function(data)&#123; value.push(data) &#125;&#125;let stack = new Stack()stack.push(1)stack.push(2)stack.push(3)stack.pop() //3 好了此次的文章就写到这了，祝高三学子高考顺利！！！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://lawsan.xyz/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://lawsan.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://lawsan.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"canvas踩坑日记","slug":"canvas踩坑日记","date":"2020-07-02T08:25:24.000Z","updated":"2020-07-07T05:31:45.698Z","comments":true,"path":"2020/07/02/canvas踩坑日记/","link":"","permalink":"http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/","excerpt":"","text":"这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过html2canvas.js转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。 利用canvas的API进行剪切注意：Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。也就是说通过css给canvas添加样式是行不通的（这个坑费了我好多时间)。解决方案：动态添加canvas； 123456&lt;p&gt;图片应用:&lt;/p&gt;&lt;img id=\"scream\" src=\"img_the_scream.jpg\"&gt;&lt;p&gt;画布:&lt;/p&gt;&lt;canvas id=\"myCanvas\" width=\"300\" height=\"150\" style=\"border:1px solid #d3d3d3;\"&gt;您的浏览器不支持 HTML5 canvas 标签。&lt;/canvas&gt; 1234567document.getElementById(\"scream\").onload=function()&#123; var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); var img=document.getElementById(\"scream\"); ctx.drawImage(img,90,130,50,60,10,10,50,60);&#125;; 关于drawImage的使用有三种语法的使用： context.drawImage(img,dx,dy); context.drawImage(img,dx,dy,dw,dh); context.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh); 坐标草图 对图片进行剪切12345678910111213141516let IMG = &#123; file: 0, //图片文件 width: 0, //源图片宽度 height: 0, //源图片高度 firstY: 330, //第一次剪切高度（从0开始） secondY: 410, //第二次剪切高度（第二次开始剪切的y坐标） money: \"-588.00\", //要修改的数字 bg: \"#f7f7f7\", //#f5f5f5 fontSize:'60px',&#125;pic.onload = function() &#123; IMG.height = pic.height; IMG.width = pic.width; ctx1.drawImage(pic, 0, 0, pic.width, IMG.firstY, 0, 0, pic.width, IMG.firstY); ctx2.drawImage(pic, 0, IMG.secondY, pic.width, (IMG.height - IMG.secondY), 0, 0, pic.width, (IMG.height -IMG.secondY));&#125; 对图片要要修改的部分用html代替显示，然后html转图片12345678910111213141516html2canvas(canvasBox, &#123; allowTaint: true, //允许污染 taintTest: true, //在渲染前测试图片 useCORS: true, //使用跨域 background:IMG.bg, dpi: window.devicePixelRatio * 2, //分辨率，是图片清晰点 scale: 2, height: IMG.height - 10, //截图高度 width: IMG.width, //截图宽度&#125;).then(function(canvas) &#123; //显示ps好的图片 let show = document.getElementById('show'); show.style.display = 'block'; show.src = canvas.toDataURL(); canvasBox.style.display = 'none';&#125;) 此次是对支付宝账单详情的金额进行ps，整个源码地址==&gt;canvas对支付宝账单详情进行P图","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"},{"name":"html2canvas","slug":"html2canvas","permalink":"http://lawsan.xyz/tags/html2canvas/"}]},{"title":"聊聊几种排序算法","slug":"聊聊几种排序算法","date":"2020-07-02T08:09:54.494Z","updated":"2020-07-03T14:57:34.258Z","comments":true,"path":"2020/07/02/聊聊几种排序算法/","link":"","permalink":"http://lawsan.xyz/2020/07/02/%E8%81%8A%E8%81%8A%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"Javascript API实现排序12let arr = [72, 45, 62, 12, 23, 67, 80, 56, 90, 6, 9];arr.sort((a,b)=&gt;a-b); 冒泡排序基本思路：每次执行循环就把一个最大的数放到最后，就像气泡一样一个一个的冒；第一个循环遍历数组所有元素，第二个循环遍历是找出最大数值然后放在最后，时间复杂度为O(n2)。 1234567891011function bubbleSort(arr) &#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; //两个数比较，i表示数组总个数，j代表第一个数（索引较前）最大就是倒数第二个数 for (let j = 0; j &lt; arrLength - 1 - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] //交换两个数值 &#125; &#125; &#125;&#125; 选择排序基本思路： 每次执行循环找出最小值的索引值，并把这个最小放到前面，索引i前面的数组是依次排好的，时间复杂度为O(n2)。 与冒泡排序比较，冒泡排序是每次找出最大值放到最后而选择排序这是每次找出最小值放到前面。每次循环都会从乱序数组中找出最大（最小）值排到有序数组中。 1234567891011121314function selectSort(arr)&#123; let arrLength = arr.length for (let i = 0; i &lt; arrLength; i++) &#123; let minIndex = i //每次循环找出最小值索引 for(let j = i;j&lt;arrLength;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j &#125; &#125; //把最小值放到前面数组 [arr[i],arr[minIndex]] = [arr[minIndex],arr[i]] &#125;&#125; 插入排序基本思路：在已有排序的数组中找出自己位置，插入其中； 12345678910111213141516function insertSort(arr)&#123; let arrLength = arr.length let preIndex,current for(let i = 1;i&lt;arrLength;i++)&#123; preIndex = i - 1 current = arr[i] //这个循环就是找出自己的位置，然后跳出，比较这个原始和current的大小，大则移后 while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current)&#123; arr[preIndex + 1] = arr[preIndex] 45,72,72 preIndex --; &#125; //插入 arr[preIndex + 1] = current; &#125;&#125; 归并排序基本思路：该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。 123456789101112131415161718192021222324252627282930function mergeSort(arr)&#123; let len = arr.length if(len&lt;2)&#123; return arr &#125; //把长度为n的输入序列分成两个长度为n/2的子序列 let mid = Math.floor(len/2) let left = arr.slice(0,mid) let right = arr.slice(mid) //对这两个子序列分别采用归并排序 return merge(mergeSort(left),mergeSort(right))&#125;//将两个排序好的子序列合并成一个最终的排序序列。function merge(left,right)&#123; let result = [] while(left.length &gt; 0 &amp;&amp; right.length &gt; 0)&#123; if(left[0] &lt;= right[0])&#123; result.push(left.shift()) &#125;else&#123; result.push(right.shift()) &#125; &#125; while(left.length)&#123; result.push(left.shift()) &#125; while(right.length)&#123; result.push(right.shift()) &#125; return result&#125; 快速排序基本思路： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。12345678910111213141516171819202122232425function quickSort(arr,left,right)&#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if(left &lt; right)&#123; partitionIndex = partition(arr, left ,right) quickSort(arr, left, partitionIndex-1) quickSort(arr, partitionIndex+1, right) &#125; return arr&#125;//分区操作function partition(arr, left ,right)&#123; var pivot = left, index =pivot + 1; for(var i = index;i &lt;= right; i++)&#123; if(arr[i] &lt; arr[pivot])&#123; [arr[i],arr[index]] = [arr[index],arr[i]] index++ &#125; &#125; [arr[pivot],arr[index-1]] = [arr[index-1],arr[pivot]] return index-1&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"Vue监听回车事件@keyup","slug":"Vue监听回车事件keyup","date":"2020-06-30T13:08:05.000Z","updated":"2020-07-03T10:49:37.730Z","comments":true,"path":"2020/06/30/Vue监听回车事件keyup/","link":"","permalink":"http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/","excerpt":"","text":"当我们要在一个输入框中监听回车事件时要绑定keyup事件；keydown当键盘被按下时会触发；keyup当键盘松开时触发； 1&lt;input type=\"text\" value=\"\" id=\"search_input\"/&gt; 原生JavaScript实现;1234567document.getElementById('search_input').onkeyup = function(e)&#123; var theEvent = window.event || e; var code = theEvent.keyCode || theEvent.which || theEvent.charCode; if (code == 13) &#123; //doSomeThing... &#125;&#125; jQuery实现；12345$(\"#search_input\").keyup(function(e)&#123; if (e.keyCode == 13) &#123; //doSomeThing... &#125;&#125;) Vue事件绑定实现全部键盘别名 enter,tab,delete,esc,space,up,down,left,right;组合按键 ctr,alt,shift,meta(window系统下是win键，mac下是command键) 12345&lt;input type=\"text\" @keyup.enter=\"search\" v-model=\"search_input\"/&gt;//methodssearch()&#123; //doSomeThing...&#125; 如果是封装组件的话，例如element的el-input，要加上native; 1&lt;el-input v-model=\"search_input\" @keyup.enter.native=\"search\"&gt;&lt;/el-input&gt;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}],"categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"算法","slug":"算法","permalink":"http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://lawsan.xyz/tags/%E9%80%92%E5%BD%92/"},{"name":"动态规划","slug":"动态规划","permalink":"http://lawsan.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://lawsan.xyz/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"canvas","slug":"canvas","permalink":"http://lawsan.xyz/tags/canvas/"},{"name":"html2canvas","slug":"html2canvas","permalink":"http://lawsan.xyz/tags/html2canvas/"},{"name":"排序算法","slug":"排序算法","permalink":"http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"Vue","slug":"Vue","permalink":"http://lawsan.xyz/tags/Vue/"},{"name":"Element","slug":"Element","permalink":"http://lawsan.xyz/tags/Element/"}]}