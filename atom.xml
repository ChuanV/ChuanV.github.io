<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lawson&#39;s Blog</title>
  
  <subtitle>尝尽人间百味，方知人间冷暖。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lawsan.xyz/"/>
  <updated>2020-07-13T05:34:13.400Z</updated>
  <id>http://lawsan.xyz/</id>
  
  <author>
    <name>Lawson</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP1.0、HTTP1.1与HTTP2.0有啥变化？</title>
    <link href="http://lawsan.xyz/2020/07/13/HTTP1.0%E3%80%81HTTP1.1%E4%B8%8EHTTP2.0%E6%9C%89%E5%95%A5%E5%8F%98%E5%8C%96%EF%BC%9F/"/>
    <id>http://lawsan.xyz/2020/07/13/HTTP1.0%E3%80%81HTTP1.1%E4%B8%8EHTTP2.0%E6%9C%89%E5%95%A5%E5%8F%98%E5%8C%96%EF%BC%9F/</id>
    <published>2020-07-13T04:25:45.000Z</published>
    <updated>2020-07-13T05:34:13.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>计算机网络是一个开发人员的基础知识，今天我们就来聊聊HTTP的发展历史吧。<br>影响一个网络的因素有：<br>带宽：带宽的大小决定你网络的速率，比如100Mbps的宽带，理论上每秒下载量100Mbps/8 = 12.5m;上行一般都较小，大概30Mbps左右。<br>延迟：有时候你打游戏的时候，打的正爽，然后网络延时了（460）；在浏览器中，可能是以下原因：</p><ul><li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 6个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。<h3 id="HTTP协议是啥？"><a href="#HTTP协议是啥？" class="headerlink" title="HTTP协议是啥？"></a>HTTP协议是啥？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E6%88%91%E5%8F%88%E4%B8%8D%E8%AF%86%E5%AD%97.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>HTTP协议 ：Hyper Text Transfer Protocol（超文本传输协议）,是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</li></ul><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><p>HTTP/0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP/0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。<br>HTTP/0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。<br>一次HTTP/0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>在HTTP 1.0中对上一代的版本添加了很多功能：</p><ol><li>请求与响应支持头域</li><li>响应对象以一个响应状态行开始</li><li>响应对象不只限于超文本</li><li>开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法</li><li>支持长连接（但默认还是使用短连接），缓存机制，以及身份认证</li></ol><p><strong>缺点</strong>：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p> 是目前使用最广泛的协议版本，相对于HTTP/1.0新增了以下内容：</p><ol><li><strong>引入了持久连接</strong>（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接；</li><li><strong>多了一些缓存处理字段</strong>HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。</li><li>1.1版还新增了许多请求方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</li><li><strong>引入了管道机制</strong>（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</li><li><strong>采用分块传输编码</strong>，对于一些很耗时的动态操作，服务器需要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer），这是支持文件断点续传的基础。<br><strong>缺点</strong>：虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。<br>这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。</li></ol><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP 2.0 主要基于<code>SPDY协议</code>。HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。<br><strong>SPDY协议是啥？</strong><br>它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过<code>压缩</code>、<code>多路复用</code>和<code>优先级</code>等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是<code>尽量减少TCP连接数</code>。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p><h4 id="HTTP-1-x协议的缺陷"><a href="#HTTP-1-x协议的缺陷" class="headerlink" title="HTTP 1.x协议的缺陷"></a>HTTP 1.x协议的缺陷</h4><ol><li>HTTP 1.0 一个TCP连接只能发起一个HTTP请求，在资源多面前，每次连接都要3次TCP握手还有断开的4次握手，非常费时间。</li><li>HTTP 1.1 一个TCP连接能发起多个HTTP请求，但是会出现队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。</li><li>单向请求，只能由客户端发起。</li><li>请求报文与响应报文首部信息冗余量大。</li><li>数据未压缩，导致数据的传输量大。<br><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">HTTP1.1与HTTP2.0速度比较</a><h4 id="HTTP-2-0的特点"><a href="#HTTP-2-0的特点" class="headerlink" title="HTTP 2.0的特点"></a>HTTP 2.0的特点</h4>HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。</li><li>二进制分帧：HTTP 2.0 的所有帧都采用二进制编码；在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E8%BE%93.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。</li><li>多路复用：多路复用允许同时通过单一的HTTP/2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2.0不再依赖多个TCP 连接去处理更多并发的请求。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端根据每个帧首部的流标识符把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。</li><li>头部压缩：随着web功能越来越复杂，请求数量越来越多，随之而来的就是头部的流量越来越多，并且在建立初次链接之后的链接也要发送user-agent等信息，是在是一种浪费。因此，http2提出了对请求和响应的头部进行压缩，即不再只是压缩主题部分，这种压缩方式就是HAPCK — 其设计简单而灵活。</li><li>服务器推送：服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</li><li>更多安全：HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。</li></ol><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>版本更新都是为了解决上一代的棘手问题，HTTP3.0协议基于QUIC，（Quick UDP Internet Connections)基于UDP的传输层协议。计算机网络在发明至今发展飞快，技术迭代迅速，科技的进步也给我们的生活带来了便利。<br>好了，就写到这了！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E7%A0%96%E5%8E%82%E7%B9%81%E5%BF%99%EF%BC%8C%E5%91%8A%E8%BE%9E.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;计算机网络是一个开发人员的基础知识，今天我们就来聊聊HTTP的发展历史吧。&lt;br&gt;影响一个网络的因素有：&lt;br&gt;带宽：带宽的大小决定你网络的
      
    
    </summary>
    
    
    
      <category term="HTTP" scheme="http://lawsan.xyz/tags/HTTP/"/>
    
      <category term="计算机网络" scheme="http://lawsan.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>一文带你了解前端模块化</title>
    <link href="http://lawsan.xyz/2020/07/12/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://lawsan.xyz/2020/07/12/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2020-07-12T10:05:20.000Z</published>
    <updated>2020-07-12T13:31:40.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着项目越来越复杂，我们写的代码也越来越多了。代码越来越难维护，全局的命名污染，依赖不明确等等。<br>为了解决此问题，衍生有许多模块化规范。前端模块化发展历程： <code>无模块化</code> ==&gt; <code>CommonJS规范</code> ==&gt; <code>AMD规范</code> ==&gt; <code>CMD规范</code> ==&gt; <code>ES6模块化</code></p><h3 id="模块化是个啥？"><a href="#模块化是个啥？" class="headerlink" title="模块化是个啥？"></a>模块化是个啥？</h3><p>在ES5中，只有全局作用域和函数作用域，一旦在函数体中声明变量没有添加 <code>var</code>，就会造成全局污染。在ES6中有了<code>let</code>，<code>const</code>，这样就有了块作用域。<br><strong>模块化</strong>：指解决一个复杂的问题时自顶向下把系统划分成若干模块的过程，有多种属性，分别反映其内部特性；将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起；块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信；<br><strong>模块化组成</strong>：数据（内部属性），操作数据的行为（内部函数）。<br><strong>ES5中怎么实现模块化？</strong></p><ul><li><strong>原始写法</strong>：无模块可言，会污染全局作用域，看不出依赖关系。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>对象写法</strong>：对象会暴露所有模块成员，内部状态可以被外部改写。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">count:<span class="number">0</span>,</span><br><span class="line">foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;,</span><br><span class="line">bar:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>立即执行函数(IIFE)</strong>:避免暴露私有成员，数据是私有的, 外部只能通过暴露的方法操作。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> increaseCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">count++</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">var</span> decreaseCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">count--</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;increaseCount,decreaseCount&#125; <span class="comment">//ES6简写，ES5 ==&gt;  &#123;increaseCount:increaseCount,...&#125;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li>**IIFE的增强（依赖引入）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> _$body = $(<span class="string">"body"</span>)</span><br><span class="line"><span class="keyword">var</span> logBody = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(_$body)</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;logBody&#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure><h3 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h3>比如以下代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"jquery.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="bootstrap.min.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"main.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="do.js"&gt;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>简单粗暴引入文件即可，但是顺序不能错，因为后面的代码依赖着前面的代码。而且代码变量的命名可能冲突，可能在<code>main.js</code>里面声明了变量<code>foo</code>在<code>do.js</code>文件里面又声明了，或者直接用了该变量，又或者修改了该变量。<br>无模块化带来的问题：</li></ul><ol><li>污染全局作用域</li><li>依赖关系不明显</li><li>维护成本高</li></ol><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>该规范最初是用在服务器端的node的，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。<br>实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用require加载模块（同步）。注意这是同步加载，在浏览器同步加载是会阻塞的，所以在浏览器不用此规范。<br>优点：解决了依赖、全局变量污染的问题；<strong>CommonJS用同步的方式加载模块</strong>。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，CommonJS不适合浏览器端模块<br><code>module.exports</code> 和 <code>exports</code>的区别：module.exports导出一个对象，exports可以导出多个对象。不过 <code>module.exports.foo == exports.foo</code>也就说<code>exports.属性</code>会自动挂载到没有命名冲突的<code>module.exports.属性</code>,但是不要给<code>exports</code>赋值，一旦有了新值，它就不再绑定到module.exports；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">module</span>.exports.foo = <span class="string">'bar'</span>  <span class="comment">//正确</span></span><br><span class="line">exports = &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125; <span class="comment">//error 这种方式是错误的，相当于重新定义了exports</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是add.js文件</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">Add</span>:add,c&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是main.js文件</span></span><br><span class="line"><span class="keyword">const</span> addFn = <span class="built_in">require</span>(<span class="string">'./add'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(addFn.Add(<span class="number">5</span>,<span class="number">9</span>),addFn.c)<span class="comment">//19,5</span></span><br><span class="line"><span class="comment">//ES6解构赋值，导入</span></span><br><span class="line"><span class="keyword">const</span> &#123;Add,c&#125; = <span class="built_in">require</span>(<span class="string">'./add'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(Add(<span class="number">5</span>,<span class="number">9</span>),c)<span class="comment">//19,5</span></span><br></pre></td></tr></table></figure><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。<br>它采用<strong>异步方式加载模块</strong>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，<strong>等到加载完成之后，这个回调函数才会运行</strong>。<br>AMD也采用require()语句加载模块，但是不同于CommonJS;<br>基本语法：</p><ol><li>定义暴露模块: <code>define([依赖模块名], function(){return 模块对象})</code>;</li><li>引入模块: <code>require([&#39;模块1&#39;, &#39;模块2&#39;, &#39;模块3&#39;], function(m1, m2){//使用模块对象})</code></li><li>指定引用路径:<code>require.config()</code><br>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面引入  打印I am LiSi;I am 18 years old</span></span><br><span class="line">&lt;script data-main=<span class="string">"js/main.js"</span> src=<span class="string">"https://cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">js/</span>logFn.js文件</span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> logAge = <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;age&#125;</span> years old`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;logName,logAge&#125;</span><br><span class="line">&#125;)</span><br><span class="line">js/main.js文件</span><br><span class="line"><span class="built_in">require</span>([<span class="string">'logFn'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">logFn</span>)</span>&#123;</span><br><span class="line">logFn.logName(<span class="string">'LiSi'</span>)</span><br><span class="line">logFn.logAge(<span class="number">18</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>优点：适合在浏览器环境中异步加载模块、并行加载多个模块；<br>缺点：不能按需加载、开发成本大；</li></ol><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p><strong>AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行</strong>。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。<br>在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。<br>说白了就是AMD引入依赖要先执行依赖再跳出执行主程序，而CMD则需要的时候引入，执行完主程序再回来执行依赖；CMD是按需加载，就近原则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面引入 </span></span><br><span class="line"><span class="comment">//module1 show() this is module1 msg</span></span><br><span class="line"><span class="comment">//异步引入依赖模块1  this is module1 msg</span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcdn.net/ajax/libs/seajs/3.0.3/sea.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">seajs.use('./js/main.js')</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">js/module1.js文件</span></span><br><span class="line"><span class="string">define(function (require, exports, module) &#123;</span></span><br><span class="line"><span class="string">  //内部变量数据</span></span><br><span class="line"><span class="string">  var data = 'this is module1'</span></span><br><span class="line"><span class="string">  var msg = 'this is module1 msg'</span></span><br><span class="line"><span class="string">  //内部函数</span></span><br><span class="line"><span class="string">  function show() &#123;</span></span><br><span class="line"><span class="string">    console.log('module1 show() ' + data)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  //向外暴露</span></span><br><span class="line"><span class="string">  exports.show = show</span></span><br><span class="line"><span class="string">  exports.msg = msg</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">js/main.js文件</span></span><br><span class="line"><span class="string">define(function (require, exports, module) &#123;</span></span><br><span class="line"><span class="string"> //引入依赖模块(同步)</span></span><br><span class="line"><span class="string"> var module1 = require('./module1')</span></span><br><span class="line"><span class="string"> function show() &#123;</span></span><br><span class="line"><span class="string">   console.log('module1 show() ' + module1.msg)</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">  show()</span></span><br><span class="line"><span class="string"> //引入依赖模块(异步)</span></span><br><span class="line"><span class="string"> require.async('./module1', function () &#123;</span></span><br><span class="line"><span class="string">   console.log('异步引入依赖模块1  ' + module1.msg)</span></span><br><span class="line"><span class="string"> &#125;)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><p>在ES6中，我们可以使用 import 关键字引入模块，通过 exprot 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的；<br>但是由于ES6在一些浏览器中无法执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。<br>基本用法：</p><ol><li>export 命令用于规定模块的对外接口；</li><li>import 命令用于输入其他模块提供的功能。</li><li><code>export default</code> 暴露一个对象 <code>export</code>暴露多个对象<br>es6在导出的时候有一个默认导出，<code>export default</code>,使用它导出后，在import的时候，不需要加上{}，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">a,b</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">'add.js'</span></span><br><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">a,b</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'add.js'</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="CommonJS规范和-ES6的区别"><a href="#CommonJS规范和-ES6的区别" class="headerlink" title="CommonJS规范和 ES6的区别"></a>CommonJS规范和 ES6的区别</h3><ol><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着项目越来越复杂，我们写的代码也越来越多了。代码越来越难维护，全局的命名污染，依赖不明确等等。&lt;br&gt;为了解决此问题，衍生有许多模块化规范
      
    
    </summary>
    
    
    
      <category term="模块化" scheme="http://lawsan.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存</title>
    <link href="http://lawsan.xyz/2020/07/10/HTTP%E7%BC%93%E5%AD%98/"/>
    <id>http://lawsan.xyz/2020/07/10/HTTP%E7%BC%93%E5%AD%98/</id>
    <published>2020-07-10T08:10:27.000Z</published>
    <updated>2020-07-10T09:16:10.919Z</updated>
    
    <content type="html"><![CDATA[<p>只有不断的学习，才会发现自己是多么无知。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%93%AD%E7%9A%84%E5%BE%88%E5%A4%A7%E5%A3%B0.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不过如果站在巨人的肩膀上的话，我就比别人看的更高更远。今天就来谈谈HTTP缓存机制。</p><h3 id="缓存是啥？"><a href="#缓存是啥？" class="headerlink" title="缓存是啥？"></a>缓存是啥？</h3><p>在浏览一些网站的时候，你有没有发现第二次浏览的时候比一开始的快很多。其实这就是缓存的结果，把第一次加载的网络资源缓存下来，以后请求的时候不用再去服务器获取，直接在本地获取即可。<br>这样可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力，可谓是一石多鸟啊。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%A6%99.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。我们来看一个缓存的流程图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E7%BC%93%E5%AD%98%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次浏览器发起GET请求(POST请求不能缓存)都会判断是否有缓存，首先判断的是强缓存，有则返回资源给浏览器渲染；否则判断是否有协商缓存，有返回资源给浏览器渲染，否则向服务器请求资源。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>当有强缓存在时不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 。<br>强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 <code>Expires</code>、<code>Cache-Control</code> 和 <code>Pragma</code> 3 个 Header 属性共同来控制。<br>优先级：<code>Pragma</code> &gt; <code>Cache-Control</code> &gt; <code>Expires</code>;</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。<br>Expires有一个很大的弊端，就是它返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，Expires是HTTP1.0的产物，现在大多数使用Cache-Control替代。</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p><ul><li><code>max-age</code>：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li><li><code>no-cache</code>：不使用强缓存，需要与服务器验证缓存是否可用</li><li><code>no-store</code>：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li><li><code>private</code>：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li><li><code>public</code>：响应可以被中间代理、CDN 等缓存</li><li><code>must-revalidate</code>：在缓存过期前可以使用，过期后必须向服务器验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;100, must-revalidate, public</span><br></pre></td></tr></table></figure>上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。</li></ul><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否可用；<br>当 Pragma 和 Cache-Control 同时存在的时候，Pragma 的优先级高于 Cache-Control。<br>Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上上面这段meta元标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p>在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified : Fri , 11 May 2019 18:53:33 GMT</span><br></pre></td></tr></table></figure><p>当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since : Fri , 11 May 2019 18:53:33 GMT</span><br></pre></td></tr></table></figure><p>服务端通过If-Modified-Since字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。</p><h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p>代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。<br><strong>If-None-Match和If-Modified-Since同时存在的时候If-None-Match优先级更高</strong>。<br>ETag/If-None-Match 的出现主要解决了 Last-Modified/If-Modified-Since 所解决不了的问题：<br>如果文件的修改频率在秒级以下，Last-Modified/If-Modified-Since 会错误地返回 304<br>如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304<br>好了，HTTP缓存就说到这了，虽然还有很多字段没说，比如 <code>Vary</code>、<code>Date</code>、<code>Age</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E7%A7%83%E5%A4%B4%E5%BF%AB%E4%B9%90.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只有不断的学习，才会发现自己是多么无知。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay
      
    
    </summary>
    
    
    
      <category term="HTTP" scheme="http://lawsan.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理你了解多少</title>
    <link href="http://lawsan.xyz/2020/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/"/>
    <id>http://lawsan.xyz/2020/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/</id>
    <published>2020-07-10T04:21:03.000Z</published>
    <updated>2020-07-10T07:24:44.742Z</updated>
    
    <content type="html"><![CDATA[<p>通过这篇文章，能够让你重新认识浏览器，并把JavaScript，网络，页面渲染，浏览器安全等知识串联起来，从而让你对整个前端体系有全新的认识。<br>这篇文章是上篇文章的追加<a href="/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/">从输入URL到页面展示，这中间发生了啥</a></p><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><ul><li><strong>渲染引擎</strong>：它是浏览器最核心的部分是 “Rendering Engine”，不过我们一般习惯将之称为 “浏览器内核”；</li><li>渲染引擎主要包括的线程：GUI渲染线程、JavaScript引擎线程、事件触发线程、定时器触发线程、HTTP异步请求线程；如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><strong>GUI渲染线程</strong>：GUI 渲染线程负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行。</li><li><strong>JavaScript引擎线程</strong>: JavaScript 引擎线程主要负责解析 JavaScript 脚本并运行相关代码。 JavaScript 引擎在一个Tab页（Renderer 进程）中无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序。需要提起一点就是，GUI线程与JavaScript引擎线程是互斥的，这也是就是为什么JavaScript操作时间过长，会造成页面渲染不连贯，导致页面出现阻塞的原理。</li><li><strong>事件触发线程</strong>：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。 通常JavaScript引擎是单线程的，所以这些事件都会排队等待JS执行。</li><li><strong>定时器触发器</strong>：我们日常使用的setInterval 和 setTimeout 就在该线程中，原因可能就是：由于JS引擎是单线程的，如果处于阻塞线程状态就会影响记时的准确，所以需要通过单独的线程来记时并触发响应的事件这样子更为合理。</li><li><strong>Http请求线程</strong>：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，这个线程就Http请求线程，它 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。<h3 id="简略的渲染流程"><a href="#简略的渲染流程" class="headerlink" title="简略的渲染流程"></a>简略的渲染流程</h3></li></ul><ol><li>处理 HTML 并构建 DOM 树。</li><li>处理 CSS 构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 GPU 绘制，合成图层，显示在屏幕上。<br>流程如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>相关说明：</li></ol><ul><li>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。</li><li>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。</li><li><strong>Load 和 DOMContentLoaded 区别</strong><br>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。<h4 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h4></li><li>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</li><li>通过以下几个常用属性可以生成新图层：</li></ul><ol><li>变换：translate3d、translateZ；</li><li>will-change；</li><li>video、iframe 标签；</li><li>通过动画实现的 opacity 动画转换；</li><li>position: fixed；<h4 id="重绘（Repaint）和回流（Reflow）"><a href="#重绘（Repaint）和回流（Reflow）" class="headerlink" title="重绘（Repaint）和回流（Reflow）"></a>重绘（Repaint）和回流（Reflow）</h4></li></ol><ul><li><strong>回流</strong>是布局或者几何属性需要改变就称为回流。<br>另外一个叫法是重排，回流触发的条件就是:对 DOM 结构的修改引发 DOM 几何尺寸变化的时候,会发生回流过程。<br>会发生回流的情况有如下：</li></ul><ol><li>一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等；</li><li>使 DOM 节点发生增减或者移动；</li><li>读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。</li><li>调用 window.getComputedStyle 方法。</li></ol><p><strong>回流的过程</strong><br>依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%9B%9E%E6%B5%81%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>重绘</strong>是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘<br>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。<br>根据概念，我们知道由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，流程如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E9%87%8D%E7%BB%98%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>跳过了布局树和建图层树,直接去绘制列表，然后在去分块,生成位图等一系列操作。</li><li>可以看到，重绘不一定导致回流，但回流一定发生了重绘。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</li><li>很多人不知道的是，重绘和回流其实和Event loop 有关。</li></ul><ol><li>Event loop 执行完微任务（Microtasks ）后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每(1000/60) = 16ms 才会更新一次。</li><li>然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 media query</li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 requestAnimationFrame 回调</li><li>执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面<br>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。</li></ol><h4 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h4><ul><li>使用 translate 替代 top，在修改定位时，使用translate代替；</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）；</li><li>把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来；</li><li>不要把DOM结点的属性值放在一个循环里当成循环里的变量;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 offsetTop 会导致回流，因为需要去获取正确的值</span><br><span class="line">    console.log(document.querySelector(&#39;.test&#39;).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局;</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame;</li><li>CSS 选择符从右往左匹配查找，避免 DOM 深度过深;</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。<h3 id="详细的渲染流程"><a href="#详细的渲染流程" class="headerlink" title="详细的渲染流程"></a>详细的渲染流程</h3>构建DOM树 ==&gt; 样式计算 ==&gt; 布局阶段 ==&gt; 分层 ==&gt; 绘制 ==&gt; 分块 ==&gt; 光栅化 ==&gt; 合成;<br>从0，1字节流到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程中化为很多的子阶段，渲染引擎从网络进程拿到字节流数据后，经过这些子阶段的处理，最后输出像素，这个过程可以称为渲染流水线 ，我们从一张图上来看👇<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%AD%90%E9%98%B6%E6%AE%B5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%9E%84%E5%BB%BADOM%E6%A0%91%E6%B5%81%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>数据类型改变： 字节 ==&gt; 字符 ==&gt; 令牌 ==&gt; 节点 ==&gt; 对象模型<br>转化过程：<ol><li><strong>转换</strong>:浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li><li><strong>令牌化</strong>：浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“html”、“head”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li><li><strong>词法分析</strong>：发出的令牌转换成定义其属性和规则的“对象”。</li><li><strong>DOM构建</strong>：最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。<h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4></li></ol></li><li><em>格式化样式表*</em><br>我们拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构styleSheets；<br>通过浏览器的控制台document.styleSheets可以来查看这个最终结果。通过JavaScript可以完成查询和修改功能,或者说这个阶段为后面的样式操作提供基石。</li><li><em>标准化样式表*</em><br>有些时候，我们写CSS 样式的时候，会写font-size:2em;color:red;font-weight:bold,像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如em-&gt;px,red-&gt;rgba(255,0,0,0),bold-&gt;700等等。<br>我们来看看标准化的变化过程，如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/css%E6%A0%87%E5%87%86%E5%8C%96.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><em>计算每个DOM节点具体样式*</em><br>通过之前的格式化和标准化后，接下来就是计算每个节点具体样式信息了。<br>计算规则：<code>继承</code>和<code>层叠</code></li><li><em>继承*</em>：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫UserAgent样式。</li><li><em>层叠*</em>：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。<br>不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到window.getComputedStyle当中，也就是可以通过JS来获取计算后的样式，非常方便。<br>这个阶段，完成了DOM节点中每个元素的具体样式，计算过程中要遵循CSS的继承和层叠两条规则，最终输出的内容是每个节点DOM的样式，被保存在ComputedStyle中。</li></ul><h4 id="生成布局树"><a href="#生成布局树" class="headerlink" title="生成布局树"></a>生成布局树</h4><p>上述过程已经完成DOM树（DOM树）构建，以及样式计算（DOM样式），接下来就是要通过浏览器的布局系统确定元素位置，也就是生成一颗布局树（Layout Tree）,之前说法叫渲染树。<br><strong>创建布局树</strong><br>在DOM树上不可见的元素，head元素，meta元素等，以及使用display:none属性的元素，最后都不会出现在布局树上，所以<strong>浏览器布局系统需要额外去构建一棵只包含可见元素布局树。</strong><br>我们直接结合图来看看这个布局树构建过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%B8%83%E5%B1%80%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>主要流程：</p><ol><li>遍历DOM树可见节点，并把这些节点加到布局树中；</li><li>对于不可见的节点，head,meta标签等都会被忽略。对于body.p.span 这个元素，它的属性包含display:none,所以这个元素没有被包含进布局树。</li></ol><p><strong>布局计算</strong><br>这个请看<a href="https://www.rrfed.com/2017/02/26/chrome-layout/" target="_blank" rel="noopener">从Chrome源码看浏览器如何layout布局</a><br><strong>一张图看懂渲染前三步流程：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%B8%B2%E6%9F%93%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>首先需要知道的就是，浏览器在构建完布局树后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，比如一些些复杂的 3D 变换、页面滚动，或者使用 z-index做 z 轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。<br><strong>生成图层树</strong><br>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。<br>我们来看看图层与布局树之间关系，如下图👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%9B%BE%E5%B1%82%E6%A0%91.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。<br>那什么情况下，渲染引擎会为特定的节点创建新图层呢？<br>有两种情况需要分别讨论，一种是<strong>显式合成</strong>，一种是<strong>隐式合成</strong>。<br><strong>显式合成</strong><br>需要剪裁(clip)的地方或者拥有层叠上下文的节点。层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:</p><ol><li>HTML根元素本身就具有层叠上下文。</li><li>普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文。</li><li>元素的 opacity 值不是 1</li><li>元素的 transform 值不是 none</li><li>元素的 filter 值不是 none</li><li>元素的 isolation 值是isolate</li><li>will-change指定的属性值为上面任意一个。</li></ol><p><strong>隐式合成</strong><br>这是一种什么样的情况呢，通俗意义上来说，就是z-index比较低的节点会提升为一个单独的途图层，那么层叠等级比它高的节点都会成为一个独立的图层。<br>在一个大型的项目中，一个z-index比较低的节点被提升为单独图层后，层叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃。这就是<code>层爆炸</code>;</p><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>完成了图层的构建，接下来要做的工作就是图层的绘制了。图层的绘制跟我们日常的绘制一样，每次都会把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个绘制列表，类似于下图👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E7%BB%98%E5%88%B6%E5%88%97%E8%A1%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>接下来我们就要开始绘制操作了，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫<code>合成线程</code>。<br>绘制列表准备好了之后，渲染进程的主线程会给<code>合成线程</code>发送<code>commit</code>消息，把<code>绘制列表</code>提交给合成线程。接下来就是合成线程一展宏图的时候啦。</p><blockquote><p>你想呀，有时候，你的图层很大，或者说你的页面需要使用滚动条，然后页面的内容太多，多的无法想象，这个时候需要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。<br>基于上面的原因，合成线程会讲图层划分为图块(tile);这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。<br><strong>首屏渲染加速：</strong><br>因为后面图块（非视口内的图块）数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。</p></blockquote><h4 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h4><p>接着上面的步骤，有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p><ul><li>图块是栅格化执行的最小单位</li><li>渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据</li><li>合成线程会选择视口附近的图块(tile)，把它交给栅格化线程池生成位图</li><li>生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程<br>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%A0%85%E6%A0%BC%E5%8C%96.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h4>栅格化操作完成后，合成线程会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。<br>浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡<br>两张图总结渲染过程，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%80%BB%E7%BB%93%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%80%BB%E7%BB%93%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>感觉好多东西还没有接触，越细越多，此时我的心情如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E7%86%8A%E7%8C%AB%E4%BA%BA%E5%90%90%E8%A1%80.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过这篇文章，能够让你重新认识浏览器，并把JavaScript，网络，页面渲染，浏览器安全等知识串联起来，从而让你对整个前端体系有全新的认识。&lt;br&gt;这篇文章是上篇文章的追加&lt;a href=&quot;/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5UR
      
    
    </summary>
    
    
    
      <category term="浏览器" scheme="http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面展示，这中间发生了啥</title>
    <link href="http://lawsan.xyz/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/"/>
    <id>http://lawsan.xyz/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/</id>
    <published>2020-07-09T13:48:16.000Z</published>
    <updated>2020-07-09T15:19:36.140Z</updated>
    
    <content type="html"><![CDATA[<p>这道题应该是一个非常经典的题目，包括了HTTP、TCP连接、浏览器缓存、浏览器渲染等等。<br>用户输入URL后，向服务器端发起请求、如果顺利，得到网络响应之后，浏览器对资源进行解析、最后将其渲染到页面上。具体步骤如下👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>首先构建请求</li><li>查找缓存，如果命中缓存，直接使用缓存资源(包括DNS缓存)</li><li>否则进行DNS解析，将域名转换成对应的IP地址</li><li>建立TCP连接</li><li>发送HTTP请求</li><li>如果顺利得到网络响应，浏览器开始解析和渲染</li><li>HTML解释器 解析HTML 为 DOM树</li><li>同时CSS解释器 解析CSS文档 为 styleSheets</li><li>创建布局树，进行布局计算</li><li>整合图层，展示页面<br>我们先来分析一下HTTP请求，请求流程如下👇<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/HTTP%E8%AF%B7%E6%B1%82%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="首先构建请求"><a href="#首先构建请求" class="headerlink" title="首先构建请求"></a>首先构建请求</h2>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP1.1</span><br></pre></td></tr></table></figure><h2 id="查找缓存"><a href="#查找缓存" class="headerlink" title="查找缓存"></a>查找缓存</h2>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。<br>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。<br>这样做的好处有：</li><li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li><li>对于网站来说，缓存是实现快速资源加载的重要组成部分。<br>当然，如果缓存查找失败，就会进入网络请求过程了。</li></ol><h2 id="DNS解析，将域名转换成对应的IP地址"><a href="#DNS解析，将域名转换成对应的IP地址" class="headerlink" title="DNS解析，将域名转换成对应的IP地址"></a>DNS解析，将域名转换成对应的IP地址</h2><p><strong>默认端口</strong> http为80，https为443。<br><strong>DNS解析</strong>：将域名映射成对应的IP地址，这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）<br><strong>DNS数据缓存服务</strong>：浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p><h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2><p><strong>网络OSI七层架构(从低到高)</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br><strong>计算机网络知识</strong>：HTTP在应用层，TCP在传输层，IP在网络层。<br>浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。<br>也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/TCP%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>等待TCP队列</strong>：在建立TCP建立之前，可能要进入TCP队列。因为浏览器的限制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然如果少于6个就不用进入队列等待。<br>浏览器通过TCP3次握手和服务器建立连接，建立连接后进行数据传输，传输完成后，经过4次TCP握手断开连接。如下图👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输。</li><li>网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层。</li><li>底层通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层。</li><li>目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层</li><li>说白就是从网络底层到高层就是对数据脱外套，相反就是穿外套。<br><code>Connection:Keep-Alive</code>:如果请求头里面有这个属性，数据传输完成后，不会断开TCP的。</li></ol><h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>上面大概讲完了建立TCP连接，你可以理解TCP的连接，是为了保证浏览器跟服务器更好的通信。当然了有了上面的这个过程中， HTTP 中的数据也正是在这个通信过程中传输的。<br>那么我们从一张图片中来看，浏览器是如何发送信息给服务器的👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>请求行</strong>：<code>请求方法</code>，<code>请求URL</code> <code>HTTP协议版本</code>；</li><li>请求行大概意思就是告诉服务器，我需要做上面，比如GET方法，我需要向你拿资源，POST方法通常也就是我需要向服务器提交什么数据，需要注意的就是如果是POST方法，浏览器还需要准备好数据，通过请求体发送给服务器。</li><li><strong>请求头</strong>：把浏览器的基础信息告诉服务器，比如包含了浏览器所使用的操作系统，浏览器的内核信息等，还有请求的域名信息，浏览器的Cookie信息等等。</li><li><strong>请求体</strong>：一些业务逻辑需要的数据。</li></ul><h2 id="得到网络响应，浏览器开始解析和渲染"><a href="#得到网络响应，浏览器开始解析和渲染" class="headerlink" title="得到网络响应，浏览器开始解析和渲染"></a>得到网络响应，浏览器开始解析和渲染</h2><p>我们也来看一看响应的报文吧👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>响应行</strong>：HTTP协议版本 状态码，通过常见的状态码，就可以知道处理的结果。</li><li><strong>响应头</strong>：你可以理解成包含服务器自身的一些信息，比如服务器生成数据的时间，返回数据的类型（HTML，流媒体，JSON，XHTML等等）以及服务器在客户端保存的Cookie等信息。响应头中 Cache-Control 字段也很重要，这个涉及到了HTTP缓存，这个字段涵义就是设置缓存资源的时间的</li><li><strong>响应体</strong>：请求返回的内容。<br>返回的状态码中有<code>301</code>或者<code>302</code>即可发生重定向；302为临时重定向，301为永久重定向。<br><code>Content-Type</code>:浏览器会按照这个内容类型来解析。<h2 id="HTML解释器-解析HTML-为-DOM树"><a href="#HTML解释器-解析HTML-为-DOM树" class="headerlink" title="HTML解释器 解析HTML 为 DOM树"></a>HTML解释器 解析HTML 为 DOM树</h2>渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。<br>哎！，感觉后面的内容有点多，再新建一篇文章讲讲后面的内容（浏览器的渲染机制）。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%B0%8F%E9%BB%84%E9%B8%A1%E8%80%B6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这道题应该是一个非常经典的题目，包括了HTTP、TCP连接、浏览器缓存、浏览器渲染等等。&lt;br&gt;用户输入URL后，向服务器端发起请求、如果顺利，得到网络响应之后，浏览器对资源进行解析、最后将其渲染到页面上。具体步骤如下👇&lt;/p&gt;
&lt;figure class=&quot;image-
      
    
    </summary>
    
    
    
      <category term="浏览器" scheme="http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="HTTP" scheme="http://lawsan.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>浏览器架构你了解多少？</title>
    <link href="http://lawsan.xyz/2020/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/"/>
    <id>http://lawsan.xyz/2020/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/</id>
    <published>2020-07-08T02:45:05.000Z</published>
    <updated>2020-07-09T13:14:51.049Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端cv仔和浏览器打交道是最多的，浏览器对我们来说可以说是个黑盒，今天我们就来聊聊浏览器的架构。<br>首先了解一下必要的知识进程和线程。</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ol><li>进程是资源分配的最小单位,线程是程序执行的最小单位。</li><li>同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，而进程共享进程中的数据的，使用相同的地址空间；</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ol><h3 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h3><p>顾名思义，单进程浏览器是指浏览器所以模块都运行再同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。<br>单进程浏览器的架构如下图所示👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如此多的功能模块运行在一个进程里，肯定有着不足的：</p><ol><li>不稳定性：只要一个线程崩溃，这个进程就崩溃，浏览就用不了了。</li><li>不流畅： 多个任务共用一个线程，比如页面线程。</li><li>不安全：没有沙箱机制。</li></ol><h3 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h3><h4 id="早期多进程架构"><a href="#早期多进程架构" class="headerlink" title="早期多进程架构"></a>早期多进程架构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）</p><ul><li><strong>解决早期浏览器不稳定问题</strong>：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</li><li><strong>解决早期浏览器不流畅问题</strong>：JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</li><li><strong>解决早期浏览器不安全问题</strong>：用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><h4 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。<br>下面我们来逐个分析下这几个进程的功能👇</p><ul><li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU进程</strong>。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p><strong>多进程带来的问题</strong>：</p><ol><li>更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li>更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li></ol><h3 id="面向未来的架构"><a href="#面向未来的架构" class="headerlink" title="面向未来的架构"></a>面向未来的架构</h3><p>为了解决上面的问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h3><ul><li><strong>为什么单进程浏览器当时不可以采用安全沙箱？</strong><br>如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。</li><li><strong>打开Chrome浏览器一个Tab页面，至少会出现几个进程？</strong><br>最新的Chrome浏览器包括至少四个:1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程,当然还有复杂的情况；</li></ul><ol><li>页面中有iframe的话,iframe会单独在进程中</li><li>有插件的话，插件也会开启进程</li><li>多个页面属于同一站点，并且从a打开b页面，会共用一个渲染进程</li><li>装了扩展的话，扩展也会占用进程<br>这些进程都可以通过Chrome任务管理器来查看</li></ol><ul><li><strong>即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？</strong><br>Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。<br>更加简单的来说，就是如果多个页面符合同一站点，这几个页面会分配到一个渲染进程中去,所以有这样子的一种情况,一个页面崩溃了，会导致同一个站点的其他页面也奔溃，这是因为它们使用的是同一个渲染进程。<br>它们在一个渲染进程中的话，它们就会共享JS执行环境，也就是A页面可以直接在B页面中执行脚本了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为前端cv仔和浏览器打交道是最多的，浏览器对我们来说可以说是个黑盒，今天我们就来聊聊浏览器的架构。&lt;br&gt;首先了解一下必要的知识进程和线程。&lt;/p&gt;
&lt;h3 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与
      
    
    </summary>
    
    
    
      <category term="浏览器" scheme="http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>经典算法以及数据结构</title>
    <link href="http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-07-07T09:31:21.000Z</published>
    <updated>2020-07-12T15:06:48.241Z</updated>
    
    <content type="html"><![CDATA[<p>斐波那契数列在算法题中比较经典，故出此文以此铭记。<br>题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&lt;=39</p><h3 id="暴力递归实现"><a href="#暴力递归实现" class="headerlink" title="暴力递归实现"></a>暴力递归实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n</span><br><span class="line"><span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组保存计算缓存，减少计算"><a href="#数组保存计算缓存，减少计算" class="headerlink" title="数组保存计算缓存，减少计算"></a>数组保存计算缓存，减少计算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Fib(n)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[n] !== <span class="literal">undefined</span> ) <span class="keyword">return</span> arr[n] <span class="comment">//计算过的不用再计算</span></span><br><span class="line"><span class="keyword">return</span> arr[n] = Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span> <span class="comment">//第一项</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span> <span class="comment">//第二项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i&lt; n;i++ )&#123; <span class="comment">//从第二项开始到n-1项</span></span><br><span class="line">[a,b] = [b,a+b]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这篇幅有点短，好吧再加几个算法题^_^</p><h3 id="经典算法二分查找"><a href="#经典算法二分查找" class="headerlink" title="经典算法二分查找"></a>经典算法二分查找</h3><p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target,array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i&lt;array.length;i++)&#123;</span><br><span class="line"><span class="keyword">let</span> low = <span class="number">0</span> <span class="comment">//每行的开始索引</span></span><br><span class="line"><span class="keyword">let</span> height = array[i].length - <span class="number">1</span> <span class="comment">//每行的最大索引</span></span><br><span class="line"><span class="keyword">while</span>(low &lt;= height)&#123;<span class="comment">//对每一行的数组进行二分查找</span></span><br><span class="line"><span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low+height)/<span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span>(target &gt; array[i][mid])&#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][mid])&#123;</span><br><span class="line">height = mid <span class="number">-1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还有一种更好的思路：既然是递增数组，那我们就比较一下每一行数组最大的元素，如果此数大于这一行的最大元素则去下一行数组比较，如果此数小于这一行的最大元素则去前一列比较；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target,array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> row = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> col = array[<span class="number">0</span>].length <span class="number">-1</span></span><br><span class="line"><span class="keyword">let</span> len = array.length</span><br><span class="line"><span class="keyword">while</span>(row &lt; len &amp;&amp; <span class="number">0</span> &lt;= col)&#123; <span class="comment">//row是索引要小于行数，col要大于0</span></span><br><span class="line"><span class="keyword">if</span>(target &gt; array[row][col])&#123;</span><br><span class="line">row++</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[row][col])&#123;</span><br><span class="line">col--</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表也是数据结构中的一种，由指针指向。<br>题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead</span>(<span class="params">head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ArrayList = []</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        ArrayList.push(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList.reverse()</span><br><span class="line">    <span class="keyword">return</span> ArrayList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript实现队列"><a href="#JavaScript实现队列" class="headerlink" title="JavaScript实现队列"></a>JavaScript实现队列</h3><p>队列是数据结构中的一种，先进先出<code>FIFO</code>,我们用数组来实现它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">return</span> arr.shift()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">arr.push(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line">queue.push(<span class="number">1</span>)</span><br><span class="line">queue.push(<span class="number">2</span>)</span><br><span class="line">queue.push(<span class="number">3</span>)</span><br><span class="line">queue.pop() <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript实现栈"><a href="#JavaScript实现栈" class="headerlink" title="JavaScript实现栈"></a>JavaScript实现栈</h3><p>栈是数据结构中的一种，先进先出<code>FILO</code>,我们用数组来实现它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> value = []</span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(value.length &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">return</span> value.pop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">value.push(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.pop() <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>好了此次的文章就写到这了，祝高三学子高考顺利！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;斐波那契数列在算法题中比较经典，故出此文以此铭记。&lt;br&gt;题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&amp;lt;=39&lt;/p&gt;
&lt;h3 id=&quot;暴力递归实现&quot;&gt;&lt;a href=&quot;#暴力递归实现&quot; c
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>canvas踩坑日记</title>
    <link href="http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    <id>http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</id>
    <published>2020-07-02T08:25:24.000Z</published>
    <updated>2020-07-12T15:07:41.675Z</updated>
    
    <content type="html"><![CDATA[<p>这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过<code>html2canvas.js</code>转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。</p><h3 id="利用canvas的API进行剪切"><a href="#利用canvas的API进行剪切" class="headerlink" title="利用canvas的API进行剪切"></a>利用canvas的API进行剪切</h3><p>注意：Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。<font color=red>也就是说通过css给canvas添加样式是行不通的</font>（这个坑费了我好多时间)。<br>解决方案：动态添加canvas；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>图片应用:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"scream"</span> <span class="attr">src</span>=<span class="string">"img_the_scream.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>画布:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"150"</span> <span class="attr">style</span>=<span class="string">"border:1px solid #d3d3d3;"</span>&gt;</span></span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"scream"</span>).onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span><br><span class="line">    <span class="keyword">var</span> ctx=c.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    <span class="keyword">var</span> img=<span class="built_in">document</span>.getElementById(<span class="string">"scream"</span>);</span><br><span class="line">    ctx.drawImage(img,<span class="number">90</span>,<span class="number">130</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关于drawImage的使用"><a href="#关于drawImage的使用" class="headerlink" title="关于drawImage的使用"></a>关于drawImage的使用</h3><p>有三种语法的使用：</p><ol><li><code>context.drawImage(img,dx,dy);</code></li><li><code>context.drawImage(img,dx,dy,dw,dh);</code></li><li><code>context.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh);</code><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.02/1.jpg" alt="坐标草图" title="">                </div>                <div class="image-caption">坐标草图</div>            </figure>对图片进行剪切<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> IMG = &#123;</span><br><span class="line">file: <span class="number">0</span>, <span class="comment">//图片文件</span></span><br><span class="line">width: <span class="number">0</span>, <span class="comment">//源图片宽度</span></span><br><span class="line">height: <span class="number">0</span>, <span class="comment">//源图片高度</span></span><br><span class="line">firstY: <span class="number">330</span>, <span class="comment">//第一次剪切高度（从0开始）</span></span><br><span class="line">secondY: <span class="number">410</span>, <span class="comment">//第二次剪切高度（第二次开始剪切的y坐标）</span></span><br><span class="line">money: <span class="string">"-588.00"</span>, <span class="comment">//要修改的数字</span></span><br><span class="line">bg: <span class="string">"#f7f7f7"</span>, <span class="comment">//#f5f5f5</span></span><br><span class="line">fontSize:<span class="string">'60px'</span>,</span><br><span class="line">&#125;</span><br><span class="line">pic.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">IMG.height = pic.height;</span><br><span class="line">IMG.width = pic.width;</span><br><span class="line">ctx1.drawImage(pic, <span class="number">0</span>, <span class="number">0</span>, pic.width, IMG.firstY, <span class="number">0</span>, <span class="number">0</span>, pic.width, IMG.firstY);</span><br><span class="line">ctx2.drawImage(pic, <span class="number">0</span>, IMG.secondY, pic.width, (IMG.height - IMG.secondY), <span class="number">0</span>, <span class="number">0</span>, pic.width, (IMG.height -IMG.secondY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对图片要要修改的部分用html代替显示，然后html转图片<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">html2canvas(canvasBox, &#123;</span><br><span class="line">allowTaint: <span class="literal">true</span>, <span class="comment">//允许污染</span></span><br><span class="line">taintTest: <span class="literal">true</span>, <span class="comment">//在渲染前测试图片</span></span><br><span class="line">useCORS: <span class="literal">true</span>, <span class="comment">//使用跨域</span></span><br><span class="line">background:IMG.bg,</span><br><span class="line">dpi: <span class="built_in">window</span>.devicePixelRatio * <span class="number">2</span>, <span class="comment">//分辨率，是图片清晰点</span></span><br><span class="line">scale: <span class="number">2</span>,</span><br><span class="line">height: IMG.height - <span class="number">10</span>, <span class="comment">//截图高度</span></span><br><span class="line">width: IMG.width, <span class="comment">//截图宽度</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">canvas</span>) </span>&#123;</span><br><span class="line"><span class="comment">//显示ps好的图片</span></span><br><span class="line"><span class="keyword">let</span> show = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>);</span><br><span class="line">show.style.display = <span class="string">'block'</span>;</span><br><span class="line">show.src = canvas.toDataURL();</span><br><span class="line">canvasBox.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>此次是对支付宝账单详情的金额进行ps，整个源码地址==&gt;<a href="https://gitee.com/chuan8905/codes/ds7e8pmfqoajn94yxi6c181" target="_blank" rel="noopener">canvas对支付宝账单详情进行P图</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过&lt;code&gt;html2canvas.js&lt;/code&gt;转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。&lt;/p&gt;
&lt;h3 id=&quot;利用canvas的API
      
    
    </summary>
    
    
    
      <category term="canvas" scheme="http://lawsan.xyz/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>聊聊几种排序算法</title>
    <link href="http://lawsan.xyz/2020/07/02/%E8%81%8A%E8%81%8A%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://lawsan.xyz/2020/07/02/%E8%81%8A%E8%81%8A%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-07-02T08:09:54.494Z</published>
    <updated>2020-07-03T14:57:34.258Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Javascript-API实现排序"><a href="#Javascript-API实现排序" class="headerlink" title="Javascript API实现排序"></a>Javascript API实现排序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">72</span>, <span class="number">45</span>, <span class="number">62</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">67</span>, <span class="number">80</span>, <span class="number">56</span>, <span class="number">90</span>, <span class="number">6</span>, <span class="number">9</span>];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b);</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基本思路：每次执行循环就把一个最大的数放到最后，就像气泡一样一个一个的冒；第一个循环遍历数组所有元素，第二个循环遍历是找出最大数值然后放在最后，时间复杂度为O(n2)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> arrLength = arr.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLength; i++) &#123;</span><br><span class="line"><span class="comment">//两个数比较，i表示数组总个数，j代表第一个数（索引较前）最大就是倒数第二个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arrLength - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j]) &#123;</span><br><span class="line">[arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]] <span class="comment">//交换两个数值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>基本思路：</p><ul><li>每次执行循环找出最小值的索引值，并把这个最小放到前面，索引i前面的数组是依次排好的，时间复杂度为O(n2)。</li><li>与冒泡排序比较，冒泡排序是每次找出最大值放到最后而选择排序这是每次找出最小值放到前面。每次循环都会从乱序数组中找出最大（最小）值排到有序数组中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arrLength = arr.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLength; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> minIndex = i</span><br><span class="line"><span class="comment">//每次循环找出最小值索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = i;j&lt;arrLength;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;</span><br><span class="line">minIndex = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把最小值放到前面数组</span></span><br><span class="line">[arr[i],arr[minIndex]] = [arr[minIndex],arr[i]]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>基本思路：在已有排序的数组中找出自己位置，插入其中；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arrLength = arr.length</span><br><span class="line"><span class="keyword">let</span> preIndex,current</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;arrLength;i++)&#123;</span><br><span class="line">preIndex = i - <span class="number">1</span> </span><br><span class="line">current = arr[i]</span><br><span class="line"><span class="comment">//这个循环就是找出自己的位置，然后跳出，比较这个原始和current的大小，大则移后</span></span><br><span class="line"><span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current)&#123;</span><br><span class="line">arr[preIndex + <span class="number">1</span>] = arr[preIndex]</span><br><span class="line"><span class="number">45</span>,<span class="number">72</span>,<span class="number">72</span></span><br><span class="line">preIndex --;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>基本思路：该算法是采用分治法，将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> len = arr.length</span><br><span class="line"><span class="keyword">if</span>(len&lt;<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把长度为n的输入序列分成两个长度为n/2的子序列</span></span><br><span class="line"><span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> left = arr.slice(<span class="number">0</span>,mid)</span><br><span class="line"><span class="keyword">let</span> right = arr.slice(mid)</span><br><span class="line"><span class="comment">//对这两个子序列分别采用归并排序</span></span><br><span class="line"><span class="keyword">return</span> merge(mergeSort(left),mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个排序好的子序列合并成一个最终的排序序列。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">while</span>(left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>])&#123;</span><br><span class="line">result.push(left.shift())</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">result.push(right.shift())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(left.length)&#123;</span><br><span class="line">result.push(left.shift())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(right.length)&#123;</span><br><span class="line">result.push(right.shift())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思路：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,left,right</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> len = arr.length,</span><br><span class="line">partitionIndex,</span><br><span class="line">left = <span class="keyword">typeof</span> left != <span class="string">'number'</span> ? <span class="number">0</span> : left,</span><br><span class="line">right = <span class="keyword">typeof</span> right != <span class="string">'number'</span> ? len - <span class="number">1</span> : right;</span><br><span class="line"><span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">partitionIndex = partition(arr, left ,right)</span><br><span class="line">quickSort(arr, left, partitionIndex<span class="number">-1</span>)</span><br><span class="line">quickSort(arr, partitionIndex+<span class="number">1</span>, right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分区操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> pivot = left,</span><br><span class="line">index =pivot + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = index;i &lt;= right; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; arr[pivot])&#123;</span><br><span class="line">[arr[i],arr[index]] = [arr[index],arr[i]]</span><br><span class="line">index++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[arr[pivot],arr[index<span class="number">-1</span>]] = [arr[index<span class="number">-1</span>],arr[pivot]]</span><br><span class="line"><span class="keyword">return</span> index<span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Javascript-API实现排序&quot;&gt;&lt;a href=&quot;#Javascript-API实现排序&quot; class=&quot;headerlink&quot; title=&quot;Javascript API实现排序&quot;&gt;&lt;/a&gt;Javascript API实现排序&lt;/h3&gt;&lt;figure c
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序算法" scheme="http://lawsan.xyz/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue监听回车事件@keyup</title>
    <link href="http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/"/>
    <id>http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/</id>
    <published>2020-06-30T13:08:05.000Z</published>
    <updated>2020-07-03T10:49:37.730Z</updated>
    
    <content type="html"><![CDATA[<p>当我们要在一个输入框中监听回车事件时要绑定<code>keyup</code>事件；<br><code>keydown</code>当键盘被按下时会触发；<code>keyup</code>当键盘松开时触发；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"search_input"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="原生JavaScript实现"><a href="#原生JavaScript实现" class="headerlink" title="原生JavaScript实现;"></a>原生JavaScript实现;</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'search_input'</span>).onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> theEvent = <span class="built_in">window</span>.event || e;</span><br><span class="line"><span class="keyword">var</span> code = theEvent.keyCode || theEvent.which || theEvent.charCode;</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">13</span>) &#123;</span><br><span class="line"><span class="comment">//doSomeThing...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jQuery实现；"><a href="#jQuery实现；" class="headerlink" title="jQuery实现；"></a>jQuery实现；</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#search_input"</span>).keyup(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (e.keyCode == <span class="number">13</span>) &#123;</span><br><span class="line"><span class="comment">//doSomeThing...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue事件绑定实现"><a href="#Vue事件绑定实现" class="headerlink" title="Vue事件绑定实现"></a>Vue事件绑定实现</h2><p>全部键盘别名 <code>enter</code>,<code>tab</code>,<code>delete</code>,<code>esc</code>,<code>space</code>,<code>up</code>,<code>down</code>,<code>left</code>,<code>right</code>;<br>组合按键 <code>ctr</code>,<code>alt</code>,<code>shift</code>,<code>meta</code>(window系统下是win键，mac下是command键)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> @keyup.enter=<span class="string">"search"</span>  v-model=<span class="string">"search_input"</span>/&gt;</span><br><span class="line"><span class="comment">//methods</span></span><br><span class="line">search()&#123;</span><br><span class="line"><span class="comment">//doSomeThing...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是封装组件的话，例如element的<code>el-input</code>，要加上<code>native</code>;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-input v-model=<span class="string">"search_input"</span> @keyup.enter.native=<span class="string">"search"</span>&gt;&lt;<span class="regexp">/el-input&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们要在一个输入框中监听回车事件时要绑定&lt;code&gt;keyup&lt;/code&gt;事件；&lt;br&gt;&lt;code&gt;keydown&lt;/code&gt;当键盘被按下时会触发；&lt;code&gt;keyup&lt;/code&gt;当键盘松开时触发；&lt;/p&gt;
&lt;figure class=&quot;highlight htm
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
      <category term="Element" scheme="http://lawsan.xyz/tags/Element/"/>
    
  </entry>
  
</feed>
