<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lawson&#39;s Blog</title>
  
  <subtitle>认清现实，你只是看起来很努力。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lawsan.xyz/"/>
  <updated>2020-07-27T05:47:09.637Z</updated>
  <id>http://lawsan.xyz/</id>
  
  <author>
    <name>Lawson</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue全局配置</title>
    <link href="http://lawsan.xyz/2020/07/27/Vue%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/"/>
    <id>http://lawsan.xyz/2020/07/27/Vue%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-27T02:51:12.000Z</published>
    <updated>2020-07-27T05:47:09.637Z</updated>
    
    <content type="html"><![CDATA[<p><code>Vue.config</code> 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property：</p><h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h3><ul><li>类型：<code>boolean</code></li><li>默认值：<code>false</code></li><li>用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.silent = <span class="literal">true</span></span><br></pre></td></tr></table></figure>取消 Vue 所有的日志与警告。<h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h3></li><li>类型：<code>{ [key: string]: Function }</code></li><li>默认值：<code>{}</code></li><li>用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.optionMergeStrategies._my_option = <span class="function"><span class="keyword">function</span> (<span class="params">parent, child, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> child + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Profile = Vue.extend(&#123;</span><br><span class="line">  _my_option: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Profile.options._my_option = 2</span></span><br></pre></td></tr></table></figure>自定义合并策略的选项。<br>合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数，Vue 实例上下文被作为第三个参数传入。<h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3></li><li>类型：<code>boolean</code></li><li>默认值：<code>true (生产版为 false)</code></li><li>用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 务必在加载 Vue 之后，立即同步设置以下内容</span></span><br><span class="line">Vue.config.devtools = <span class="literal">true</span></span><br></pre></td></tr></table></figure>配置是否允许 <code>vue-devtools</code> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3></li><li>类型：<code>Function</code></li><li>默认值：<code>undefined</code></li><li>用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm, info</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">  <span class="comment">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span></span><br><span class="line">  <span class="comment">// 只在 2.2.0+ 可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。<blockquote><p>从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。<br>从 2.4.0 起，这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。<br>从 2.6.0 起，这个钩子也会捕获 v-on DOM 监听器内部抛出的错误。另外，如果任何被覆盖的钩子或处理函数返回一个 Promise 链 (例如 async 函数)，则来自其 Promise 链的错误也会被处理。</p></blockquote><h3 id="warnHandler"><a href="#warnHandler" class="headerlink" title="warnHandler"></a>warnHandler</h3></li><li>类型：<code>Function</code></li><li>默认值：<code>undefined</code></li><li>用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.warnHandler = <span class="function"><span class="keyword">function</span> (<span class="params">msg, vm, trace</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `trace` 是组件的继承关系追踪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>为 Vue 的运行时警告赋予一个自定义处理函数。<strong>注意这只会在开发者环境下生效，在生产环境下它会被忽略</strong>。<h3 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a>ignoredElements</h3></li><li>类型：<code>Array&lt;string | RegExp&gt;</code></li><li>默认值：[]</li><li>用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.ignoredElements = [</span><br><span class="line">  <span class="string">'my-custom-web-component'</span>,</span><br><span class="line">  <span class="string">'another-web-component'</span>,</span><br><span class="line">  <span class="comment">// 用一个 `RegExp` 忽略所有“ion-”开头的元素</span></span><br><span class="line">  <span class="comment">// 仅在 2.5+ 支持</span></span><br><span class="line">  /^ion-<span class="regexp">/</span></span><br><span class="line"><span class="regexp">]</span></span><br></pre></td></tr></table></figure>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g. 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。<h3 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h3></li><li>类型：<code>{ [key: string]: number | Array&lt;number&gt; }</code></li><li>默认值：<code>{}</code></li><li>用法：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.keyCodes = &#123;</span><br><span class="line">  v: <span class="number">86</span>,</span><br><span class="line">  f1: <span class="number">112</span>,</span><br><span class="line">  <span class="comment">// camelCase 不可用</span></span><br><span class="line">  mediaPlayPause: <span class="number">179</span>,</span><br><span class="line">  <span class="comment">// 取而代之的是 kebab-case 且用双引号括起来</span></span><br><span class="line">  <span class="string">"media-play-pause"</span>: <span class="number">179</span>,</span><br><span class="line">  up: [<span class="number">38</span>, <span class="number">87</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.media-play-pause</span>=<span class="string">"method"</span>&gt;</span></span><br></pre></td></tr></table></figure>给 v-on 自定义键位别名。<h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3></li><li>类型：<code>boolean</code></li><li>默认值：<code>false</code> (自 2.2.3 起)</li><li>用法：<br>设置为 <code>true</code> 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于<code>开发模式和支持 performance.mark API 的浏览器</code>上。</li></ul><h3 id="productionTip"><a href="#productionTip" class="headerlink" title="productionTip"></a>productionTip</h3><ul><li>类型：<code>boolean</code></li><li>默认值：<code>true</code></li><li>用法：<br>设置为 <code>false</code> 以阻止 vue 在启动时生成生产提示。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Vue.config&lt;/code&gt; 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property：&lt;/p&gt;
&lt;h3 id=&quot;silent&quot;&gt;&lt;a href=&quot;#silent&quot; class=&quot;headerlink&quot; title=&quot;silent
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>深入Vue响应式原理</title>
    <link href="http://lawsan.xyz/2020/07/25/%E6%B7%B1%E5%85%A5Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
    <id>http://lawsan.xyz/2020/07/25/%E6%B7%B1%E5%85%A5Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</id>
    <published>2020-07-25T08:55:08.000Z</published>
    <updated>2020-07-26T03:01:23.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何追踪变化？"><a href="#如何追踪变化？" class="headerlink" title="如何追踪变化？"></a>如何追踪变化？</h3><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 <code>Object.defineProperty</code> 把这些 property 全部转为 <code>getter/setter</code>。<br>数据代理的另一个说法是数据劫持，当我们在访问或者修改对象的某个属性时，数据劫持可以拦截这个行为并进行额外的操作或者修改返回的结果。我们知道Vue响应式系统的核心就是数据代理，代理使得数据在访问时进行依赖收集，在修改更新时对依赖进行更新，这是响应式系统的核心思路。</p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p><code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>基本用法：<code>Object.defineProperty(obj, prop, descriptor)</code><br><code>Object.defineProperty()</code>可以用来精确添加或修改对象的属性，只需要在descriptor对象中将属性特性描述清楚，descriptor的属性描述符有两种形式，一种是数据描述符，另一种是存取描述符，我们分别看看各自的特点。<br>数据描述符，它拥有四个属性配置</p><ul><li><code>configurable</code>：数据是否可删除，可配置</li><li><code>enumerable</code>：属性是否可枚举</li><li><code>value</code>：属性值,默认为undefined</li><li><code>writable</code>：属性是否可读写<br>存取描述符，它同样拥有四个属性选项</li><li><code>configurable</code>：数据是否可删除，可配置</li><li><code>enumerable</code>：属性是否可枚举</li><li><code>get</code>:一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。</li><li><code>set</code>:一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。</li><li><em>需要注意的是: 数据描述符的<code>value</code>，<code>writable</code> 和 存取描述符中的<code>get</code>, <code>set</code>属性不能同时存在，否则会抛出异常。*</em><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">defineReactive(data,key,data[key])</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,val</span>)</span>&#123;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data,key,&#123;</span><br><span class="line">enumerable:<span class="literal">true</span>,</span><br><span class="line">configurable:<span class="literal">false</span>,</span><br><span class="line"><span class="keyword">get</span>()&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'获取值'</span>)</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">set</span>(newVal)&#123;</span><br><span class="line"><span class="keyword">if</span>(val === newVal) <span class="keyword">return</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'监听到值变化了'</span>,val,<span class="string">'--&gt;'</span>,newVal)</span><br><span class="line">val = newVal</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'lisi'</span>&#125;</span><br><span class="line">observe(arr)</span><br><span class="line">observe(obj)</span><br><span class="line">obj.age = <span class="number">18</span> <span class="comment">//拦截不到</span></span><br><span class="line">obj.name <span class="comment">//获取值</span></span><br><span class="line">obj.name = <span class="string">'programmer'</span> <span class="comment">//监听到值变化了 lisi --&gt;programmer</span></span><br><span class="line">arr[<span class="number">1</span>] <span class="comment">//获取值</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">8</span> <span class="comment">//监听到值变化了 3 --&gt;8</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="number">5</span> <span class="comment">//拦截不到</span></span><br></pre></td></tr></table></figure>然而<code>Object.defineProperty</code>是有缺陷的，比如添加属性是监听不到对象的添加和删除或者数组的变化是无法拦截的。</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>为了解决像数组这类无法进行数据拦截，以及深层次的嵌套问题，es6引入了<code>Proxy</code>的概念，它是真正在语言层面对数据拦截的定义。和<code>Object.defineProperty</code>一样，<code>Proxy</code>可以修改某些操作的默认行为，但是不同的是，<code>Proxy</code><strong>针对目标对象会创建一个新的实例对象，并将目标对象代理到新的实例对象上</strong>，。 本质的区别是后者会创建一个新的对象对原对象做代理，外界对原对象的访问，都必须先通过这层代理进行拦截处理。而拦截的结果是我们只要通过操作新的实例对象就能间接的操作真正的目标对象了。针对Proxy，下面是基础的写法:<br>语法：<code>const p = new Proxy(target, handler)</code></p><ul><li><code>target</code>要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li><code>handler</code>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">b</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">var</span> nobj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'获取值'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value, receiver) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'设置值'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">nobj.a = <span class="string">'代理'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//设置值 &#123;b:18,a: "代理"&#125;</span></span><br></pre></td></tr></table></figure><code>Proxy</code>能监听数组的变化，<code>添加</code>，<code>删除</code>，<code>修改</code>等。</li></ul><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><h4 id="为什么要收集依赖？"><a href="#为什么要收集依赖？" class="headerlink" title="为什么要收集依赖？"></a>为什么要收集依赖？</h4><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该模板中使用了数据name，所以它发生变化时，要向使用了它的地方发送通知。总结一句话就是<strong>在getter中收集依赖，在setter中触发依赖</strong></p><h3 id="订阅者-Dep"><a href="#订阅者-Dep" class="headerlink" title="订阅者 Dep"></a>订阅者 Dep</h3><p>我们把依赖收集的代码封装成一个Dep类，它帮助我们管理依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="keyword">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>addSub</code> 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作；<br>用 <code>notify</code> 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。</p><h3 id="观察者-Watcher"><a href="#观察者-Watcher" class="headerlink" title="观察者 Watcher"></a>观察者 Watcher</h3><p>当属性发生变化后，我们要通知用到数据的地方，而使用这个数据的地方有很多，而且类型还不一样，既有可能是模板，也有可能是用户写的一个watch,这时需要抽象出一个能集中处理这些情况的类。然后，我们在依赖收集阶段只收集这个封装好的类的实例进来，通知也只通知它一个，再由它负责通知其他地方。<br>依赖收集的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">   <span class="comment">// 我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 Watcher 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 Watcher ,然后执行 update 函数。</p><h3 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">    observe(value)  <span class="comment">// 递归子属性</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep() <span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>, <span class="comment">//可枚举（可以遍历）</span></span><br><span class="line">      configurable: <span class="literal">true</span>, <span class="comment">//可配置（比如可以删除）</span></span><br><span class="line">      <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>, value) <span class="comment">// 监听</span></span><br><span class="line">     <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">       <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">         dp.addSub(Dep.target) <span class="comment">// 新增</span></span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">        observe(newVal) <span class="comment">//如果赋值是一个对象，也要递归子属性</span></span><br><span class="line">        <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'set'</span>, newVal) <span class="comment">// 监听</span></span><br><span class="line">          render()</span><br><span class="line">          value = newVal</span><br><span class="line">     <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">          dp.notify() <span class="comment">//通知更新</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data = options.data;</span><br><span class="line">        observer(<span class="keyword">this</span>._data);</span><br><span class="line">        <span class="comment">/* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */</span></span><br><span class="line">        <span class="keyword">new</span> Watcher();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'模拟视图渲染'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关流程如下图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/25/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在 new Vue() 后， Vue 会调用<code>_init</code> 函数进行初始化，也就是init 过程，在 这个过程Data通过<code>Observer</code>转换成了<code>getter/setter</code>的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行getter 函数，而在当被赋值的时候会执行 setter函数。<br>当render function 执行的时候，因为会读取所需对象的值，所以会触发getter函数从而将Watcher添加到依赖中进行依赖收集。<br>在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher就会开始调用 update 来更新视图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何追踪变化？&quot;&gt;&lt;a href=&quot;#如何追踪变化？&quot; class=&quot;headerlink&quot; title=&quot;如何追踪变化？&quot;&gt;&lt;/a&gt;如何追踪变化？&lt;/h3&gt;&lt;p&gt;当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>关于HTML5中新增的特性</title>
    <link href="http://lawsan.xyz/2020/07/23/%E5%85%B3%E4%BA%8EHTML5%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://lawsan.xyz/2020/07/23/%E5%85%B3%E4%BA%8EHTML5%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/</id>
    <published>2020-07-23T05:05:06.000Z</published>
    <updated>2020-07-23T10:58:54.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h3><p>HTML 语义化是指仅仅从 HTML 元素上就能看出页面的大致结构，比如需要强调的内容可以放在 <code>&lt;strong&gt;</code> 标签中，而不是通过样式设置 <code>&lt;span&gt;</code> 标签去做。不同浏览器对 HTML 元素的解析可能有差异，HTML 语义化便是在抛开样式之后，页面能有一个友好的展示效果。我们力求让页面有良好的结构，让页面的元素有含义，同时利于被搜索引擎解析，利于 SEO。HTML 语义化的建议：</p><ul><li>少使用无意义的 <code>&lt;div&gt;</code>、<code>&lt;span&gt;</code> 标签；</li><li>在 <code>&lt;label&gt;</code> 标签中设置 for 属性和对应的 <code>&lt;input&gt;</code> 关联起来；</li><li>设置 <code>&lt;img&gt;</code> 标签的 alt 属性，给 <code>&lt;a&gt;</code> 标签设置 title 属性，利于 SEO；</li><li>在页面的标题部分使用 <code>&lt;h1&gt;~&lt;h6&gt;</code> 标签，不需要给它们加多余的样式；</li><li>与表单、有序列表、无序列表相关的标签不要单独使用。<br>HTML5 也新增了一些语义化的元素，我们通过标签名就能判断标签内容。使用语义元素的页面大致结构如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/%E8%AF%AD%E4%B9%89%E5%8C%96.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>语义元素的名称其实也很好理解，下面是它们的作用和用法：</li><li><code>&lt;header&gt;</code> 标签通常放在页面或页面某个区域的顶部，用来设置页眉；</li><li><code>&lt;nav&gt;</code>标签可以用来定义导航链接的集合，点击链接可以跳转到其他页面；</li><li><code>&lt;article&gt;</code> 标签中的内容比较独立，可以是一篇新闻报道，一篇博客，它可以独立于页面的其他内容进行阅读；</li><li><code>&lt;section&gt;</code> 标签表示页面中的一个区域，通常对页面进行分块或对内容进行分段，<code>&lt;section&gt;</code> 标签和 <code>&lt;article&gt;</code> 标签可以互相嵌套；</li><li><code>&lt;aside&gt;</code> 标签用来表示除页面主要内容之外的内容，比如侧边栏；</li><li><code>&lt;footer&gt;</code> 标签位于页面或页面某个区域的底部，用来设置页脚，通常包含版权信息，联系方式等。<br>还有其他的新增标签：</li><li><code>&lt;details&gt;</code> 用于描述文档或文档某个部分的细节。</li><li><code>&lt;summary&gt;</code> 标签包含 details 元素的标题。</li><li><code>&lt;figure&gt;</code> 规定独立的流内容（图像、图表、照片、代码等等）。</li><li><code>&lt;figcaption&gt;</code> 定义 <code>&lt;figure&gt;</code> 元素的标题。</li><li><code>&lt;dialog&gt;</code> 定义对话框，比如提示框。</li><li><code>&lt;bdi&gt;</code> 允许您设置一段文本，使其脱离其父元素的文本方向设置。</li><li><code>&lt;command&gt;</code> 定义命令按钮，比如单选按钮、复选框或按钮。</li><li><code>&lt;mark&gt;</code>  定义带有记号的文本。</li><li><code>&lt;meter&gt;</code>     定义度量衡。仅用于已知最大和最小值的度量。</li><li><code>&lt;progress&gt;</code> 定义任何类型的任务的进度。</li><li><code>&lt;time&gt;</code> 定义日期或时间。</li><li><code>&lt;wbr&gt;</code> 规定在文本中的何处适合添加换行符。</li><li><code>&lt;rt&gt;</code> 定义字符（中文注音或字符）的解释或发音。<h3 id="HTML5-Input类型"><a href="#HTML5-Input类型" class="headerlink" title="HTML5 Input类型"></a>HTML5 Input类型</h3><code>color</code>,<code>date</code>,<code>datetime</code>,<code>datetime-local</code>,<code>email</code>,<code>month</code>,<code>number</code>,<code>range</code>,<code>search</code>,<code>tel</code>,<code>time</code>,<code>url</code>,<code>week</code><h3 id="HTML5-表单元素"><a href="#HTML5-表单元素" class="headerlink" title="HTML5 表单元素"></a>HTML5 表单元素</h3>HTML5 有以下新的表单元素:<code>&lt;datalist&gt;</code>,<code>&lt;keygen&gt;</code>,<code>&lt;output&gt;</code></li><li><em>HTML5 <code>&lt;datalist&gt;</code> 元素*</em><br><code>&lt;datalist&gt;</code> 元素规定输入域的选项列表。<br><code>&lt;datalist&gt;</code> 属性规定 form 或 input 域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项：<br>使用 <code>&lt;input&gt;</code> 元素的列表属性与 <code>&lt;datalist&gt;</code>元素绑定。<a href="https://www.runoob.com/try/try.php?filename=tryhtml5_datalist" target="_blank" rel="noopener">示例</a></li><li><em>HTML5<code>&lt;keygen&gt;</code>元素*</em><br><code>&lt;keygen&gt;</code> 元素的作用是提供一种验证用户的可靠方法。<br><code>&lt;keygen&gt;</code>标签规定用于表单的密钥对生成器字段。<br>当提交表单时，会生成两个键，一个是私钥，一个公钥。<br>私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。<a href="https://www.runoob.com/try/try.php?filename=tryhtml5_keygen" target="_blank" rel="noopener">示例</a></li><li><em>HTML5 <code>&lt;output&gt;</code> 元素*</em><br><code>&lt;output&gt;</code> 元素用于不同类型的输出，比如计算或脚本输出。<a href="https://www.runoob.com/try/try.php?filename=tryhtml5_output" target="_blank" rel="noopener">示例</a><h3 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h3></li></ul><ol><li>contextmenu<br>contextmenu 属性规定了元素的上下文菜单。当用户右击元素时将显示上下文菜单。contextmenu 属性的值是需要打开的 <code>&lt;menu&gt;</code> 元素的 id。<a href="https://www.runoob.com/try/try.php?filename=tryhtml5_global_contextmenu" target="_blank" rel="noopener">示例</a></li><li>DOMContentLoaded<br>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。<br>load 仅用于检测一个完全加载的页面，页面的html、css、js、图片等资源都已经加载完之后才会触发 load 事件。</li><li>readystatechange<br>可用来判断动态载入的 script、link 标签是否加载完成。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span> <span class="title">eventListener</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.readyState === <span class="string">'loaded'</span> || event.readyState === <span class="string">'complete'</span>) &#123; <span class="comment">// hack 的手段，浏览器自身的问题</span></span><br><span class="line">    script.removeEventListener(<span class="string">'readystatechange'</span>, eventListener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">script.src = <span class="string">'example.js'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure></li><li>hashchange<br>用来监听浏览器链接的hash值变化。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUUID</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">1000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'toggle'</span>)</span><br><span class="line">  el.onclick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> uuid = getUUID()</span><br><span class="line">    location.hash = <span class="string">'#'</span> + uuid</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.onhashchange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'oldURL:'</span>, e.oldURL)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'newURL:'</span>, e.newURL)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTML5-表单属性"><a href="#HTML5-表单属性" class="headerlink" title="HTML5 表单属性"></a>HTML5 表单属性</h3><code>&lt;form&gt;</code>新属性：<code>autocomplete</code>，<code>novalidate</code><br><code>&lt;input&gt;</code>新属性：<code>autocomplete</code>,<code>autofocus</code>,<code>form</code>,<code>formaction</code>,<code>formenctype</code>,<code>formmethod</code>,<code>formnovalidate</code>,<code>formtarget</code>,<br><code>height 与 width</code>,<code>list</code>,<code>min 与 max</code>,<code>multiple</code>,<code>pattern (regexp)</code>,<code>placeholder</code>,<code>required</code>,<code>step</code><h3 id="HTML5-存储"><a href="#HTML5-存储" class="headerlink" title="HTML5 存储"></a>HTML5 存储</h3></li><li>sessionStorage: 大小上限为 2.5Mb(不同浏览器会有差异), 页面关闭时便清空;</li><li>localStorage: 大小上限为 2.5Mb(不同浏览器会有差异), 页面关闭时不会清空;<br>它们的 api 也是一致的, 有如下几个:</li></ol><ul><li>setItem(key, value)</li><li>getItem(key)</li><li>removeItem(key)</li><li>clear()<blockquote><p>在 HTML5 范围之外与存储相关的技术还有 cookie(存放在客户端，可以由客户端也可以由服务端生成, 大小上限为 4 kb)、IndexedDB(大小上限为 5 Mb)、cacheStorage(ServiceWorker)。</p></blockquote><h3 id="HTML5-JavaScript-API"><a href="#HTML5-JavaScript-API" class="headerlink" title="HTML5 JavaScript API"></a>HTML5 JavaScript API</h3></li></ul><ol><li><code>requestAnimationFrame(callback)</code>: 表示在重绘前执行指定的回调函数，下面通过一个简单的 demo 来认识它。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> frame</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(timeStamp) <span class="comment">// 开始执行回调的时间戳</span></span><br><span class="line">  <span class="comment">// 如果想要产生循环动画的效果, 需在回调函数中再次调用 requestAnimationFrame()</span></span><br><span class="line">  requestAnimationFrame(callback)</span><br><span class="line">&#125;</span><br><span class="line">frame = requestAnimationFrame(callback) <span class="comment">// 在下次重绘之前调用回调</span></span><br><span class="line"><span class="comment">// 可以在销毁期的生命周期函数中执行以下函数</span></span><br><span class="line">componentWillUnMount() &#123;</span><br><span class="line">  cancelAnimationFrame(frame)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>一帧的时间大致为 16ms。</li><li>Web Worker<br>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</li></ol><p><strong>检测浏览器是否支持Web Worker</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!==<span class="string">"undefined"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 是的! Web worker 支持!</span></span><br><span class="line">    <span class="comment">// 一些代码.....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//抱歉! Web Worker 不支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建 Web Worker 对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(w)==<span class="string">"undefined"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    w=<span class="keyword">new</span> Worker(<span class="string">"demo_workers.js"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>终止 Web Worker</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.terminate();</span><br></pre></td></tr></table></figure><p><code>Worker.onmessage</code>  当MessageEvent类型的事件冒泡到 worker 时，事件监听函数 EventListener 被调用.<br><code>Worker.onmessageerror</code> 当messageerror 类型的事件发生时，对应的EventHandler 代码被调用。<br><code>Worker.postMessage()</code> 发送一条消息到最近的外层对象，消息可由任何 JavaScript 对象组成。<br><code>Worker.terminate()</code> 立即终止 worker。该方法不会给 worker 留下任何完成操作的机会；就是简单的立即停止。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>计数： <span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"startWorker()"</span>&gt;</span>开始工作<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stopWorker()"</span>&gt;</span>停止工作<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是demo_workers.js里面的内容</span></span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedCount</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    postMessage(i); <span class="comment">//用于向 HTML 页面传回一段消息</span></span><br><span class="line">    setTimeout(<span class="string">"timedCount()"</span>,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">timedCount();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> w;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startWorker</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker) !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(w) == <span class="string">"undefined"</span>) &#123;</span><br><span class="line">w = <span class="keyword">new</span> Worker(<span class="string">"demo_workers.js"</span>);</span><br><span class="line">&#125;</span><br><span class="line">w.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">//接收postMessage的数据</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML = event.data;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML = <span class="string">"抱歉，你的浏览器不支持 Web Workers..."</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">w.terminate();</span><br><span class="line">w = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTML语义化&quot;&gt;&lt;a href=&quot;#HTML语义化&quot; class=&quot;headerlink&quot; title=&quot;HTML语义化&quot;&gt;&lt;/a&gt;HTML语义化&lt;/h3&gt;&lt;p&gt;HTML 语义化是指仅仅从 HTML 元素上就能看出页面的大致结构，比如需要强调的内容可以放在 &lt;c
      
    
    </summary>
    
    
    
      <category term="HTML5" scheme="http://lawsan.xyz/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>CSS盒模型与BFC</title>
    <link href="http://lawsan.xyz/2020/07/23/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8EBFC/"/>
    <id>http://lawsan.xyz/2020/07/23/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%8EBFC/</id>
    <published>2020-07-23T02:33:57.000Z</published>
    <updated>2020-07-23T04:52:06.237Z</updated>
    
    <content type="html"><![CDATA[<p>所有HTML元素可以看作盒子，在CSS中，<code>box model</code>这一术语是用来设计和布局时使用。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：<code>边距</code>，<code>边框</code>，<code>填充</code>，和<code>实际内容</code>。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br>下面的图片说明了盒子模型(Box Model)：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/box-model.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不同部分的说明：</p><ul><li>Margin(外边距) - 清除边框外的区域，外边距是透明的。</li><li>Border(边框) - 围绕在内边距和内容外的边框。</li><li>Padding(内边距) - 清除内容周围的区域，内边距是透明的。</li><li>Content(内容) - 盒子的内容，显示文本和图像。</li><li>注意：我们用盒子的宽高来衡量盒子的大小，可以看做总元素的宽度和高度，和元素本身设置的宽度和高度（width，height）不是同一个概念。<h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3></li><li>元素的 width、height 只包含内容 content，不包含 border 和 padding 值；</li><li>盒子的大小由元素的宽高、边框和内边距决定。</li><li>盒子的宽/高 = width/height + border + padding + margin<br>模型如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/W3C-box.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h3></li><li>元素的 width、height 不仅包括 content，还包括 border 和 padding；</li><li>盒子的大小取决于 width、height，修改 border 和 padding 值不能改变盒子的大小</li><li>盒子宽/高=width/height + margin = 内容区宽度/高度 + padding + border + margin<br>盒型如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/IE-box.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h3 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h3><ul><li>标准盒模型和IE盒模型就在内容content的区别，标准盒模型的content只包括width/height，而IE盒模型的content包括width/height+border+padding。</li><li>标准盒模型下元素的 <code>box-sizing</code> 属性（IE8+）默认值为 <code>content-box</code>，将它设置成 <code>border-box</code> 可转换为 IE 盒模型。在实际应用场景中，若想控制元素总宽高保持固定，这个设置很有用。</li><li>元素的宽（width）、高（height）、边框（border）、内边距（padding）、外边距（margin）都是盒子模型的重要组成部分，但是盒子模型的大小只与元素的宽高、边框、内间距有关，外边距只影响盒子所占外围空间的大小。<h3 id="边距重叠解决方案-BFC"><a href="#边距重叠解决方案-BFC" class="headerlink" title="边距重叠解决方案(BFC)"></a>边距重叠解决方案(BFC)</h3>首先要明确BFC是什么意思，其全英文拼写为 <code>Block Formatting Context</code> 直译为<code>块级格式化上下文</code>。它是一个独立的渲染区域，只有<code>Block-level box</code>参与， 它规定了内部的<code>Block-level Box</code>如何布局，并且与这个区域外部毫不相干。</li><li><code>Block-level box</code>:display 属性为 block, list-item, table 的元素。</li><li><code>inline-level box</code>:display 属性为  inline, inline-block, inline-table的元素。<h4 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h4></li><li>内部的box会在垂直方向，一个接一个的放置</li><li>每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反）</li><li>box垂直方向的距离由margin决定，属于同一个BFC的两个相邻box的margin会发生重叠</li><li>BFC的区域不会与浮动区域的box重叠</li><li>BFC是一个页面上的独立的容器，外面的元素不会影响BFC里的元素，反过来，里面的也不会影响外面的</li><li>计算BFC高度的时候，浮动元素也会参与计算<h4 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h4></li><li>float属性不为none（脱离文档流）</li><li>position为absolute或fixed</li><li>display为inline-block,table-cell,table-caption,flex,inline-flex</li><li>overflow不为visible</li><li>根元素, 即HTML元素<h4 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h4></li></ul><ol><li>利用BFC避免margin重叠</li><li>自适应两栏布局</li><li>清除内部浮动<br>例子如下：<h5 id="避免margin重叠"><a href="#避免margin重叠" class="headerlink" title="避免margin重叠"></a>避免margin重叠</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pOne</span>&#123;</span></span><br><span class="line">margin: 10px 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.pTwo</span>&#123;</span></span><br><span class="line">margin: 30px 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"pOne"</span>&gt;</span>文本1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"pTwo"</span>&gt;</span>文本2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>在上面的例子中，margin会重叠，会以最大的margin为准。也就是两个p元素的外边距为30px。<br>当我们利用BFC时<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.pOne</span>&#123;</span></span><br><span class="line">margin: 10px 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.pTwo</span>&#123;</span></span><br><span class="line">margin: 30px 0;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"pOne"</span>&gt;</span>文本1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"pTwo"</span>&gt;</span>文本2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>利用BFC消除了margin重叠问题，这样的话两个p元素的外边距为30+10=40px。<h5 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h5>根据BFC的布局规则：每个元素的margin box的左边，与包含块border box的左边相接触（对于从做往右的格式化，否则相反）。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.left</span>&#123;</span></span><br><span class="line">height: 300px;</span><br><span class="line">width: 200px;</span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#00FFFF</span>;</span></span><br><span class="line">float: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.right</span>&#123;</span></span><br><span class="line">height: 500px;</span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#F5F5DC</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>LEFT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>RIGHT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>效果如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/BFC-1.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>根据BFC的布局规则：BFC的区域不会与浮动区域的box重叠。所以我们要创建一个BFC，避免left和right重叠。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.left</span>&#123;</span></span><br><span class="line">height: 300px;</span><br><span class="line">width: 200px;</span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#00FFFF</span>;</span></span><br><span class="line">float: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.right</span>&#123;</span></span><br><span class="line">height: 500px;</span><br><span class="line"><span class="css"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>; <span class="comment">/*right变为BFC*/</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">background-color</span>: <span class="selector-id">#F5F5DC</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>LEFT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>RIGHT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/BFC-2.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="清除内部浮动"><a href="#清除内部浮动" class="headerlink" title="清除内部浮动"></a>清除内部浮动</h5>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清除浮动。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span>&#123;</span></span><br><span class="line">width: 300px;</span><br><span class="line">border: 5px solid darkgoldenrod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.child</span>&#123;</span></span><br><span class="line">height: 100px;</span><br><span class="line">width: 100px;</span><br><span class="line">float: left;</span><br><span class="line"><span class="css"><span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#00FFFF</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>效果如下，父节点高度塌陷：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/BFC-3.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>根据BFC布局规则：计算BFC高度的时候，浮动元素也会参与计算。因此我们把父节点设置为BFC就可以解决高度塌陷。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span>&#123;</span></span><br><span class="line">width: 300px;</span><br><span class="line">border: 5px solid darkgoldenrod;</span><br><span class="line"><span class="css"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>; <span class="comment">/*BFC*/</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.child</span>&#123;</span></span><br><span class="line">height: 100px;</span><br><span class="line">width: 100px;</span><br><span class="line">float: left;</span><br><span class="line"><span class="css"><span class="selector-tag">border</span>: 5<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#00FFFF</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/23/BFC-4.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><h3 id="关于解决父节点高度塌陷问题"><a href="#关于解决父节点高度塌陷问题" class="headerlink" title="关于解决父节点高度塌陷问题"></a>关于解决父节点高度塌陷问题</h3><h4 id="给父元素末尾添加一个空元素，并设置成清除浮动"><a href="#给父元素末尾添加一个空元素，并设置成清除浮动" class="headerlink" title="给父元素末尾添加一个空元素，并设置成清除浮动"></a>给父元素末尾添加一个空元素，并设置成清除浮动</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>缺点：添加了无意义标签，不易于后期维护，违背了结构和表现分离的标准</p><h4 id="给父元素添加-overflow：auto"><a href="#给父元素添加-overflow：auto" class="headerlink" title="给父元素添加 overflow：auto;"></a>给父元素添加 overflow：auto;</h4><h4 id="让父元素也浮动"><a href="#让父元素也浮动" class="headerlink" title="让父元素也浮动"></a>让父元素也浮动</h4><p>缺点：影响整体页面布局，若父元素也有父元素呢？总不能一直浮动到body吧？</p><h4 id="使用after伪元素"><a href="#使用after伪元素" class="headerlink" title="使用after伪元素"></a>使用after伪元素</h4><p>给父元素添加一个类，来添加一个看不见的块元素，以实现清除浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">visibility</span>: hidden;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>也就是BFC的布局规则：计算BFC高度的时候，浮动元素也会参与计算。上面的方法也用到了这条规则。下面这个方法是一个不错的方法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line"><span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有HTML元素可以看作盒子，在CSS中，&lt;code&gt;box model&lt;/code&gt;这一术语是用来设计和布局时使用。&lt;br&gt;CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：&lt;code&gt;边距&lt;/code&gt;，&lt;code&gt;边框&lt;/code&gt;，&lt;code&gt;填充&lt;/c
      
    
    </summary>
    
    
    
      <category term="CSS" scheme="http://lawsan.xyz/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>一文带你深入了解Promise</title>
    <link href="http://lawsan.xyz/2020/07/20/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Promise/"/>
    <id>http://lawsan.xyz/2020/07/20/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Promise/</id>
    <published>2020-07-20T07:03:28.000Z</published>
    <updated>2020-07-22T01:51:34.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Promise？"><a href="#什么是Promise？" class="headerlink" title="什么是Promise？"></a>什么是Promise？</h3><p><code>Promise</code>是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一。<br>从语法上来说:Promise是一个构造函数。<br>从功能上来说：promise对象是用来封装一个异步操作并可以获取其结果。</p><h3 id="Promises-A-规范"><a href="#Promises-A-规范" class="headerlink" title="Promises/A+ 规范"></a>Promises/A+ 规范</h3><p>为实现者提供一个健全的、可互操作的 JavaScript <code>promise</code> 的开放标准。</p><h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><ul><li><code>解决 (fulfill)</code> : 指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 <code>resolve</code> 来指代之。</li><li><code>拒绝（reject)</code>: 指一个 promise 失败时进行的一系列操作。</li><li><code>拒因 (reason)</code> : 也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</li><li><code>终值（eventual value）</code> : 所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li><li><code>Promise</code> : promise 是一个拥有 then 方法的对象或函数，其行为符合本规范。</li><li><code>thenable</code> : 是一个定义了 then 方法的对象或函数。</li><li><code>异常（exception）</code> : 是使用 throw 语句抛出的一个值。</li></ul><h3 id="Promise使用"><a href="#Promise使用" class="headerlink" title="Promise使用"></a>Promise使用</h3><h4 id="Promise状态"><a href="#Promise状态" class="headerlink" title="Promise状态"></a>Promise状态</h4><p>一个Promise的当前状态必须是以下三种状态中的一种: <strong>等待状态（Pending）</strong>、** 执行状态（Fulfilled）** 和 <strong>拒绝状态（Rejected）</strong>。<br>一旦状态改变就不能再次改变。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; <span class="comment">/* executor */</span>  );</span><br></pre></td></tr></table></figure><p>Promise接收一个参数<code>executor</code>，executor是带有 <code>resolve</code> 和 <code>reject</code> 两个参数的函数 。Promise构造函数执行时<code>立即调用</code>executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。<br>相关流程如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/20/promises.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 异步处理</span></span><br><span class="line">       <span class="comment">// 处理结束后、调用resolve 或 reject</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h4><p>一个 promise 必须提供一个 then 方法以访问其当前值、终值和据因，<strong>只有状态改变为<code>Fulfilled</code>或者<code>Rejected</code>时才会调用<code>then</code>方法，如果状态为<code>Pending</code>则不调用</strong>。<br>promise 的 then 方法接受两个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>onFulfilled 和 onRejected 都是可选参数;如果 onFulfilled 不是函数，其必须被忽略;如果 onRejected 不是函数，其必须被忽略。<br>then 方法可以被同一个 promise 调用多次，then方法必须返回一个promise对象。</p><h4 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h4><p><code>Promise.race(iterable)</code> 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><h4 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h4><p><code>Promise.all(iterable)</code> 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p><h4 id="reject方法"><a href="#reject方法" class="headerlink" title="reject方法"></a>reject方法</h4><p><code>Promise.reject()</code>方法返回一个带有拒绝原因的Promise对象。</p><h4 id="resolve方法"><a href="#resolve方法" class="headerlink" title="resolve方法"></a>resolve方法</h4><p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise 对象。如果这个值是一个 promise ，那么将返回这个 promise ；如果这个值是thenable（即带有”then” 方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态；否则返回的promise将以此值完成。此函数将类promise对象的多层嵌套展平。</p><h3 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>  <span class="comment">//初始状态</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span> <span class="comment">//成功状态</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span> <span class="comment">//失败状态</span></span><br><span class="line"><span class="comment">//Promise构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">excutor</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line"><span class="comment">//初始化状态</span></span><br><span class="line">self.status = PENDING</span><br><span class="line">self.data = <span class="literal">undefined</span></span><br><span class="line">self.callbacks = [] <span class="comment">//每个元素的结构: &#123;onResolved(value)&#123;&#125;, onRejected(reason)&#123;&#125; &#125;</span></span><br><span class="line"><span class="comment">//resolve方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(self.status !== PENDING)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改变状态，保存数据</span></span><br><span class="line">self.status = RESOLVED</span><br><span class="line">self.data = value</span><br><span class="line"><span class="comment">//如果有待执行回调函数，立即异步执行异步回调函数</span></span><br><span class="line"><span class="keyword">if</span>(self.callbacks.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">self.callbacks.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">item.onResolved(value)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reject方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(self.status !== PENDING)&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改变状态，保存数据</span></span><br><span class="line">self.status = REJECTED</span><br><span class="line">self.data = reason</span><br><span class="line"><span class="comment">//如果有待执行回调函数，立即异步执行异步回调函数</span></span><br><span class="line"><span class="keyword">if</span>(self.callbacks.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">self.callbacks.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">item.onRejected(reason)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//立即执行excutor函数</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">excutor(resolve,reject)</span><br><span class="line">&#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">reject(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise对象的then方法</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved,onRejected</span>)</span>&#123;</span><br><span class="line">onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ?onResolved : <span class="function"><span class="params">value</span> =&gt;</span> value,  <span class="comment">//不写默认undefined</span></span><br><span class="line"><span class="comment">//指定默认是失败回调</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ?</span><br><span class="line">  onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> reason</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line"><span class="comment">//返回一个新的promise对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//回调函数返回的结果</span></span><br><span class="line"><span class="keyword">const</span> result = callback(self.data)</span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> MyPromise)&#123;</span><br><span class="line"><span class="comment">//返回的数据是Promise</span></span><br><span class="line">result.then(resolve,reject)<span class="comment">//返回新的promise对象</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">reject(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(self.status === PENDING)&#123;</span><br><span class="line">self.callbacks.push(&#123;</span><br><span class="line">onResolved(value)&#123;</span><br><span class="line">handle(value)</span><br><span class="line">&#125;,</span><br><span class="line">onRejected(reason)&#123;</span><br><span class="line">handle(reason)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(self.status === RESOLVED)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">handle(onResolved)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">handle(onRejected)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise对象的catch方法</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise的resolve方法</span></span><br><span class="line">MyPromise.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(result <span class="keyword">instanceof</span> MyPromise)&#123;</span><br><span class="line"><span class="comment">//返回的数据是Promise</span></span><br><span class="line">result.then(resolve,reject)<span class="comment">//返回新的promise对象</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">resolve(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise的reject方法</span></span><br><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">reject(reason)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise的all方法</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(promises.length) <span class="comment">//保存成功的数据数据</span></span><br><span class="line"><span class="keyword">let</span> resolvedCount = <span class="number">0</span> <span class="comment">//成功的数量</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//遍历执行promises</span></span><br><span class="line">promises.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">MyPromise.resolve(item).then(</span><br><span class="line">value=&gt;&#123;</span><br><span class="line">reslovedCount++</span><br><span class="line">values[index] = value</span><br><span class="line"><span class="keyword">if</span>(reslovedCount === promises.length)&#123;</span><br><span class="line">resolve(values)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">reason=&gt;&#123;</span><br><span class="line">reject(reason)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise的race方法</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">promises.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">MyPromise.resolve(item).then(</span><br><span class="line">value=&gt;&#123;</span><br><span class="line">resolve(value)</span><br><span class="line">&#125;,</span><br><span class="line">reason=&gt;&#123;</span><br><span class="line">reject(reason)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.MyPromise = MyPromise</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Promise？&quot;&gt;&lt;a href=&quot;#什么是Promise？&quot; class=&quot;headerlink&quot; title=&quot;什么是Promise？&quot;&gt;&lt;/a&gt;什么是Promise？&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是JS异步编程中的重要概念，
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://lawsan.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一文带你了解JavaScript深拷贝</title>
    <link href="http://lawsan.xyz/2020/07/20/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://lawsan.xyz/2020/07/20/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-07-20T04:29:42.000Z</published>
    <updated>2020-07-20T06:33:40.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="拷贝是啥？"><a href="#拷贝是啥？" class="headerlink" title="拷贝是啥？"></a>拷贝是啥？</h3><p>顾名思义也就是复制，我们知道在JavaScript中基本数据类型都是保存在栈中的，而复杂数据类型（object）是保存在堆中的，在栈中不过是保存了堆的地址（引用）。</p><h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p>浅深拷贝都是对引用类型的数据而言的，基本数据类型一赋值就开辟了独立的栈空间，互不影响。</p><ul><li>浅拷贝：当我们对基本数据类型复制，会把值全部复制过去的。如果是引用类型，也是把值复制过去，不过这个值是地址引用。这样如果其中一个对象改变了这个地址，就会影响到另一个对象。</li><li>深拷贝：是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b = <span class="number">2</span>  <span class="comment">//b的值为2，a的值为1互不影响</span></span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">2</span>  <span class="comment">//b的值为[2,2,3]，a的值为[2,2,3]引用了同一个对象</span></span><br></pre></td></tr></table></figure><h3 id="赋值-amp-amp-浅拷贝-amp-amp-深拷贝的区别"><a href="#赋值-amp-amp-浅拷贝-amp-amp-深拷贝的区别" class="headerlink" title="赋值&amp;&amp;浅拷贝&amp;&amp;深拷贝的区别"></a>赋值&amp;&amp;浅拷贝&amp;&amp;深拷贝的区别</h3>赋值：只是在栈中新建一个变量，指向同一个堆内存,也就是把地址复制过来。<br>浅拷贝：会新建个一对象，如果属性是基本类型，则拷贝基本数据类型的值，如果是引用数据类型，则拷贝内存地址。因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。<br>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。<br>来看看下面的例子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">name:<span class="string">'lisi'</span>,</span><br><span class="line">hobby:[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">b.name = <span class="string">'zhangsan'</span></span><br><span class="line">b.hobby = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>]</span><br><span class="line"><span class="comment">//a和b的值都为&#123;name:'zhansan',hobby:[3,4,10]&#125;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">name:<span class="string">'lisi'</span>,</span><br><span class="line">hobby:[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = shallowClone(a)</span><br><span class="line">b.name = <span class="string">'zhangsan'</span></span><br><span class="line">b.hobby[<span class="number">1</span>] = <span class="number">10</span> <span class="comment">// 新旧对象还是共享同一块内存</span></span><br><span class="line"><span class="comment">//a的值为&#123;name:'lisi',hobby:[1,10,[3,4],5,6]&#125;</span></span><br><span class="line"><span class="comment">//b的值为&#123;name:'zhangsan',hobby:[1,10,[3,4],5,6]&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line"><span class="keyword">if</span> (source.hasOwnProperty(i)) &#123;</span><br><span class="line">target[i] = source[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">name:<span class="string">'lisi'</span>,</span><br><span class="line">hobby:[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a)) <span class="comment">//比较简单地实现深拷贝</span></span><br><span class="line">b.name = <span class="string">'zhangsan'</span></span><br><span class="line">b.hobby[<span class="number">1</span>] = <span class="number">10</span> <span class="comment">// 新旧对象不是同一块内存</span></span><br><span class="line"><span class="comment">//a的值为&#123;name:'lisi',hobby:[1,2,[3,4],5,6]&#125;</span></span><br><span class="line"><span class="comment">//b的值为&#123;name:'zhangsan',hobby:[1,10,[3,4],5,6]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h3><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><p><code>Object.assign()</code>方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 <code>Object.assign()</code>进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">person</span>:&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="attr">money</span>:<span class="number">666</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;,obj1)</span><br><span class="line">obj2.person.age = <span class="number">20</span></span><br><span class="line">obj2.money = <span class="number">777</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">//&#123;person:&#123;name:'lisi',age:20&#125;,money:666&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">//&#123;person:&#123;name:'lisi',age:20&#125;,money:777&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：当object只有一层的时候，是深拷贝</p></blockquote><h4 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.concat()</span><br><span class="line">arr2[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zhangsan'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1)<span class="comment">//[1,2,&#123;name:'zhangsan',age:18&#125;,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">//[1,10,&#123;name:'zhangsan',age:18&#125;,3,4]</span></span><br></pre></td></tr></table></figure><h4 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.slice()</span><br><span class="line">arr2[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">arr2[<span class="number">2</span>].name = <span class="string">'zhangsan'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1)<span class="comment">//[1,2,&#123;name:'zhangsan',age:18&#125;,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">//[1,10,&#123;name:'zhangsan',age:18&#125;,3,4]</span></span><br></pre></td></tr></table></figure><h4 id="展开运算符…"><a href="#展开运算符…" class="headerlink" title="展开运算符…"></a>展开运算符…</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">person</span>:&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="attr">money</span>:<span class="number">666</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;</span><br><span class="line">obj2.person.age = <span class="number">20</span></span><br><span class="line">obj2.money = <span class="number">777</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">//&#123;person:&#123;name:'lisi',age:20&#125;,money:666&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">//&#123;person:&#123;name:'lisi',age:20&#125;,money:777&#125;</span></span><br></pre></td></tr></table></figure><h4 id="函数库lodash的-clone方法"><a href="#函数库lodash的-clone方法" class="headerlink" title="函数库lodash的_.clone方法"></a>函数库lodash的_.clone方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">person</span>:&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="attr">money</span>:<span class="number">666</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = _.clone(obj1)</span><br><span class="line">obj2.person.age = <span class="number">20</span></span><br><span class="line">obj2.money = <span class="number">777</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1) <span class="comment">//&#123;person:&#123;name:'lisi',age:20&#125;,money:666&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2) <span class="comment">//&#123;person:&#123;name:'lisi',age:20&#125;,money:777&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h3><h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">name:<span class="string">'lisi'</span>,</span><br><span class="line">hobby:[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a)) <span class="comment">//比较简单地实现深拷贝</span></span><br><span class="line">b.name = <span class="string">'zhangsan'</span></span><br><span class="line">b.hobby[<span class="number">1</span>] = <span class="number">10</span> <span class="comment">// 新旧对象不是同一块内存</span></span><br><span class="line"><span class="comment">//a的值为&#123;name:'lisi',hobby:[1,2,[3,4],5,6]&#125;</span></span><br><span class="line"><span class="comment">//b的值为&#123;name:'zhangsan',hobby:[1,10,[3,4],5,6]&#125;</span></span><br></pre></td></tr></table></figure><p>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则，因为这两者基于<code>JSON.stringify</code>和<code>JSON.parse</code>处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为<code>null</code>）了。</p><h4 id="jQuery-extend-方法"><a href="#jQuery-extend-方法" class="headerlink" title="jQuery.extend()方法"></a>jQuery.extend()方法</h4><p>jquery 有提供一個$.extend可以用来做 Deep Copy;<code>$.extend(deepCopy, target, object1, [objectN])//第一个参数为true,就是深拷贝</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">person</span>:&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="attr">money</span>:<span class="number">666</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = $.extend(<span class="literal">true</span>,&#123;&#125;,obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.person === obj2.person) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="函数库lodash的-cloneDeep方法"><a href="#函数库lodash的-cloneDeep方法" class="headerlink" title="函数库lodash的_.cloneDeep方法"></a>函数库lodash的_.cloneDeep方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">person</span>:&#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,<span class="attr">money</span>:<span class="number">666</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = _.cloneDeep(obj1)</span><br><span class="line"><span class="built_in">console</span>.log(obj1.person === obj2.person) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj === <span class="literal">null</span>) <span class="keyword">return</span> obj <span class="comment">//如果是null返回空</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span> obj <span class="comment">//如果是基本数据类型或者函数，直接返回</span></span><br><span class="line"><span class="comment">//返回新的日期或者正则对象</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line"><span class="comment">//新建一个对象，如果是数组就是new Array() 否则是 new Object()</span></span><br><span class="line"><span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line"><span class="keyword">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class="line">cloneObj[key] = deepClone(obj[key]); <span class="comment">//递归调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;拷贝是啥？&quot;&gt;&lt;a href=&quot;#拷贝是啥？&quot; class=&quot;headerlink&quot; title=&quot;拷贝是啥？&quot;&gt;&lt;/a&gt;拷贝是啥？&lt;/h3&gt;&lt;p&gt;顾名思义也就是复制，我们知道在JavaScript中基本数据类型都是保存在栈中的，而复杂数据类型（object）是保
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://lawsan.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发指南之可复用性与组合</title>
    <link href="http://lawsan.xyz/2020/07/19/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E4%B8%8E%E7%BB%84%E5%90%88/"/>
    <id>http://lawsan.xyz/2020/07/19/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E4%B8%8E%E7%BB%84%E5%90%88/</id>
    <published>2020-07-19T04:43:24.000Z</published>
    <updated>2020-07-19T06:15:46.047Z</updated>
    
    <content type="html"><![CDATA[<h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>混入 (<code>mixin</code>) 提供了一种非常灵活的方式，来<code>分发 Vue 组件中的可复用功能</code>。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。<br>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以<strong>组件数据优先</strong>。<br>同名钩子函数将合并为一个数组，因此<strong>都将被调用</strong>。另外，<strong>混入对象的钩子将在组件自身钩子之前调用</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixin = &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span>,</span><br><span class="line">      foo: <span class="string">'abc'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'混入对象的钩子被调用'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  mixins: [mixin],</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'goodbye'</span>,</span><br><span class="line">      bar: <span class="string">'def'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$data)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'组件钩子被调用'</span>)</span><br><span class="line"><span class="comment">//混入对象的钩子被调用</span></span><br><span class="line">    <span class="comment">// =&gt; &#123; message: "goodbye", foo: "abc", bar: "def" &#125;</span></span><br><span class="line"><span class="comment">//组件钩子被调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。<code>两个对象键名冲突时，取组件对象的键值对</code>。</p><h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><p>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为自定义的选项 'myOption' 注入一个处理器。</span></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myOption = <span class="keyword">this</span>.$options.myOption</span><br><span class="line">    <span class="keyword">if</span> (myOption) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(myOption)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  myOption: <span class="string">'hello!'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "hello!"</span></span><br></pre></td></tr></table></figure><blockquote><p>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。</p></blockquote><h4 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h4><p>自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 <code>Vue.config.optionMergeStrategies</code> 添加一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = Vue.config.optionMergeStrategies.computed</span><br><span class="line">Vue.config.optionMergeStrategies.vuex = <span class="function"><span class="keyword">function</span> (<span class="params">toVal, fromVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!toVal) <span class="keyword">return</span> fromVal</span><br><span class="line">  <span class="keyword">if</span> (!fromVal) <span class="keyword">return</span> toVal</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getters: merge(toVal.getters, fromVal.getters),</span><br><span class="line">    state: merge(toVal.state, fromVal.state),</span><br><span class="line">    actions: merge(toVal.actions, fromVal.actions)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h3><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">data()&#123;</span><br><span class="line"><span class="keyword">return</span>&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line"><span class="comment">// 指令的定义</span></span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  el.focus()</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。</li><li><code>componentUpdated</code>：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。<h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4>指令钩子函数会被传入以下参数：</li><li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li><li><code>binding</code>：一个对象，包含以下 property：<br>  <code>name</code>：指令名，不包括 <code>v-</code>前缀。<br>  <code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 2。<br>  <code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。<br>  <code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。<br>  <code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。<br>  <code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li><li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。</li><li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。<blockquote><p>除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <code>dataset</code> 来进行。<br>这是一个使用了这些 property 的自定义钩子样例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hook-arguments-example"</span> <span class="attr">v-demo:foo.a.b</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'demo'</span>, &#123;</span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify</span><br><span class="line">    el.innerHTML =</span><br><span class="line">      <span class="string">'name: '</span>       + s(binding.name) + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">      <span class="string">'value: '</span>      + s(binding.value) + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">      <span class="string">'expression: '</span> + s(binding.expression) + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">      <span class="string">'argument: '</span>   + s(binding.arg) + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">      <span class="string">'modifiers: '</span>  + s(binding.modifiers) + <span class="string">'&lt;br&gt;'</span> +</span><br><span class="line">      <span class="string">'vnode keys: '</span> + <span class="built_in">Object</span>.keys(vnode).join(<span class="string">', '</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#hook-arguments-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'hello!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><em>动态指令参数*</em><br>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。<h5 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h5>在很多时候，你可能想在 <code>bind</code> 和 <code>update</code> 时触发相同行为，而不关心其它的钩子。比如这样写：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'color-swatch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.backgroundColor = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h5>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'demo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.color) <span class="comment">// =&gt; "white"</span></span><br><span class="line">  <span class="built_in">console</span>.log(binding.value.text)  <span class="comment">// =&gt; "hello!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="渲染函数与JSX"><a href="#渲染函数与JSX" class="headerlink" title="渲染函数与JSX"></a>渲染函数与JSX</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'anchored-heading'</span>, &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(</span><br><span class="line">      <span class="string">'h'</span> + <span class="keyword">this</span>.level,   <span class="comment">// 标签名称</span></span><br><span class="line">      <span class="keyword">this</span>.$slots.default <span class="comment">// 子节点数组</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h4>Vue 通过建立一个虚拟 DOM 来追踪自己要如何改变真实 DOM。请仔细看这行代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> createElement(<span class="string">'h1'</span>, <span class="keyword">this</span>.blogTitle)</span><br></pre></td></tr></table></figure><code>createElement</code> 到底会返回什么呢？其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。<h4 id="createElement-参数"><a href="#createElement-参数" class="headerlink" title="createElement 参数"></a><code>createElement</code> 参数</h4></li></ul><ol><li>一个 HTML 标签名、组件选项对象，或者resolve 了上述任何一种的一个 async 函数。必填项。</li><li>一个与模板中 attribute 对应的数据对象。可选。</li><li>子级虚拟节点 (VNodes)，由 <code>createElement()</code> 构建而成，也可以使用字符串来生成“文本虚拟节点”。可选。</li></ol><p>见<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">官方文档</a></p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code>启动应用之前完成：<br><code>Vue.use</code> 会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件。</p><h4 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h4><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">'my-directive'</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：双花括号插值和 <code>v-bind</code> 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 `v-bind` 中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"rawId | formatId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以在一个组件的选项中定义<code>本地的过滤器</code>（局部）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  capitalize: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    value = value.toString()</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在创建 Vue 实例之前<code>全局定义过滤器</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">'capitalize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  value = value.toString()</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当全局过滤器和局部过滤器重名时，会采用局部过滤器。<br>过滤器可以串联：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>filterA</code> 被定义为接收单个参数的过滤器函数，表达式 <code>message</code> 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 <code>filterB</code>，将 <code>filterA</code> 的结果传递到 <code>filterB</code> 中。<br>过滤器是 JavaScript 函数，因此可以接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(<span class="string">'arg1'</span>, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure><p>这里，filterA 被定义为接收三个参数的过滤器函数。其中 <code>message</code> 的值作为第一个参数，普通字符串 <code>&#39;arg1&#39;</code> 作为第二个参数，表达式 <code>arg2</code> 的值作为第三个参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;混入&quot;&gt;&lt;a href=&quot;#混入&quot; class=&quot;headerlink&quot; title=&quot;混入&quot;&gt;&lt;/a&gt;混入&lt;/h3&gt;&lt;h4 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h4&gt;&lt;p&gt;混入 
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发指南之过渡与动画</title>
    <link href="http://lawsan.xyz/2020/07/18/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>http://lawsan.xyz/2020/07/18/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E8%BF%87%E6%B8%A1%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2020-07-18T09:23:27.000Z</published>
    <updated>2020-07-19T04:32:39.024Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章是关于组件/单元素的过渡效果和动画效果，也是上一篇文章的续篇。</p><h3 id="进入-离开-amp-列表过渡"><a href="#进入-离开-amp-列表过渡" class="headerlink" title="进入/离开&amp;列表过渡"></a>进入/离开&amp;列表过渡</h3><h4 id="单元素-组件的过渡"><a href="#单元素-组件的过渡" class="headerlink" title="单元素/组件的过渡"></a>单元素/组件的过渡</h4><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡:</p><ul><li>条件渲染 (使用 v-if)</li><li>条件展示 (使用 v-show)</li><li>动态组件</li><li>组件根节点<br>这里是一个典型的例子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"show = !show"</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> <span class="comment">/* .fade-leave-active below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当插入或删除包含在 <code>transition</code> 组件中的元素时，Vue 将会做以下处理：</li></ul><ol><li>自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。</li><li>如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。</li><li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。<h5 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h5>在进入/离开的过渡中，会有 6 个 class 切换。</li><li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li><li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li><li><code>v-enter-to</code>：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li><li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li><li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li><li><code>v-leave-to</code>：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/18/transition.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 <code>&lt;transition&gt;</code>，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了 <code>&lt;transition name=&quot;my-transition&quot;&gt;</code>，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。<h5 id="CSS过渡"><a href="#CSS过渡" class="headerlink" title="CSS过渡"></a>CSS过渡</h5>常用的过渡都是使用 CSS 过渡。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//html 和 js 部分看上面的代码</span><br><span class="line"><span class="comment">/* 可以设置不同的进入和离开动画 */</span></span><br><span class="line"><span class="comment">/* 设置持续时间和动画函数 */</span></span><br><span class="line"><span class="selector-class">.fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span></span><br><span class="line"><span class="comment">/* .fade-leave-active for below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">10px</span>);</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h5>CSS 动画用法同 CSS 过渡，区别是在动画中 <code>v-enter</code> 类名在节点插入 DOM 后不会立即删除，而是在 <code>animationend</code> 事件触发时删除。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//html 和 js 部分看上面的代码</span><br><span class="line"><span class="selector-class">.fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: fade-in .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: fade-in .<span class="number">5s</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> fade-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义过渡的类名"><a href="#自定义过渡的类名" class="headerlink" title="自定义过渡的类名"></a>自定义过渡的类名</h5>我们可以通过以下 attribute 来自定义过渡类名：</li></ol><ul><li><code>enter-class</code></li><li><code>enter-active-class</code></li><li><code>enter-to-class</code> (2.1.8+)</li><li><code>leave-class</code></li><li><code>leave-active-class</code></li><li><code>leave-to-class</code> (2.1.8+)<br>他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 <code>Animate.css</code> 结合使用十分有用。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/animate.css@3.5.1"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"show = !show"</span>&gt;</span></span><br><span class="line">    Toggle render</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">"custom-classes-transition"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">enter-active-class</span>=<span class="string">"animated tada"</span>  //自定义过渡类名</span></span><br><span class="line"><span class="tag">    <span class="attr">leave-active-class</span>=<span class="string">"animated bounceOutRight"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="同时使用过渡和动画"><a href="#同时使用过渡和动画" class="headerlink" title="同时使用过渡和动画"></a>同时使用过渡和动画</h5>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 <code>transitionend</code> 或 <code>animationend</code>，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。<br>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 <code>animation</code> 很快的被触发并完成了，而 <code>transition</code> 效果还没结束。在这种情况中，你就需要使用<code>type</code> attribute 并设置 <code>animation</code> 或 <code>transition</code> 来明确声明你需要 Vue 监听的类型。<h5 id="显性的过渡持续时间"><a href="#显性的过渡持续时间" class="headerlink" title="显性的过渡持续时间"></a>显性的过渡持续时间</h5>你可以用 <code>&lt;transition&gt;</code> 组件上的 duration prop 定制一个显性的过渡持续时间 (以毫秒计)：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"1000"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>你也可以定制进入和移出的持续时间：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:duration</span>=<span class="string">"&#123; enter: 500, leave: 800 &#125;"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="JavaScript钩子"><a href="#JavaScript钩子" class="headerlink" title="JavaScript钩子"></a>JavaScript钩子</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-enter</span>=<span class="string">"beforeEnter"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter</span>=<span class="string">"enter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-enter</span>=<span class="string">"afterEnter"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enter-cancelled</span>=<span class="string">"enterCancelled"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-leave</span>=<span class="string">"beforeLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave</span>=<span class="string">"leave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-leave</span>=<span class="string">"afterLeave"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:leave-cancelled</span>=<span class="string">"leaveCancelled"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>除了<code>enter</code>和<code>leave</code>可以接受<code>el</code>、<code>done</code>两个参数外，其他的都只接受<code>el</code>一个参数;<blockquote><p>当只用 JavaScript 过渡的时候，在 <code>enter</code> 和 <code>leave</code> 中必须使用 <code>done</code> 进行回调。否则，它们将被同步调用，过渡会立即完成。<br>推荐对于仅使用 JavaScript 过渡的元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p></blockquote><h4 id="初始渲染的过渡"><a href="#初始渲染的过渡" class="headerlink" title="初始渲染的过渡"></a>初始渲染的过渡</h4>可以通过 <code>appear</code> attribute 设置节点在初始渲染的过渡<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear-class</span>=<span class="string">"custom-appear-class"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear-to-class</span>=<span class="string">"custom-appear-to-class"</span> (<span class="attr">2.1.8</span>+)</span></span><br><span class="line"><span class="tag">  <span class="attr">appear-active-class</span>=<span class="string">"custom-appear-active-class"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>自定义 JavaScript 钩子：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  <span class="attr">appear</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:before-appear</span>=<span class="string">"customBeforeAppearHook"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:appear</span>=<span class="string">"customAppearHook"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:after-appear</span>=<span class="string">"customAfterAppearHook"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:appear-cancelled</span>=<span class="string">"customAppearCancelledHook"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>在上面的例子中，无论是 <code>appear</code> attribute 还是 <code>v-on:appear</code> 钩子都会生成初始渲染过渡。<h4 id="多个元素的过渡"><a href="#多个元素的过渡" class="headerlink" title="多个元素的过渡"></a>多个元素的过渡</h4>我们之后讨论多个组件的过渡，对于原生标签可以使用 <code>v-if/v-else</code>。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">v-if</span>=<span class="string">"items.length &gt; 0"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>Sorry, no items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>当有相同标签名的元素切换时，需要通过 <code>key</code> attribute 设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key 是一个更好的实践。<br>示例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">"isEditing"</span> <span class="attr">key</span>=<span class="string">"save"</span>&gt;</span> </span><br><span class="line">    Save</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">"edit"</span>&gt;</span></span><br><span class="line">    Edit</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>在一些场景中，也可以通过给同一个元素的 <code>key</code> attribute 设置不同的状态来代替 <code>v-if</code> 和 <code>v-else</code>，上面的例子可以重写为：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:key</span>=<span class="string">"isEditing"</span>&gt;</span></span><br><span class="line">    &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="过渡模式（mode）"><a href="#过渡模式（mode）" class="headerlink" title="过渡模式（mode）"></a>过渡模式（mode）</h5></li><li><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。</li><li><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。<br>用 <code>out-in</code> 重写之前的开关按钮过渡：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... the buttons ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多个组件的过渡"><a href="#多个组件的过渡" class="headerlink" title="多个组件的过渡"></a>多个组件的过渡</h4>多个组件的过渡简单很多 - 我们不需要使用 <code>key</code> attribute。相反，我们只需要使用动态组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"component-fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h4>使用<code>&lt;transition-group&gt;</code> 组件可以进行列表渲染动画。在我们深入例子之前，先了解关于这个组件的几个特点：</li><li>不同于 <code>&lt;transition&gt;</code>，它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。你也可以通过 <code>tag</code> attribute 更换为其他元素。</li><li>过渡模式不可用，因为我们不再相互切换特有的元素。</li><li>内部元素总是需要提供唯一的 <code>key</code> attribute 值。</li><li>CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。<h5 id="列表的进入-离开过渡"><a href="#列表的进入-离开过渡" class="headerlink" title="列表的进入/离开过渡"></a>列表的进入/离开过渡</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">tag</span>=<span class="string">"p"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.list-enter-active</span>, <span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span></span><br><span class="line"><span class="comment">/* .list-leave-active for below version 2.1.8 */</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="列表的排序过渡"><a href="#列表的排序过渡" class="headerlink" title="列表的排序过渡"></a>列表的排序过渡</h5><code>&lt;transition-group&gt;</code> 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 <code>v-move</code> class，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 <code>name</code> attribute 来自定义前缀，也可以通过 <code>move-class</code> attribute 手动设置。<h4 id="可复用的过渡"><a href="#可复用的过渡" class="headerlink" title="可复用的过渡"></a>可复用的过渡</h4>过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 <code>&lt;transition&gt;</code> 或者 <code>&lt;transition-group&gt;</code>作为根组件，然后将任何子组件放置在其中就可以了。<h4 id="动态过渡"><a href="#动态过渡" class="headerlink" title="动态过渡"></a>动态过渡</h4>在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 <code>name</code> attribute 来绑定动态值。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">v-bind:name</span>=<span class="string">"transitionName"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="状态过渡"><a href="#状态过渡" class="headerlink" title="状态过渡"></a>状态过渡</h3>见<a href="https://cn.vuejs.org/v2/guide/transitioning-state.html" target="_blank" rel="noopener">官方文档</a><br>此篇完结</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这篇文章是关于组件/单元素的过渡效果和动画效果，也是上一篇文章的续篇。&lt;/p&gt;
&lt;h3 id=&quot;进入-离开-amp-列表过渡&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的$attrs和$listeners</title>
    <link href="http://lawsan.xyz/2020/07/15/Vue%E4%B8%AD%E7%9A%84$attrs%E5%92%8C$listeners/"/>
    <id>http://lawsan.xyz/2020/07/15/Vue%E4%B8%AD%E7%9A%84$attrs%E5%92%8C$listeners/</id>
    <published>2020-07-15T10:46:04.000Z</published>
    <updated>2020-07-16T03:22:39.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="attrs"><a href="#attrs" class="headerlink" title="$attrs"></a>$attrs</h3><p>如果向一个子组件传递数据attribute时，该子组件并没有相应prop定义的attribute时。这些 attribute 会被添加到这个组件的根元素上。<br>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"home"</span>&gt;</span></span><br><span class="line">    以下为组件S1的内容</span><br><span class="line">    <span class="tag">&lt;<span class="name">S1</span> <span class="attr">:foo</span>=<span class="string">'foo'</span> <span class="attr">:eoo</span>=<span class="string">'eoo'</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">import S1 from '@/components/S1.vue'</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">foo:'I am foo',</span><br><span class="line">eoo:'I am eoo',</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">S1</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//子组件 S1</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      &#123;&#123;foo&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">props:['foo'],</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/15/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/15/2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以看到只有foo才会显示，而eoo则被添加到根元素中了，即便页面添加了<code></code>也不会显示的。<br>如果不希望组件的根元素继承 <code>attribute</code>，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。再配合实例的 <code>$attrs</code> property 使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//修改后的子组件S1，添加$attrs，并查看其值</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>foo:&#123;&#123;foo&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>attrs:&#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">props:['foo'],</span><br><span class="line">inheritAttrs: false,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以看到在组件的选项中设置 <code>inheritAttrs: false</code>后，组件没有相应prop定义的attribute将会被绑定到<code>$attrs</code>上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/15/3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/15/4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过对象取值的方法是行不通的，比如<code>$attrs.eoo</code>,但是我们可以通过<code>v-bind=&quot;$attrs&quot;</code>传入其内部组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//修改后的子组件S1,引入子组件S1Child</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>foo:&#123;&#123;foo&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>attrs:&#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">以下为组件S1Child的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">s1-child</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span>&gt;</span><span class="tag">&lt;/<span class="name">s1-child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">import S1Child from '@/components/S1Child.vue'</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">S1Child,</span><br><span class="line">&#125;,</span><br><span class="line">props:['foo'],</span><br><span class="line">inheritAttrs: false,</span><br><span class="line">...</span><br><span class="line">//子组件S1Child</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>eoo:&#123;&#123;eoo&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">props:['eoo'],</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/15/5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以看到，通过<code>$attrs</code>可以接收组件没有相应prop定义的attribute，并通过<code>prop</code>让其子子组件接收到。那么组件<code>S1Child</code>的信息怎么传递给其父父组件呐？<code>$listeners</code>。</p><h3 id="listeners"><a href="#listeners" class="headerlink" title="$listeners"></a>$listeners</h3><p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//修改后的父组件，添加绑定事件@upData</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"home"</span>&gt;</span></span><br><span class="line">    以下为组件S1的内容</span><br><span class="line">    <span class="tag">&lt;<span class="name">S1</span> <span class="attr">:foo</span>=<span class="string">'foo'</span> <span class="attr">:eoo</span>=<span class="string">'eoo'</span> @<span class="attr">upData</span>=<span class="string">"getS1ChidData"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">import S1 from '@/components/S1.vue'</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">foo:'I am foo',</span><br><span class="line">eoo:'I am eoo',</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">S1</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">getS1ChidData(value)&#123;</span><br><span class="line">console.log('这是组件S1Chid传过来的数据：',value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//修改后的子组件S1,绑定$listeners</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>foo:&#123;&#123;foo&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>attrs:&#123;&#123;$attrs&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">以下为组件S1Child的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">s1-child</span> <span class="attr">v-bind</span>=<span class="string">"$attrs"</span> <span class="attr">v-on</span>=<span class="string">"$listeners"</span>&gt;</span><span class="tag">&lt;/<span class="name">s1-child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">import S1Child from '@/components/S1Child.vue'</span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components:&#123;</span><br><span class="line">S1Child,</span><br><span class="line">&#125;,</span><br><span class="line">props:['foo'],</span><br><span class="line">inheritAttrs: false,</span><br><span class="line">...</span><br><span class="line">//子组件S1Child</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>eoo:&#123;&#123;eoo&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"startUpData"</span>&gt;</span>upData<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">props:['eoo'],</span><br><span class="line">methods:&#123;</span><br><span class="line">startUpData()&#123;</span><br><span class="line">this.$emit('upData','我是S1Child传过来的数据！')</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/July/15/6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过点击组件S1Child中的按钮触发当前实例上的<code>upData</code>事件,但是并不能直接触发非父组件的<code>upData</code>事件，需要通过<code>v-on=&quot;$listeners&quot;</code>也就通过<code>$listeners</code>接收了父组件的事件监听器并传给内部组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;attrs&quot;&gt;&lt;a href=&quot;#attrs&quot; class=&quot;headerlink&quot; title=&quot;$attrs&quot;&gt;&lt;/a&gt;$attrs&lt;/h3&gt;&lt;p&gt;如果向一个子组件传递数据attribute时，该子组件并没有相应prop定义的attribute时。这些 att
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发指南之深入了解组件</title>
    <link href="http://lawsan.xyz/2020/07/14/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/"/>
    <id>http://lawsan.xyz/2020/07/14/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/</id>
    <published>2020-07-14T10:46:04.000Z</published>
    <updated>2020-07-18T09:19:44.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章是上一篇文章的续文，让我们一起了解组件吧。</p><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><h4 id="全局组件与局部组件"><a href="#全局组件与局部组件" class="headerlink" title="全局组件与局部组件"></a>全局组件与局部组件</h4><p>组件名称首字母大写命名（MyComponentName）或者短横线分隔命名（my-component-name）<br><strong>全局组件</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong>局部组件</strong><br>注意一点：局部注册的组件在其子组件中不可用(也就是说局部组件只在当前注册的组件中可用，当前注册的组件的子组件不可用，要在子组件重新注册)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>为什么需要局部组件？</strong><br>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p><h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>在读下文之前，先来了解一些前端模块化的知识吧<a href="http://lawsan.xyz/2020/07/12/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">一文带你了解前端模块化</a><br><strong>在模块系统中局部注册</strong><br>在模块系统中，组件总是以单文件的形式存在，而这些单文件我们习惯把它们放在<code>components</code>文件夹下。如果你是有<code>vue-cli</code>构建的项目，你们就会发现此规范。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA'</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">'./ComponentC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基础组件的自动化全局注册</strong><br>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件，它们会在各个组件中被频繁的用到。<br>全局注册的行为必须在根 Vue 实例 (通过 new Vue) 创建之前发生。<br>如果你恰好使用了 webpack (或在内部使用了 <code>webpack</code> 的 <code>Vue CLI 3+</code>)，那么就可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 src/main.js) 中全局导入基础组件的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function">(<span class="params">fileName</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = fileName</span><br><span class="line">    .replace(<span class="regexp">/^\.\/_/</span>, <span class="string">''</span>)</span><br><span class="line">    .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    .split(<span class="string">'-'</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">kebab</span>) =&gt;</span> kebab.charAt(<span class="number">0</span>).toUpperCase() + kebab.slice(<span class="number">1</span>))</span><br><span class="line">    .join(<span class="string">''</span>)</span><br><span class="line"> <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(componentName, componentConfig.default || componentConfig)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>require.context是啥？</strong><br>一个webpack的api,通过执行<code>require.context</code>函数获取一个特定的上下文,主要用来实现<code>自动化导入模块</code>,在前端工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个api,它会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用import导入模块;<br>require.context函数接受三个参数:</p><ol><li>directory {String} -读取文件的路径</li><li>useSubdirectories {Boolean} -是否遍历文件的子目录</li><li>regExp {RegExp} -匹配文件的正则</li></ol><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><h4 id="Prop的大小写"><a href="#Prop的大小写" class="headerlink" title="Prop的大小写"></a>Prop的大小写</h4><p>驼峰命名和短横线分隔命名，两个是可以互用的，相互等价。如果使用字符串模板就没有这个限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">'postTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span><br><span class="line">&lt;blog-post post-title&#x3D;&quot;hello!&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure><h4 id="Prop类型"><a href="#Prop类型" class="headerlink" title="Prop类型"></a>Prop类型</h4><p>没有指定类型的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'title'</span>, <span class="string">'likes'</span>, <span class="string">'isPublished'</span>, <span class="string">'commentIds'</span>, <span class="string">'author'</span>]</span><br></pre></td></tr></table></figure><p>通常你希望每个 <code>prop</code> 都有指定的值类型。这时，你可以以对象形式列出 <code>prop</code>，这些 <code>property</code> 的名称和值分别是 <code>prop</code> 各自的名称和类型,<code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传递静态或动态-Prop"><a href="#传递静态或动态-Prop" class="headerlink" title="传递静态或动态 Prop"></a>传递静态或动态 Prop</h4><p><strong>静态传值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>动态态传值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">:title</span>=<span class="string">"post.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可传值的类型有 数字、布尔值、数组、对象等</p><h4 id="Prop的单向数据流"><a href="#Prop的单向数据流" class="headerlink" title="Prop的单向数据流"></a>Prop的单向数据流</h4><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。<br>每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。这里有两种常见的试图变更一个 prop 的情形：</p><ol><li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。</p></blockquote><h4 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h4>多种验证方式如下：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h4>如果在一个组件中传递数据，二组件没有用prop去接收，那么这个数据就会成为非 Prop 的 Attribute。而这些 attribute 会被添加到这个组件的根元素上。</li></ol><p><strong>替换/合并已有的 Attribute</strong><br>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-date-picker</span>=<span class="string">"activated"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"date-picker-theme-dark"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这种情况下，我们定义了两个不同的 class 的值：<code>form-control</code> 和 <code>date-picker-theme-dark</code>;<br>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 type=”text” 就会替换掉 type=”date”,但是<code>class</code> 和 <code>style</code> attribute 两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。<br><strong>禁用 Attribute 继承</strong><br>如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这尤其适合配合实例的 $attrs property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  required: <span class="literal">true</span>,</span><br><span class="line">  placeholder: <span class="string">'Enter your username'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写基础组件的时候是常会用到的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注意 inheritAttrs: false 选项不会影响 style 和 class 的绑定。</p></blockquote><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h4><p>事件名遵循完全匹配的机制，<code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 <code>v-on:myEvent</code> 将会变成 <code>v-on:myevent</code>——导致 <code>myEvent</code> 不可能被监听到。因此，我们推荐你始终使用 <code>kebab-case</code> 的事件名。</p><h4 id="自定义v-model"><a href="#自定义v-model" class="headerlink" title="自定义v-model"></a>自定义v-model</h4><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于不同的目的。model 选项可以用来避免这样的冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      v-bind:checked="checked"</span></span><br><span class="line"><span class="string">      v-on:change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在在这个组件上使用 v-model 的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;base-checkbox v-model=<span class="string">"lovingVue"</span>&gt;&lt;<span class="regexp">/base-checkbox&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 lovingVue 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。</p><blockquote><p>注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。</p></blockquote><h4 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h4><p>你可能有很多次想要在一个组件的<code>根元素</code>上直接监听一个原生事件。这时，你可以使用 <code>v-on</code> 的 <code>.native</code> 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">"onFocus"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br><span class="line">//根元素是label</span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">"value"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">"$emit('input', $event.target.value)"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>v-on=&quot;$listeners&quot;</code>将所有的事件监听器指向这个组件的<code>某个特定的子元素</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="keyword">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">'input'</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on="inputListeners"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a><code>.sync</code> 修饰符</h4><p>prop的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。<br>我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTitle)</span><br></pre></td></tr></table></figure><p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"doc.title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">"doc.title = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"doc.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> 不能和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code>是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。<br>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">"doc"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样会把 doc 对象中的每一个 property (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。</p><blockquote><p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><blockquote><p>在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 <code>v-slot</code> 指令)。它取代了 <code>slot</code> 和 <code>slot-scope</code> 这两个目前已被废弃但未被移除且仍在文档中的 attribute。</p></blockquote><h4 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h4><p>Vue 实现了一套内容分发的 API，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。<br>它允许你像这样合成组件：<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><br> 然后你在 <code>&lt;navigation-link&gt;</code> 的模板中可能会写为：<br> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:href</span>=<span class="string">"url"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"nav-link"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><br> 当组件渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML。<br> 如果 <code>&lt;navigation-link&gt;</code> 的 template 中没有包含一个 <code>&lt;slot&gt;</code> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。</p><h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h4><p>当你想在一个插槽中使用数据时，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Logged in as &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  &#123;&#123;url&#125;&#125; //这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是传递给`<span class="tag">&lt;<span class="name">navigation-link</span>&gt;</span>`的而不是在 `<span class="tag">&lt;<span class="name">navigation-link</span>&gt;</span>` 组件*内部*定义的。</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该插槽跟模板的其它地方一样可以访问相同的实例 property (也就是相同的“作用域”)，而不能访问 <code>&lt;navigation-link&gt;</code>的作用域。例如 url 是访问不到的。</p><blockquote><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p></blockquote><h4 id="后备内容（默认内容）"><a href="#后备内容（默认内容）" class="headerlink" title="后备内容（默认内容）"></a>后备内容（默认内容）</h4><p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 <code>&lt;submit-button&gt;</code> 组件中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在当我在一个父级组件中使用 <code>&lt;submit-button&gt;</code> 并且不提供任何插槽内容时：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span><span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span>//内容默认为Submit</span><br><span class="line"><span class="tag">&lt;<span class="name">submit-button</span>&gt;</span>Save<span class="tag">&lt;/<span class="name">submit-button</span>&gt;</span>//内容替换为Save</span><br></pre></td></tr></table></figure><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>具名插槽:有时我们需要多个插槽，这样就可以使用<code>&lt;slot&gt;</code>元素中的一个特殊的 attribute：<code>name</code>,这个 attribute 可以用来定义额外的插槽。<br>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  //上面这两行代码相当于下面的<span class="tag">&lt;<span class="name">template</span>&gt;</span>的内容</span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容(也就是没有没有名称的插槽 <code>name=&quot;default&quot;</code>)。</p><blockquote><p>注意 <code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上 (只有一种例外情况)，这一点和已经废弃的 <code>slot</code> attribute 不同。</p></blockquote><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>&#123;&#123; user.lastName &#125;&#125;<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。<br>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code> 而我们提供的内容是在父级渲染的。<br>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span> //slotProps可以任意取名称的</span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>独占默认插槽的缩写语法</strong><br>在上述情况下，当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这样我们就可以把 <code>v-slot</code>直接用在组件上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>注意默认插槽的缩写语法不能和具名插槽混用</code>，因为它会导致作用域不明确：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无效，会导致警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">"otherSlotProps"</span>&gt;</span></span><br><span class="line">    slotProps is NOT available here</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">"otherSlotProps"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>解构插槽 Prop</strong><br>ES6的解构赋值语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//&#123; user: person &#125; 可以将user重名为person ；&#123; user = &#123; firstName: 'Guest' &#125; &#125; 定义默认值</span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user &#125;"</span>&gt;</span> </span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;  //&#123;&#123;person.firstname&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><p>动态参数:从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数.<br>比如，当 eventName 的值为 “focus” 时，v-on:[eventName] 将等价于 v-on:focus。<br>动态指令参数也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h4><p>跟 <code>v-on</code> 和<code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这样会触发一个警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #=<span class="string">"&#123; user &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> #<span class="attr">default</span>=<span class="string">"&#123; user &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="废弃了的语法"><a href="#废弃了的语法" class="headerlink" title="废弃了的语法"></a>废弃了的语法</h4><blockquote><p><code>v-slot</code> 指令自 Vue 2.6.0 起被引入，提供更好的支持 <code>slot</code> 和 <code>slot-scope</code> attribute 的 API 替代方案。在接下来所有的 2.x 版本中 <code>slot</code> 和 <code>slot-scope</code> attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。<br><strong>带有 <code>slot</code> attribute 的具名插槽</strong></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//slot</span><br><span class="line"> <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> //v-slot</span><br><span class="line"> <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>有 <code>slot-scope</code> attribute 的作用域插槽</strong><br>在 <code>&lt;template&gt;</code> 上使用特殊的 <code>slot-scope</code> attribute，可以接收传递给插槽的 <code>prop</code> ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot-example</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"default"</span> <span class="attr">slot-scope</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot-example</span>&gt;</span></span><br><span class="line">//v-slot</span><br><span class="line"><span class="tag">&lt;<span class="name">slot-example</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"&#123;msg&#125;"</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot-example</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>slot-scope</code> attribute 也可以直接用于非 <code>&lt;template&gt;</code> 元素 (包括组件)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot-example</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; msg &#125;"</span>&gt;</span></span><br><span class="line">    &#123;&#123; msg &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot-example</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件 &amp; 异步组件"></a>动态组件 &amp; 异步组件</h3><h4 id="在动态组件上使用-keep-alive"><a href="#在动态组件上使用-keep-alive" class="headerlink" title="在动态组件上使用 keep-alive"></a>在动态组件上使用 <code>keep-alive</code></h4><p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。<br>多标签界面是典型的切换问题。次切换新标签的时候，Vue 都创建了一个新的 <code>currentTabComponent</code> 实例。重新创建动态组件的行为通常是非常有用的，但是在这个案例中，我们更希望那些标签的组件实例能够被在它们第一次被创建的时候缓存下来。为了解决这个问题，我们可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><p>异步从服务器获取组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//ES6 +webpack</span></span><br><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个动态导入会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当使用局部注册的时候，你也可以直接提供一个返回 Promise 的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>处理加载状态</strong><br>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>Vue开发指南之深入了解组件篇整理完了，下一篇过渡动画。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这篇文章是上一篇文章的续文，让我们一起了解组件吧。&lt;/p&gt;
&lt;h3 id=&quot;组件注册&quot;&gt;&lt;a href=&quot;#组件注册&quot; class=&quot;hea
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发指南之基础篇</title>
    <link href="http://lawsan.xyz/2020/07/13/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://lawsan.xyz/2020/07/13/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2020-07-13T11:43:34.000Z</published>
    <updated>2020-07-18T09:11:47.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写这编文章也是为了回顾之前学的Vue，查漏补缺。此篇文章涵盖Vue的基本知识以及开发技巧等。这篇文章不讲Vue的相关原理，只会讲Vue 2.0在开发中常见的知识点。你准备好了吗？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%93%A7%E6%BA%9C.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="CDN引入"><a href="#CDN引入" class="headerlink" title="CDN引入"></a>CDN引入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure><h4 id="命令行工具（CLI）"><a href="#命令行工具（CLI）" class="headerlink" title="命令行工具（CLI）"></a>命令行工具（CLI）</h4><p>安装Vue-cli <code>npm install -g @vue/cli</code><br>利用脚手架创建一个Vue项目 <code>vue create 项目名称</code> 这是vue-cli3创建项目的命令；vue-cli2创建一个Vue项目 <code>vue init webpack 项目名称</code>；</p><h3 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h3><h4 id="实例-amp-amp-数据-amp-amp-方法"><a href="#实例-amp-amp-数据-amp-amp-方法" class="headerlink" title="实例&amp;&amp;数据&amp;&amp;方法"></a>实例&amp;&amp;数据&amp;&amp;方法</h4><p>当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el:<span class="string">'#app'</span>,</span><br><span class="line">data:data,</span><br><span class="line">methods:&#123;&#125;,</span><br><span class="line">props:[],</span><br><span class="line">components:&#123;&#125;,</span><br><span class="line">created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">....</span><br><span class="line">&#125;)</span><br><span class="line">vm.a == data.a <span class="comment">//true</span></span><br><span class="line">vm.a = <span class="number">2</span>; data.a == <span class="number">2</span> <span class="comment">//true </span></span><br><span class="line"><span class="comment">//反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span>; vm.a == <span class="number">3</span> <span class="comment">//true </span></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><p>当数据被<code>Object.freeze()</code>时，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>beforeCreate：只是初始化一些生命周期函数和默认事件，其他的均未创建。<br>created：初始化data和methods了。<br>beforeMount：数据已经准备好了，还没渲染到页面。<br>mounted：将编译好的HTML挂载到页面，完成了渲染。<br>beforeUpdate：数据被修改，当是还没被重新渲染到页面。<br>updated：重新渲染页面，页面已经是修改后的了。<br>beforeDestroy：Vue实例进入销毁状态，data、methods，以及过滤器和指令都是可以用的。<br>destroyed：Vue实例已经被销毁。<br>看懂下面这张图就行</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.13/Vue%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p><strong>文本</strong><br>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>无论何时，绑定的数据对象上 msg property 发生了改变，插值处的内容都会更新。<br>通过使用 <code>v-once</code> 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p><strong>原始HTML</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Using v-html directive: &lt;span v-html&#x3D;&quot;rawHtml&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p><code>v-html</code>可能会引发XSS攻击，因此绝不要对用户提供的内容使用插值。<br><strong>Attribute &amp;&amp; 表达式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><code>v-if</code>:判断true或者flase，是否插入元素。<br><code>v-else</code>:经常和<code>v-if</code>一起用,还有<code>v-else-if</code>。<br><code>v-for</code>:遍历循环，注意要绑定<code>:key</code>。<br><code>v-on</code>:处理事件，<code>v-on:事件名=&quot;表达式||函数名&quot;</code>,简写<code>@事件名=&quot;函数名&quot;</code>。<br><code>v-bind</code>:绑定属性，<code>v-bind:属性名=&quot;属性值&quot;</code>简写<code>:属性名=&quot;属性值&quot;</code>。<br><code>v-show</code>:原始的显示与隐藏，与<code>v-if</code>不同，<code>v-if</code>是插入元素或者删除元素，开销大。<br><code>v-html</code>:插人原始HTML，插入的元素要用 <code>&gt;&gt;&gt;</code> css选择器渲染。<br><code>v-text</code>:插入文本。<br><code>v-cloak</code>:解决vue解析时出现页面闪烁问题。<br><code>v-model</code>:双向数据绑定。</p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p><code>@submit.prevent=&quot;fName&quot;</code>:<code>.prevent</code>阻止事件默认行为。<br><code>@click.stop=&quot;fName&quot;</code>:<code>.stop</code>阻止事件冒泡,<code>.capture</code>可以发生事件捕获，<code>.self</code>只触发本身。<br><code>@keyup.enter=&quot;fName&quot;</code>:<code>.enter</code>键盘回车事件，当然还有很多按键，请看我的另一篇文章<a href="http://lawsan.xyz/2020/06/30/Vue%E7%9B%91%E5%90%AC%E5%9B%9E%E8%BD%A6%E4%BA%8B%E4%BB%B6keyup/">Vue监听回车事件@keyup</a>。<br><code>@click.once=&quot;fName&quot;</code>:<code>.once</code>事件只触发一次。<br><code>&lt;el-input @keyup.enter.native=&quot;search&quot;&gt;&lt;/el-input&gt;</code>:<code>.native</code>在自定义组件中，要加<code>native</code>才能监听原生的事件。<br><code>&lt;input v-model.lazy=&quot;msg&quot; &gt;</code>:<code>.lazy</code>惰性更新，也就是说不会更新那么快，等输入完成后才更新。<br><code>&lt;input v-model.trim=&quot;msg&quot;&gt;</code>:<code>.trim</code>去除前后空格。<br><code>&lt;input v-model.number=&quot;msg&quot;&gt;</code>:<code>.number</code>将输入的字符串变成数字。<br><code>.sync</code>:对prop进行双向绑定,用法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;fa-comp :fatest.sync&#x3D;&quot;test&quot;&gt;&lt;&#x2F;fa-comp&gt;</span><br><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">this.$emit(&#39;update:fatest,sontest);</span><br></pre></td></tr></table></figure><p><code>.passive</code>:提升移动端的性能，大概解释就是每次滚动都会有一个默认事件触发，加了这个就是告诉浏览器，不需要查询，不需要触发这个默认事件。<br>利用vue中的修饰符能让你的开发事倍功半。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%A6%99.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><h4 id="基础实例"><a href="#基础实例" class="headerlink" title="基础实例"></a>基础实例</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护，所以，对于任何复杂逻辑，你都应当使用计算属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line"><span class="comment">// 计算属性的 getter</span></span><br><span class="line">reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。</p><h4 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h4><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;computed实现属性计算</span><br><span class="line">computed: &#123;</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">      return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;watch实现属性计算</span><br><span class="line"> watch: &#123;</span><br><span class="line">    firstName: function (val) &#123;</span><br><span class="line">      this.fullName &#x3D; val + &#39; &#39; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (val) &#123;</span><br><span class="line">      this.fullName &#x3D; this.firstName + &#39; &#39; + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。<br>除了 watch 选项之外，您还可以使用命令式的 vm.$watch。</p><h3 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h3><h4 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h4><p><strong>对象语法</strong><br>我们可以传给 v-bind:class 一个对象，以动态地切换 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class&#x3D;&quot;&#123; active: isActive &#125;&quot; :class&#x3D;&quot;classObject&quot;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F;两种形式</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: true,</span><br><span class="line">    &#39;text-danger&#39;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的语法表示 active 这个 class 存在与否将取决于数据 property isActive 的布尔值。<br><strong>数组语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class&#x3D;&quot;[activeClass, errorClass]&quot; :class&#x3D;&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;&#x2F;div&gt; &#x2F;&#x2F;也可以使用三元表达式</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive:false, </span><br><span class="line">  activeClass: &#39;active&#39;,</span><br><span class="line">  errorClass: &#39;text-danger&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h4><p><strong>对象语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style&#x3D;&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>数组语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style&#x3D;&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>和绑定HTML Class 大同小异，这里就不做多描述了。<br>注意：当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，Vue.js 会自动侦测并添加相应的前缀。<br><strong>前缀多重值</strong><br>你可以为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :style&#x3D;&quot;&#123; display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;A&#39;&quot;&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;B&#39;&quot;&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else-if&#x3D;&quot;type &#x3D;&#x3D;&#x3D; &#39;C&#39;&quot;&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div v-else&gt;</span><br><span class="line">  Not A&#x2F;B&#x2F;C</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><code>v-if</code>,<code>v-else</code>,<code>v-else-if</code>,<code>v-for</code>,<code>v-show</code>在前面的指令那里都有解释，这里就不做多描述了。</p><blockquote><p>不推荐同时使用 <code>v-if</code> 和 <code>v-for</code>;当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级,这意味着 v-if 将分别重复运行于每个 v-for 循环中。<br><strong>注意</strong><br>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外。也就是说<code>v-if</code>切换是，复用了已有元素。<code>要用key 管理可复用的元素</code>。</p></blockquote><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 v-for 里使用对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for&#x3D;&quot;(value, name, index) in object&quot;&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。</p></blockquote><h4 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h4><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。<br>这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for&#x3D;&quot;item in items&quot; v-bind:key&#x3D;&quot;item.id&quot;&gt;</span><br><span class="line">  &lt;!-- 内容 --&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p></blockquote><h4 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h4><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括(可以改变原数组的方法)：<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>;<br>当然也可以使用数组替换，用新数组替换原来的旧数组，达到数据变化以驱动视图更新。例如 <code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>,虽然不能改变原数组，但是可以赋值替换的方式来改变原数组。</p><blockquote><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</p></blockquote><h4 id="在-v-for-里使用值范围"><a href="#在-v-for-里使用值范围" class="headerlink" title="在 v-for 里使用值范围"></a>在 v-for 里使用值范围</h4><p>v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;span v-for&#x3D;&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&#x2F;&#x2F;结果：1,2,3...10</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click&#x3D;&quot;greet&quot;&gt;Greet&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:click&#x3D;&quot;say(&#39;hi&#39;)&quot;&gt;Say hi&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>事件修饰符，在前面有说了，这里就不做多描述。</p><blockquote><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。<br><code>.exact</code>修饰符允许你控制由精确的系统修饰符组合触发的事件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>鼠标按钮修饰符<code>.left</code>,<code>.right</code>,<code>.middle</code>;</p><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源，v-model是双向数据绑定的；<br>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。<br>绑定文本：<code>&lt;input v-model=&quot;message&quot; &gt;</code><br>多行文本：<code>&lt;textarea v-model=&quot;message&quot; &gt;&lt;/textarea&gt;</code><br>复选框:<code>&lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;</code><br>单选框：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;one&quot; value&#x3D;&quot;One&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;two&quot; value&#x3D;&quot;Two&quot; v-model&#x3D;&quot;picked&quot;&gt;</span><br></pre></td></tr></table></figure>选择框：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;select v-model&#x3D;&quot;selected&quot; multiple&gt; &#x2F;&#x2F;如果可以多选，加上multiple</span><br><span class="line">&lt;option disabled value&#x3D;&quot;&quot;&gt;请选择&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option&gt;A&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option&gt;B&lt;&#x2F;option&gt;</span><br><span class="line">&lt;option&gt;C&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当选中时，&#96;picked&#96; 为字符串 &quot;a&quot; --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;picked&quot; value&#x3D;&quot;a&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- &#96;toggle&#96; 为 true 或 false --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;toggle&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 当选中第一个选项时，&#96;selected&#96; 为字符串 &quot;abc&quot; --&gt;</span><br><span class="line">&lt;select v-model&#x3D;&quot;selected&quot;&gt;</span><br><span class="line">  &lt;option value&#x3D;&quot;abc&quot;&gt;ABC&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure><h4 id="修饰符-1"><a href="#修饰符-1" class="headerlink" title="修饰符"></a>修饰符</h4><code>.trim</code>,<code>.lazy</code>,<code>number</code>;在模板语法里面有讲解了，这里就不做多描述。<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3>组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</li><li><em>（单个根元素）*</em>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(&#39;button-counter&#39;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#39;&lt;button v-on:click&#x3D;&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;&#x2F;button&gt;&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h4>你可以将组件进行任意次数的复用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;components-demo&quot;&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;&#x2F;button-counter&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;&#x2F;button-counter&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;&#x2F;button-counter&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。组件之间是独立的，复用的时候也会产生独立的作用域。</li><li><em>data 必须是一个函数*</em><br>一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这也就是为什么，组件复用的时候，复用组件之间的数据是不互通的，作用域相互独立。<br>为了能在模板中使用，这些组件必须先注册以便 Vue 能够识别。这里有两种组件的注册类型：<code>全局注册</code>和<code>局部注册</code>。至此，我们的组件都只是通过 <code>Vue.component</code> 全局注册的：<h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4>父向子传props：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;...父组件</span><br><span class="line">&lt;son :title&#x3D;&quot;hello&quot; &gt;&lt;&#x2F;son&gt;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#x2F;&#x2F;...子组件</span><br><span class="line">&#123;&#123;title&#125;&#125;</span><br><span class="line">props:[title]</span><br><span class="line">&#x2F;&#x2F;...</span><br></pre></td></tr></table></figure>子传父$emit:<br>子组件通过<code>$emit</code>触发父组件的事件，而达到数据传递的效果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;...父组件</span><br><span class="line">&lt;son @getSonData&#x3D;&quot;sonData&quot; &gt;&lt;&#x2F;son&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">sonData(data)&#123;</span><br><span class="line">console.log(data) &#x2F;&#x2F;data为子组件传递过来的数据</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#x2F;&#x2F;...子组件</span><br><span class="line">&lt;button @click&#x3D;&quot;sendData&quot;&gt;向父组件传数据&lt;&#x2F;button&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">sendData()&#123;</span><br><span class="line">this.$emit(&#39;getSonData&#39;,&#39;我是子组件传递过来的数据&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;...</span><br></pre></td></tr></table></figure>EventBus 事件总线传递数据<br>…<h4 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&quot;searchText&quot;&gt;</span><br></pre></td></tr></table></figure>等价于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  v-bind:value&#x3D;&quot;searchText&quot;</span><br><span class="line">  v-on:input&#x3D;&quot;searchText &#x3D; $event.target.value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>当用在组件上时，v-model 则会这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value&#x3D;&quot;searchText&quot;</span><br><span class="line">  v-on:input&#x3D;&quot;searchText &#x3D; $event&quot;</span><br><span class="line">&gt;&lt;&#x2F;custom-input&gt;</span><br></pre></td></tr></table></figure>为了让它正常工作，这个组件内的 <input> 必须：</li><li>将其 value attribute 绑定到一个名叫 value 的 prop 上</li><li>在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出。<br>写成代码之后是这样的：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'custom-input'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value="value"</span></span><br><span class="line"><span class="string">      v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>现在 v-model 就应该可以在这个组件上完美地工作起来了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input v-model&#x3D;&quot;searchText&quot;&gt;&lt;&#x2F;custom-input&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="通过插槽分发内容："><a href="#通过插槽分发内容：" class="headerlink" title="通过插槽分发内容："></a>通过插槽分发内容：</h4><p>和 HTML 元素一样，我们经常需要向一个组件传递内容，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;alert-box&gt;</span><br><span class="line">  Something bad happened.</span><br><span class="line">&lt;&#x2F;alert-box&gt;</span><br></pre></td></tr></table></figure><p>幸好，Vue 自定义的 <code>&lt;slot&gt;</code>元素让这变得非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'alert-box'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="demo-alert-box"&gt;</span></span><br><span class="line"><span class="string">      &lt;strong&gt;Error!&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里：<br>上述内容可以通过 Vue 的 <component> 元素加一个特殊的 is attribute 来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 组件会在 &#96;currentTabComponent&#96; 改变时改变 --&gt;</span><br><span class="line">&lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;</span><br></pre></td></tr></table></figure><p>在上述示例中，currentTabComponent 可以包括:已注册组件的名字，或一个组件的选项对象</p><h4 id="解析-DOM-模板时的注意事项"><a href="#解析-DOM-模板时的注意事项" class="headerlink" title="解析 DOM 模板时的注意事项"></a>解析 DOM 模板时的注意事项</h4><p>有些 HTML 元素，诸如 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code> 和 <code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 <code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code> 和 <code>&lt;option&gt;</code>，只能出现在其它某些特定的元素内部。<br>这会导致我们使用这些有约束条件的元素时遇到一些问题。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;blog-post-row&gt;&lt;&#x2F;blog-post-row&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>这个自定义组件 <code>&lt;blog-post-row&gt;</code> 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is&#x3D;&quot;blog-post-row&quot;&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的：</p><ol><li><code>字符串 (例如：template: &#39;...&#39;)</code></li><li><code>单文件组件 (.vue)</code></li><li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li></ol><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p> Vue的基础篇就到这里结束，下篇<a href="http://lawsan.xyz/2020/07/14/Vue%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/">深入了解组件</a>。<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E5%90%97%EF%BC%9F.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;写这编文章也是为了回顾之前学的Vue，查漏补缺。此篇文章涵盖Vue的基本知识以及开发技巧等。这篇文章不讲Vue的相关原理，只会讲Vue 2.
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://lawsan.xyz/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0、HTTP1.1与HTTP2.0有啥变化？</title>
    <link href="http://lawsan.xyz/2020/07/13/HTTP1.0%E3%80%81HTTP1.1%E4%B8%8EHTTP2.0%E6%9C%89%E5%95%A5%E5%8F%98%E5%8C%96%EF%BC%9F/"/>
    <id>http://lawsan.xyz/2020/07/13/HTTP1.0%E3%80%81HTTP1.1%E4%B8%8EHTTP2.0%E6%9C%89%E5%95%A5%E5%8F%98%E5%8C%96%EF%BC%9F/</id>
    <published>2020-07-13T04:25:45.000Z</published>
    <updated>2020-07-13T05:34:13.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>计算机网络是一个开发人员的基础知识，今天我们就来聊聊HTTP的发展历史吧。<br>影响一个网络的因素有：<br>带宽：带宽的大小决定你网络的速率，比如100Mbps的宽带，理论上每秒下载量100Mbps/8 = 12.5m;上行一般都较小，大概30Mbps左右。<br>延迟：有时候你打游戏的时候，打的正爽，然后网络延时了（460）；在浏览器中，可能是以下原因：</p><ul><li>浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 6个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</li><li>DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</li><li>建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。<h3 id="HTTP协议是啥？"><a href="#HTTP协议是啥？" class="headerlink" title="HTTP协议是啥？"></a>HTTP协议是啥？</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E6%88%91%E5%8F%88%E4%B8%8D%E8%AF%86%E5%AD%97.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>HTTP协议 ：Hyper Text Transfer Protocol（超文本传输协议）,是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。是互联网上应用最为广泛的一种网络协议。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</li></ul><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><p>HTTP/0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP/0.9协议只支持一种内容，即纯文本。不过网页仍然支持用HTML语言格式化，同时无法插入图片。<br>HTTP/0.9具有典型的无状态性，每个事务独立进行处理，事务结束时就释放这个连接。<br>一次HTTP/0.9的传输首先要建立一个由客户端到Web服务器的TCP连接，由客户端发起一个请求，然后由Web服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>在HTTP 1.0中对上一代的版本添加了很多功能：</p><ol><li>请求与响应支持头域</li><li>响应对象以一个响应状态行开始</li><li>响应对象不只限于超文本</li><li>开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法</li><li>支持长连接（但默认还是使用短连接），缓存机制，以及身份认证</li></ol><p><strong>缺点</strong>：每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p> 是目前使用最广泛的协议版本，相对于HTTP/1.0新增了以下内容：</p><ol><li><strong>引入了持久连接</strong>（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接；</li><li><strong>多了一些缓存处理字段</strong>HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。</li><li>1.1版还新增了许多请求方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。</li><li><strong>引入了管道机制</strong>（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</li><li><strong>采用分块传输编码</strong>，对于一些很耗时的动态操作，服务器需要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer），这是支持文件断点续传的基础。<br><strong>缺点</strong>：虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。<br>这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。</li></ol><h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP 2.0 主要基于<code>SPDY协议</code>。HTTP2.0的特点是：在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了web性能。<br><strong>SPDY协议是啥？</strong><br>它是Google开发的基于TCP协议的应用层协议。目标是优化HTTP协议的性能，通过<code>压缩</code>、<code>多路复用</code>和<code>优先级</code>等技术，缩短网页的加载时间并提高安全性。SPDY协议的核心思想是<code>尽量减少TCP连接数</code>。SPDY并不是一种用于替代HTTP的协议，而是对HTTP协议的增强。</p><h4 id="HTTP-1-x协议的缺陷"><a href="#HTTP-1-x协议的缺陷" class="headerlink" title="HTTP 1.x协议的缺陷"></a>HTTP 1.x协议的缺陷</h4><ol><li>HTTP 1.0 一个TCP连接只能发起一个HTTP请求，在资源多面前，每次连接都要3次TCP握手还有断开的4次握手，非常费时间。</li><li>HTTP 1.1 一个TCP连接能发起多个HTTP请求，但是会出现队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。</li><li>单向请求，只能由客户端发起。</li><li>请求报文与响应报文首部信息冗余量大。</li><li>数据未压缩，导致数据的传输量大。<br><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">HTTP1.1与HTTP2.0速度比较</a><h4 id="HTTP-2-0的特点"><a href="#HTTP-2-0的特点" class="headerlink" title="HTTP 2.0的特点"></a>HTTP 2.0的特点</h4>HTTP2.0中，有两个概念非常重要：帧（frame）和流（stream）。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。</li><li>二进制分帧：HTTP 2.0 的所有帧都采用二进制编码；在HTTP1.x中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%A0%E8%BE%93.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>为了保证HTTP不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。</li><li>多路复用：多路复用允许同时通过单一的HTTP/2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP/2.0不再依赖多个TCP 连接去处理更多并发的请求。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端根据每个帧首部的流标识符把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。</li><li>头部压缩：随着web功能越来越复杂，请求数量越来越多，随之而来的就是头部的流量越来越多，并且在建立初次链接之后的链接也要发送user-agent等信息，是在是一种浪费。因此，http2提出了对请求和响应的头部进行压缩，即不再只是压缩主题部分，这种压缩方式就是HAPCK — 其设计简单而灵活。</li><li>服务器推送：服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</li><li>更多安全：HTTP2.0使用了tls的拓展ALPN做为协议升级，除此之外，HTTP2.0对tls的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。</li></ol><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>版本更新都是为了解决上一代的棘手问题，HTTP3.0协议基于QUIC，（Quick UDP Internet Connections)基于UDP的传输层协议。计算机网络在发明至今发展飞快，技术迭代迅速，科技的进步也给我们的生活带来了便利。<br>好了，就写到这了！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E7%A0%96%E5%8E%82%E7%B9%81%E5%BF%99%EF%BC%8C%E5%91%8A%E8%BE%9E.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;计算机网络是一个开发人员的基础知识，今天我们就来聊聊HTTP的发展历史吧。&lt;br&gt;影响一个网络的因素有：&lt;br&gt;带宽：带宽的大小决定你网络的
      
    
    </summary>
    
    
    
      <category term="HTTP" scheme="http://lawsan.xyz/tags/HTTP/"/>
    
      <category term="计算机网络" scheme="http://lawsan.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://lawsan.xyz/2020/07/12/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://lawsan.xyz/2020/07/12/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</id>
    <published>2020-07-12T15:03:50.000Z</published>
    <updated>2020-07-13T05:41:01.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br>举个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//3</span></span><br><span class="line"><span class="comment">//如果现在有一个柯里化函数curriedAdd</span></span><br><span class="line"><span class="keyword">let</span> add= curriedAdd(<span class="number">1</span>）</span><br><span class="line">add(<span class="number">2</span>)<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>满足以上条件的curriedAdd 的函数可以用以下代码段实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curriedAdd</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化函数实现"><a href="#柯里化函数实现" class="headerlink" title="柯里化函数实现"></a>柯里化函数实现</h3><p>函数柯里化的好处：参数复用。本质上是降低通用性，提高适用性。<br>这个curriedAdd 的实现表明了实现 Currying 的一个基础 —— <code>Currying 延迟求值的特性</code>需要用到 JavaScript 中的作用域——说得更通俗一些，我们需要<code>使用作用域来保存上一次传进来的参数</code>(闭包)。<br>对curriedAdd抽象化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curring</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>)<span class="comment">//类数组对象转数组，截取参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>)) <span class="comment">//合并参数</span></span><br><span class="line"><span class="keyword">return</span> fn.apply(<span class="keyword">this</span>.newArgs)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>);</span><br><span class="line">addCurry(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curring</span>(<span class="params">fn,...args1</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line">fn(...args1,...args2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现也只是一个简单的curring，而且只适用于两个参数的函数。让我们用递归来实现自动Curring化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trueCurring</span>(<span class="params">fn,args</span>)</span>&#123;</span><br><span class="line">length = fn.length</span><br><span class="line">args = args || []</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> _agrs = args.slice(<span class="number">0</span>),</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">_args.push(<span class="built_in">arguments</span>[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(_args.length &lt; length)&#123;</span><br><span class="line"><span class="keyword">return</span> trueCurring.call(<span class="keyword">this</span>,fn,_args)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn.apply(<span class="keyword">this</span>._args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trueCurring</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line"><span class="comment">//...args 剩余全部参数</span></span><br><span class="line"><span class="keyword">if</span>(args.length &gt;= fn.length)&#123; <span class="comment">//一次全部传完</span></span><br><span class="line"><span class="keyword">return</span> fn(...args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> trueCurring(fn,...args,...args2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现基本思路：比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p><a href="https://www.lodashjs.com" target="_blank" rel="noopener">工具库Lodsh</a><br>函数的bind方法和curring在功能上有很大的相似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是柯里化？&quot;&gt;&lt;a href=&quot;#什么是柯里化？&quot; class=&quot;headerlink&quot; title=&quot;什么是柯里化？&quot;&gt;&lt;/a&gt;什么是柯里化？&lt;/h3&gt;&lt;p&gt;在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。&lt;b
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://lawsan.xyz/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一文带你了解前端模块化</title>
    <link href="http://lawsan.xyz/2020/07/12/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://lawsan.xyz/2020/07/12/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2020-07-12T10:05:20.000Z</published>
    <updated>2020-07-12T13:31:40.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>随着项目越来越复杂，我们写的代码也越来越多了。代码越来越难维护，全局的命名污染，依赖不明确等等。<br>为了解决此问题，衍生有许多模块化规范。前端模块化发展历程： <code>无模块化</code> ==&gt; <code>CommonJS规范</code> ==&gt; <code>AMD规范</code> ==&gt; <code>CMD规范</code> ==&gt; <code>ES6模块化</code></p><h3 id="模块化是个啥？"><a href="#模块化是个啥？" class="headerlink" title="模块化是个啥？"></a>模块化是个啥？</h3><p>在ES5中，只有全局作用域和函数作用域，一旦在函数体中声明变量没有添加 <code>var</code>，就会造成全局污染。在ES6中有了<code>let</code>，<code>const</code>，这样就有了块作用域。<br><strong>模块化</strong>：指解决一个复杂的问题时自顶向下把系统划分成若干模块的过程，有多种属性，分别反映其内部特性；将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起；块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信；<br><strong>模块化组成</strong>：数据（内部属性），操作数据的行为（内部函数）。<br><strong>ES5中怎么实现模块化？</strong></p><ul><li><strong>原始写法</strong>：无模块可言，会污染全局作用域，看不出依赖关系。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>对象写法</strong>：对象会暴露所有模块成员，内部状态可以被外部改写。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">count:<span class="number">0</span>,</span><br><span class="line">foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;,</span><br><span class="line">bar:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><strong>立即执行函数(IIFE)</strong>:避免暴露私有成员，数据是私有的, 外部只能通过暴露的方法操作。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> increaseCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">count++</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">var</span> decreaseCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">count--</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;increaseCount,decreaseCount&#125; <span class="comment">//ES6简写，ES5 ==&gt;  &#123;increaseCount:increaseCount,...&#125;</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li>**IIFE的增强（依赖引入）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> _$body = $(<span class="string">"body"</span>)</span><br><span class="line"><span class="keyword">var</span> logBody = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(_$body)</span><br><span class="line"><span class="comment">//doSomethings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;logBody&#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure><h3 id="无模块化"><a href="#无模块化" class="headerlink" title="无模块化"></a>无模块化</h3>比如以下代码：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"jquery.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="bootstrap.min.js"&gt;&lt;/</span>script&gt;</span><br><span class="line">&lt;script src=<span class="string">"main.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="do.js"&gt;&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>简单粗暴引入文件即可，但是顺序不能错，因为后面的代码依赖着前面的代码。而且代码变量的命名可能冲突，可能在<code>main.js</code>里面声明了变量<code>foo</code>在<code>do.js</code>文件里面又声明了，或者直接用了该变量，又或者修改了该变量。<br>无模块化带来的问题：</li></ul><ol><li>污染全局作用域</li><li>依赖关系不明显</li><li>维护成本高</li></ol><h3 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h3><p>该规范最初是用在服务器端的node的，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。<br>实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用require加载模块（同步）。注意这是同步加载，在浏览器同步加载是会阻塞的，所以在浏览器不用此规范。<br>优点：解决了依赖、全局变量污染的问题；<strong>CommonJS用同步的方式加载模块</strong>。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，CommonJS不适合浏览器端模块<br><code>module.exports</code> 和 <code>exports</code>的区别：module.exports导出一个对象，exports可以导出多个对象。不过 <code>module.exports.foo == exports.foo</code>也就说<code>exports.属性</code>会自动挂载到没有命名冲突的<code>module.exports.属性</code>,但是不要给<code>exports</code>赋值，一旦有了新值，它就不再绑定到module.exports；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">module</span>.exports.foo = <span class="string">'bar'</span>  <span class="comment">//正确</span></span><br><span class="line">exports = &#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125; <span class="comment">//error 这种方式是错误的，相当于重新定义了exports</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是add.js文件</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">Add</span>:add,c&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是main.js文件</span></span><br><span class="line"><span class="keyword">const</span> addFn = <span class="built_in">require</span>(<span class="string">'./add'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(addFn.Add(<span class="number">5</span>,<span class="number">9</span>),addFn.c)<span class="comment">//19,5</span></span><br><span class="line"><span class="comment">//ES6解构赋值，导入</span></span><br><span class="line"><span class="keyword">const</span> &#123;Add,c&#125; = <span class="built_in">require</span>(<span class="string">'./add'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(Add(<span class="number">5</span>,<span class="number">9</span>),c)<span class="comment">//19,5</span></span><br></pre></td></tr></table></figure><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。<br>它采用<strong>异步方式加载模块</strong>，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，<strong>等到加载完成之后，这个回调函数才会运行</strong>。<br>AMD也采用require()语句加载模块，但是不同于CommonJS;<br>基本语法：</p><ol><li>定义暴露模块: <code>define([依赖模块名], function(){return 模块对象})</code>;</li><li>引入模块: <code>require([&#39;模块1&#39;, &#39;模块2&#39;, &#39;模块3&#39;], function(m1, m2){//使用模块对象})</code></li><li>指定引用路径:<code>require.config()</code><br>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面引入  打印I am LiSi;I am 18 years old</span></span><br><span class="line">&lt;script data-main=<span class="string">"js/main.js"</span> src=<span class="string">"https://cdn.bootcdn.net/ajax/libs/require.js/2.3.6/require.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">js/</span>logFn.js文件</span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> logName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> logAge = <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`I am <span class="subst">$&#123;age&#125;</span> years old`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;logName,logAge&#125;</span><br><span class="line">&#125;)</span><br><span class="line">js/main.js文件</span><br><span class="line"><span class="built_in">require</span>([<span class="string">'logFn'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">logFn</span>)</span>&#123;</span><br><span class="line">logFn.logName(<span class="string">'LiSi'</span>)</span><br><span class="line">logFn.logAge(<span class="number">18</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>优点：适合在浏览器环境中异步加载模块、并行加载多个模块；<br>缺点：不能按需加载、开发成本大；</li></ol><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><p><strong>AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行</strong>。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。<br>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。<br>在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。<br>说白了就是AMD引入依赖要先执行依赖再跳出执行主程序，而CMD则需要的时候引入，执行完主程序再回来执行依赖；CMD是按需加载，就近原则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面引入 </span></span><br><span class="line"><span class="comment">//module1 show() this is module1 msg</span></span><br><span class="line"><span class="comment">//异步引入依赖模块1  this is module1 msg</span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcdn.net/ajax/libs/seajs/3.0.3/sea.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">seajs.use('./js/main.js')</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">js/module1.js文件</span></span><br><span class="line"><span class="string">define(function (require, exports, module) &#123;</span></span><br><span class="line"><span class="string">  //内部变量数据</span></span><br><span class="line"><span class="string">  var data = 'this is module1'</span></span><br><span class="line"><span class="string">  var msg = 'this is module1 msg'</span></span><br><span class="line"><span class="string">  //内部函数</span></span><br><span class="line"><span class="string">  function show() &#123;</span></span><br><span class="line"><span class="string">    console.log('module1 show() ' + data)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  //向外暴露</span></span><br><span class="line"><span class="string">  exports.show = show</span></span><br><span class="line"><span class="string">  exports.msg = msg</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">js/main.js文件</span></span><br><span class="line"><span class="string">define(function (require, exports, module) &#123;</span></span><br><span class="line"><span class="string"> //引入依赖模块(同步)</span></span><br><span class="line"><span class="string"> var module1 = require('./module1')</span></span><br><span class="line"><span class="string"> function show() &#123;</span></span><br><span class="line"><span class="string">   console.log('module1 show() ' + module1.msg)</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">  show()</span></span><br><span class="line"><span class="string"> //引入依赖模块(异步)</span></span><br><span class="line"><span class="string"> require.async('./module1', function () &#123;</span></span><br><span class="line"><span class="string">   console.log('异步引入依赖模块1  ' + module1.msg)</span></span><br><span class="line"><span class="string"> &#125;)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><p>在ES6中，我们可以使用 import 关键字引入模块，通过 exprot 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的；<br>但是由于ES6在一些浏览器中无法执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。<br>基本用法：</p><ol><li>export 命令用于规定模块的对外接口；</li><li>import 命令用于输入其他模块提供的功能。</li><li><code>export default</code> 暴露一个对象 <code>export</code>暴露多个对象<br>es6在导出的时候有一个默认导出，<code>export default</code>,使用它导出后，在import的时候，不需要加上{}，模块名字可以随意起。该名字实际上就是个对象，包含导出模块里面的函数或者变量。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">a,b</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">'add.js'</span></span><br><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">a,b</span>) =&gt;</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'add.js'</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="CommonJS规范和-ES6的区别"><a href="#CommonJS规范和-ES6的区别" class="headerlink" title="CommonJS规范和 ES6的区别"></a>CommonJS规范和 ES6的区别</h3><ol><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;随着项目越来越复杂，我们写的代码也越来越多了。代码越来越难维护，全局的命名污染，依赖不明确等等。&lt;br&gt;为了解决此问题，衍生有许多模块化规范
      
    
    </summary>
    
    
    
      <category term="模块化" scheme="http://lawsan.xyz/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存</title>
    <link href="http://lawsan.xyz/2020/07/10/HTTP%E7%BC%93%E5%AD%98/"/>
    <id>http://lawsan.xyz/2020/07/10/HTTP%E7%BC%93%E5%AD%98/</id>
    <published>2020-07-10T08:10:27.000Z</published>
    <updated>2020-07-10T09:16:10.919Z</updated>
    
    <content type="html"><![CDATA[<p>只有不断的学习，才会发现自己是多么无知。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%93%AD%E7%9A%84%E5%BE%88%E5%A4%A7%E5%A3%B0.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>不过如果站在巨人的肩膀上的话，我就比别人看的更高更远。今天就来谈谈HTTP缓存机制。</p><h3 id="缓存是啥？"><a href="#缓存是啥？" class="headerlink" title="缓存是啥？"></a>缓存是啥？</h3><p>在浏览一些网站的时候，你有没有发现第二次浏览的时候比一开始的快很多。其实这就是缓存的结果，把第一次加载的网络资源缓存下来，以后请求的时候不用再去服务器获取，直接在本地获取即可。<br>这样可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力，可谓是一石多鸟啊。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%A6%99.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。我们来看一个缓存的流程图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E7%BC%93%E5%AD%98%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>每次浏览器发起GET请求(POST请求不能缓存)都会判断是否有缓存，首先判断的是强缓存，有则返回资源给浏览器渲染；否则判断是否有协商缓存，有返回资源给浏览器渲染，否则向服务器请求资源。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>当有强缓存在时不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 。<br>强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 <code>Expires</code>、<code>Cache-Control</code> 和 <code>Pragma</code> 3 个 Header 属性共同来控制。<br>优先级：<code>Pragma</code> &gt; <code>Cache-Control</code> &gt; <code>Expires</code>;</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。<br>Expires有一个很大的弊端，就是它返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，Expires是HTTP1.0的产物，现在大多数使用Cache-Control替代。</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>Cache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p><ul><li><code>max-age</code>：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效</li><li><code>no-cache</code>：不使用强缓存，需要与服务器验证缓存是否可用</li><li><code>no-store</code>：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源</li><li><code>private</code>：专用于个人的缓存，中间代理、CDN 等不能缓存此响应</li><li><code>public</code>：响应可以被中间代理、CDN 等缓存</li><li><code>must-revalidate</code>：在缓存过期前可以使用，过期后必须向服务器验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age&#x3D;100, must-revalidate, public</span><br></pre></td></tr></table></figure>上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。</li></ul><h5 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h5><p>Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否可用；<br>当 Pragma 和 Cache-Control 同时存在的时候，Pragma 的优先级高于 Cache-Control。<br>Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上上面这段meta元标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;Pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p>在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified : Fri , 11 May 2019 18:53:33 GMT</span><br></pre></td></tr></table></figure><p>当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since : Fri , 11 May 2019 18:53:33 GMT</span><br></pre></td></tr></table></figure><p>服务端通过If-Modified-Since字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。</p><h4 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h4><p>代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。<br><strong>If-None-Match和If-Modified-Since同时存在的时候If-None-Match优先级更高</strong>。<br>ETag/If-None-Match 的出现主要解决了 Last-Modified/If-Modified-Since 所解决不了的问题：<br>如果文件的修改频率在秒级以下，Last-Modified/If-Modified-Since 会错误地返回 304<br>如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 304<br>好了，HTTP缓存就说到这了，虽然还有很多字段没说，比如 <code>Vary</code>、<code>Date</code>、<code>Age</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E7%A7%83%E5%A4%B4%E5%BF%AB%E4%B9%90.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只有不断的学习，才会发现自己是多么无知。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay
      
    
    </summary>
    
    
    
      <category term="HTTP" scheme="http://lawsan.xyz/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理你了解多少</title>
    <link href="http://lawsan.xyz/2020/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/"/>
    <id>http://lawsan.xyz/2020/07/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/</id>
    <published>2020-07-10T04:21:03.000Z</published>
    <updated>2020-07-10T07:24:44.742Z</updated>
    
    <content type="html"><![CDATA[<p>通过这篇文章，能够让你重新认识浏览器，并把JavaScript，网络，页面渲染，浏览器安全等知识串联起来，从而让你对整个前端体系有全新的认识。<br>这篇文章是上篇文章的追加<a href="/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/">从输入URL到页面展示，这中间发生了啥</a></p><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><ul><li><strong>渲染引擎</strong>：它是浏览器最核心的部分是 “Rendering Engine”，不过我们一般习惯将之称为 “浏览器内核”；</li><li>渲染引擎主要包括的线程：GUI渲染线程、JavaScript引擎线程、事件触发线程、定时器触发线程、HTTP异步请求线程；如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><strong>GUI渲染线程</strong>：GUI 渲染线程负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。当界面需要重绘（Repaint）或由于某种操作引发回流（Reflow）时，该线程就会执行。</li><li><strong>JavaScript引擎线程</strong>: JavaScript 引擎线程主要负责解析 JavaScript 脚本并运行相关代码。 JavaScript 引擎在一个Tab页（Renderer 进程）中无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序。需要提起一点就是，GUI线程与JavaScript引擎线程是互斥的，这也是就是为什么JavaScript操作时间过长，会造成页面渲染不连贯，导致页面出现阻塞的原理。</li><li><strong>事件触发线程</strong>：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理。 通常JavaScript引擎是单线程的，所以这些事件都会排队等待JS执行。</li><li><strong>定时器触发器</strong>：我们日常使用的setInterval 和 setTimeout 就在该线程中，原因可能就是：由于JS引擎是单线程的，如果处于阻塞线程状态就会影响记时的准确，所以需要通过单独的线程来记时并触发响应的事件这样子更为合理。</li><li><strong>Http请求线程</strong>：在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，这个线程就Http请求线程，它 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。<h3 id="简略的渲染流程"><a href="#简略的渲染流程" class="headerlink" title="简略的渲染流程"></a>简略的渲染流程</h3></li></ul><ol><li>处理 HTML 并构建 DOM 树。</li><li>处理 CSS 构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 GPU 绘制，合成图层，显示在屏幕上。<br>流程如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>相关说明：</li></ol><ul><li>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。</li><li>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。</li><li><strong>Load 和 DOMContentLoaded 区别</strong><br>Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。<h4 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h4></li><li>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</li><li>通过以下几个常用属性可以生成新图层：</li></ul><ol><li>变换：translate3d、translateZ；</li><li>will-change；</li><li>video、iframe 标签；</li><li>通过动画实现的 opacity 动画转换；</li><li>position: fixed；<h4 id="重绘（Repaint）和回流（Reflow）"><a href="#重绘（Repaint）和回流（Reflow）" class="headerlink" title="重绘（Repaint）和回流（Reflow）"></a>重绘（Repaint）和回流（Reflow）</h4></li></ol><ul><li><strong>回流</strong>是布局或者几何属性需要改变就称为回流。<br>另外一个叫法是重排，回流触发的条件就是:对 DOM 结构的修改引发 DOM 几何尺寸变化的时候,会发生回流过程。<br>会发生回流的情况有如下：</li></ul><ol><li>一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等；</li><li>使 DOM 节点发生增减或者移动；</li><li>读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。</li><li>调用 window.getComputedStyle 方法。</li></ol><p><strong>回流的过程</strong><br>依照上面的渲染流水线，触发回流的时候，如果 DOM 结构发生改变，则重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%9B%9E%E6%B5%81%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>重绘</strong>是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘<br>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。<br>根据概念，我们知道由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程，流程如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E9%87%8D%E7%BB%98%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>跳过了布局树和建图层树,直接去绘制列表，然后在去分块,生成位图等一系列操作。</li><li>可以看到，重绘不一定导致回流，但回流一定发生了重绘。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</li><li>很多人不知道的是，重绘和回流其实和Event loop 有关。</li></ul><ol><li>Event loop 执行完微任务（Microtasks ）后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每(1000/60) = 16ms 才会更新一次。</li><li>然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 media query</li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 requestAnimationFrame 回调</li><li>执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面<br>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。</li></ol><h4 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h4><ul><li>使用 translate 替代 top，在修改定位时，使用translate代替；</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）；</li><li>把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改100次，然后再把它显示出来；</li><li>不要把DOM结点的属性值放在一个循环里当成循环里的变量;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(let i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 offsetTop 会导致回流，因为需要去获取正确的值</span><br><span class="line">    console.log(document.querySelector(&#39;.test&#39;).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局;</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame;</li><li>CSS 选择符从右往左匹配查找，避免 DOM 深度过深;</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。<h3 id="详细的渲染流程"><a href="#详细的渲染流程" class="headerlink" title="详细的渲染流程"></a>详细的渲染流程</h3>构建DOM树 ==&gt; 样式计算 ==&gt; 布局阶段 ==&gt; 分层 ==&gt; 绘制 ==&gt; 分块 ==&gt; 光栅化 ==&gt; 合成;<br>从0，1字节流到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程中化为很多的子阶段，渲染引擎从网络进程拿到字节流数据后，经过这些子阶段的处理，最后输出像素，这个过程可以称为渲染流水线 ，我们从一张图上来看👇<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%AD%90%E9%98%B6%E6%AE%B5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%9E%84%E5%BB%BADOM%E6%A0%91%E6%B5%81%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>数据类型改变： 字节 ==&gt; 字符 ==&gt; 令牌 ==&gt; 节点 ==&gt; 对象模型<br>转化过程：<ol><li><strong>转换</strong>:浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li><li><strong>令牌化</strong>：浏览器将字符串转换成 W3C HTML5 标准规定的各种令牌，例如，“html”、“head”，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li><li><strong>词法分析</strong>：发出的令牌转换成定义其属性和规则的“对象”。</li><li><strong>DOM构建</strong>：最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML 对象是 body 对象的父项，body 是 paragraph 对象的父项，依此类推。<h4 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h4></li></ol></li><li><em>格式化样式表*</em><br>我们拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构styleSheets；<br>通过浏览器的控制台document.styleSheets可以来查看这个最终结果。通过JavaScript可以完成查询和修改功能,或者说这个阶段为后面的样式操作提供基石。</li><li><em>标准化样式表*</em><br>有些时候，我们写CSS 样式的时候，会写font-size:2em;color:red;font-weight:bold,像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如em-&gt;px,red-&gt;rgba(255,0,0,0),bold-&gt;700等等。<br>我们来看看标准化的变化过程，如下图<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/css%E6%A0%87%E5%87%86%E5%8C%96.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><em>计算每个DOM节点具体样式*</em><br>通过之前的格式化和标准化后，接下来就是计算每个节点具体样式信息了。<br>计算规则：<code>继承</code>和<code>层叠</code></li><li><em>继承*</em>：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫UserAgent样式。</li><li><em>层叠*</em>：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。<br>不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到window.getComputedStyle当中，也就是可以通过JS来获取计算后的样式，非常方便。<br>这个阶段，完成了DOM节点中每个元素的具体样式，计算过程中要遵循CSS的继承和层叠两条规则，最终输出的内容是每个节点DOM的样式，被保存在ComputedStyle中。</li></ul><h4 id="生成布局树"><a href="#生成布局树" class="headerlink" title="生成布局树"></a>生成布局树</h4><p>上述过程已经完成DOM树（DOM树）构建，以及样式计算（DOM样式），接下来就是要通过浏览器的布局系统确定元素位置，也就是生成一颗布局树（Layout Tree）,之前说法叫渲染树。<br><strong>创建布局树</strong><br>在DOM树上不可见的元素，head元素，meta元素等，以及使用display:none属性的元素，最后都不会出现在布局树上，所以<strong>浏览器布局系统需要额外去构建一棵只包含可见元素布局树。</strong><br>我们直接结合图来看看这个布局树构建过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%B8%83%E5%B1%80%E6%A0%91%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>主要流程：</p><ol><li>遍历DOM树可见节点，并把这些节点加到布局树中；</li><li>对于不可见的节点，head,meta标签等都会被忽略。对于body.p.span 这个元素，它的属性包含display:none,所以这个元素没有被包含进布局树。</li></ol><p><strong>布局计算</strong><br>这个请看<a href="https://www.rrfed.com/2017/02/26/chrome-layout/" target="_blank" rel="noopener">从Chrome源码看浏览器如何layout布局</a><br><strong>一张图看懂渲染前三步流程：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%B8%B2%E6%9F%93%E5%89%8D%E4%B8%89%E9%98%B6%E6%AE%B5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>首先需要知道的就是，浏览器在构建完布局树后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，比如一些些复杂的 3D 变换、页面滚动，或者使用 z-index做 z 轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。<br><strong>生成图层树</strong><br>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。<br>我们来看看图层与布局树之间关系，如下图👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E5%9B%BE%E5%B1%82%E6%A0%91.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。<br>那什么情况下，渲染引擎会为特定的节点创建新图层呢？<br>有两种情况需要分别讨论，一种是<strong>显式合成</strong>，一种是<strong>隐式合成</strong>。<br><strong>显式合成</strong><br>需要剪裁(clip)的地方或者拥有层叠上下文的节点。层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:</p><ol><li>HTML根元素本身就具有层叠上下文。</li><li>普通元素设置position不为static并且设置了z-index属性，会产生层叠上下文。</li><li>元素的 opacity 值不是 1</li><li>元素的 transform 值不是 none</li><li>元素的 filter 值不是 none</li><li>元素的 isolation 值是isolate</li><li>will-change指定的属性值为上面任意一个。</li></ol><p><strong>隐式合成</strong><br>这是一种什么样的情况呢，通俗意义上来说，就是z-index比较低的节点会提升为一个单独的途图层，那么层叠等级比它高的节点都会成为一个独立的图层。<br>在一个大型的项目中，一个z-index比较低的节点被提升为单独图层后，层叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃。这就是<code>层爆炸</code>;</p><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>完成了图层的构建，接下来要做的工作就是图层的绘制了。图层的绘制跟我们日常的绘制一样，每次都会把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个绘制列表，类似于下图👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E7%BB%98%E5%88%B6%E5%88%97%E8%A1%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>接下来我们就要开始绘制操作了，实际上在渲染进程中绘制操作是由专门的线程来完成的，这个线程叫<code>合成线程</code>。<br>绘制列表准备好了之后，渲染进程的主线程会给<code>合成线程</code>发送<code>commit</code>消息，把<code>绘制列表</code>提交给合成线程。接下来就是合成线程一展宏图的时候啦。</p><blockquote><p>你想呀，有时候，你的图层很大，或者说你的页面需要使用滚动条，然后页面的内容太多，多的无法想象，这个时候需要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。<br>基于上面的原因，合成线程会讲图层划分为图块(tile);这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。<br><strong>首屏渲染加速：</strong><br>因为后面图块（非视口内的图块）数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。</p></blockquote><h4 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h4><p>接着上面的步骤，有了图块之后，合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</p><ul><li>图块是栅格化执行的最小单位</li><li>渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据</li><li>合成线程会选择视口附近的图块(tile)，把它交给栅格化线程池生成位图</li><li>生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程<br>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E6%A0%85%E6%A0%BC%E5%8C%96.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h4>栅格化操作完成后，合成线程会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。<br>浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡<br>两张图总结渲染过程，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%80%BB%E7%BB%93%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.10/%E4%B8%80%E5%BC%A0%E5%9B%BE%E6%80%BB%E7%BB%93%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>感觉好多东西还没有接触，越细越多，此时我的心情如下<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E7%86%8A%E7%8C%AB%E4%BA%BA%E5%90%90%E8%A1%80.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过这篇文章，能够让你重新认识浏览器，并把JavaScript，网络，页面渲染，浏览器安全等知识串联起来，从而让你对整个前端体系有全新的认识。&lt;br&gt;这篇文章是上篇文章的追加&lt;a href=&quot;/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5UR
      
    
    </summary>
    
    
    
      <category term="浏览器" scheme="http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面展示，这中间发生了啥</title>
    <link href="http://lawsan.xyz/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/"/>
    <id>http://lawsan.xyz/2020/07/09/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/</id>
    <published>2020-07-09T13:48:16.000Z</published>
    <updated>2020-07-09T15:19:36.140Z</updated>
    
    <content type="html"><![CDATA[<p>这道题应该是一个非常经典的题目，包括了HTTP、TCP连接、浏览器缓存、浏览器渲染等等。<br>用户输入URL后，向服务器端发起请求、如果顺利，得到网络响应之后，浏览器对资源进行解析、最后将其渲染到页面上。具体步骤如下👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>首先构建请求</li><li>查找缓存，如果命中缓存，直接使用缓存资源(包括DNS缓存)</li><li>否则进行DNS解析，将域名转换成对应的IP地址</li><li>建立TCP连接</li><li>发送HTTP请求</li><li>如果顺利得到网络响应，浏览器开始解析和渲染</li><li>HTML解释器 解析HTML 为 DOM树</li><li>同时CSS解释器 解析CSS文档 为 styleSheets</li><li>创建布局树，进行布局计算</li><li>整合图层，展示页面<br>我们先来分析一下HTTP请求，请求流程如下👇<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/HTTP%E8%AF%B7%E6%B1%82%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="首先构建请求"><a href="#首先构建请求" class="headerlink" title="首先构建请求"></a>首先构建请求</h2>首先，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;index.html HTTP1.1</span><br></pre></td></tr></table></figure><h2 id="查找缓存"><a href="#查找缓存" class="headerlink" title="查找缓存"></a>查找缓存</h2>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。<br>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。<br>这样做的好处有：</li><li>缓解服务器端压力，提升性能（获取资源的耗时更短了）；</li><li>对于网站来说，缓存是实现快速资源加载的重要组成部分。<br>当然，如果缓存查找失败，就会进入网络请求过程了。</li></ol><h2 id="DNS解析，将域名转换成对应的IP地址"><a href="#DNS解析，将域名转换成对应的IP地址" class="headerlink" title="DNS解析，将域名转换成对应的IP地址"></a>DNS解析，将域名转换成对应的IP地址</h2><p><strong>默认端口</strong> http为80，https为443。<br><strong>DNS解析</strong>：将域名映射成对应的IP地址，这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）<br><strong>DNS数据缓存服务</strong>：浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p><h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2><p><strong>网络OSI七层架构(从低到高)</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br><strong>计算机网络知识</strong>：HTTP在应用层，TCP在传输层，IP在网络层。<br>浏览器使用 HTTP 协议作为应用层协议，用来封装请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。<br>也就是说 HTTP 的内容是通过 TCP 的传输数据阶段来实现的，你可以结合下图更好地理解这二者的关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/TCP%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>等待TCP队列</strong>：在建立TCP建立之前，可能要进入TCP队列。因为浏览器的限制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。当然如果少于6个就不用进入队列等待。<br>浏览器通过TCP3次握手和服务器建立连接，建立连接后进行数据传输，传输完成后，经过4次TCP握手断开连接。如下图👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li>TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输。</li><li>网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层。</li><li>底层通过物理网络传输给目的服务器主机，紧接着目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层。</li><li>目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层</li><li>说白就是从网络底层到高层就是对数据脱外套，相反就是穿外套。<br><code>Connection:Keep-Alive</code>:如果请求头里面有这个属性，数据传输完成后，不会断开TCP的。</li></ol><h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>上面大概讲完了建立TCP连接，你可以理解TCP的连接，是为了保证浏览器跟服务器更好的通信。当然了有了上面的这个过程中， HTTP 中的数据也正是在这个通信过程中传输的。<br>那么我们从一张图片中来看，浏览器是如何发送信息给服务器的👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>请求行</strong>：<code>请求方法</code>，<code>请求URL</code> <code>HTTP协议版本</code>；</li><li>请求行大概意思就是告诉服务器，我需要做上面，比如GET方法，我需要向你拿资源，POST方法通常也就是我需要向服务器提交什么数据，需要注意的就是如果是POST方法，浏览器还需要准备好数据，通过请求体发送给服务器。</li><li><strong>请求头</strong>：把浏览器的基础信息告诉服务器，比如包含了浏览器所使用的操作系统，浏览器的内核信息等，还有请求的域名信息，浏览器的Cookie信息等等。</li><li><strong>请求体</strong>：一些业务逻辑需要的数据。</li></ul><h2 id="得到网络响应，浏览器开始解析和渲染"><a href="#得到网络响应，浏览器开始解析和渲染" class="headerlink" title="得到网络响应，浏览器开始解析和渲染"></a>得到网络响应，浏览器开始解析和渲染</h2><p>我们也来看一看响应的报文吧👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><strong>响应行</strong>：HTTP协议版本 状态码，通过常见的状态码，就可以知道处理的结果。</li><li><strong>响应头</strong>：你可以理解成包含服务器自身的一些信息，比如服务器生成数据的时间，返回数据的类型（HTML，流媒体，JSON，XHTML等等）以及服务器在客户端保存的Cookie等信息。响应头中 Cache-Control 字段也很重要，这个涉及到了HTTP缓存，这个字段涵义就是设置缓存资源的时间的</li><li><strong>响应体</strong>：请求返回的内容。<br>返回的状态码中有<code>301</code>或者<code>302</code>即可发生重定向；302为临时重定向，301为永久重定向。<br><code>Content-Type</code>:浏览器会按照这个内容类型来解析。<h2 id="HTML解释器-解析HTML-为-DOM树"><a href="#HTML解释器-解析HTML-为-DOM树" class="headerlink" title="HTML解释器 解析HTML 为 DOM树"></a>HTML解释器 解析HTML 为 DOM树</h2>渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来。<br>哎！，感觉后面的内容有点多，再新建一篇文章讲讲后面的内容（浏览器的渲染机制）。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/emotion/%E5%B0%8F%E9%BB%84%E9%B8%A1%E8%80%B6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这道题应该是一个非常经典的题目，包括了HTTP、TCP连接、浏览器缓存、浏览器渲染等等。&lt;br&gt;用户输入URL后，向服务器端发起请求、如果顺利，得到网络响应之后，浏览器对资源进行解析、最后将其渲染到页面上。具体步骤如下👇&lt;/p&gt;
&lt;figure class=&quot;image-
      
    
    </summary>
    
    
    
      <category term="HTTP" scheme="http://lawsan.xyz/tags/HTTP/"/>
    
      <category term="浏览器" scheme="http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器架构你了解多少？</title>
    <link href="http://lawsan.xyz/2020/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/"/>
    <id>http://lawsan.xyz/2020/07/08/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91/</id>
    <published>2020-07-08T02:45:05.000Z</published>
    <updated>2020-07-09T13:14:51.049Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端cv仔和浏览器打交道是最多的，浏览器对我们来说可以说是个黑盒，今天我们就来聊聊浏览器的架构。<br>首先了解一下必要的知识进程和线程。</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ol><li>进程是资源分配的最小单位,线程是程序执行的最小单位。</li><li>同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，而进程共享进程中的数据的，使用相同的地址空间；</li><li>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ol><h3 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h3><p>顾名思义，单进程浏览器是指浏览器所以模块都运行再同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。<br>单进程浏览器的架构如下图所示👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如此多的功能模块运行在一个进程里，肯定有着不足的：</p><ol><li>不稳定性：只要一个线程崩溃，这个进程就崩溃，浏览就用不了了。</li><li>不流畅： 多个任务共用一个线程，比如页面线程。</li><li>不安全：没有沙箱机制。</li></ol><h3 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h3><h4 id="早期多进程架构"><a href="#早期多进程架构" class="headerlink" title="早期多进程架构"></a>早期多进程架构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）</p><ul><li><strong>解决早期浏览器不稳定问题</strong>：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</li><li><strong>解决早期浏览器不流畅问题</strong>：JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</li><li><strong>解决早期浏览器不安全问题</strong>：用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</li></ul><h4 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E7%9B%AE%E5%89%8D%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看出，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。<br>下面我们来逐个分析下这几个进程的功能👇</p><ul><li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU进程</strong>。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p><strong>多进程带来的问题</strong>：</p><ol><li>更高的资源占用因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li>更复杂的体系架构浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</li></ol><h3 id="面向未来的架构"><a href="#面向未来的架构" class="headerlink" title="面向未来的架构"></a>面向未来的架构</h3><p>为了解决上面的问题，在2016年，Chrome官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.09/%E6%9C%AA%E6%9D%A5%E6%9E%B6%E6%9E%84.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h3><ul><li><strong>为什么单进程浏览器当时不可以采用安全沙箱？</strong><br>如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。</li><li><strong>打开Chrome浏览器一个Tab页面，至少会出现几个进程？</strong><br>最新的Chrome浏览器包括至少四个:1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程,当然还有复杂的情况；</li></ul><ol><li>页面中有iframe的话,iframe会单独在进程中</li><li>有插件的话，插件也会开启进程</li><li>多个页面属于同一站点，并且从a打开b页面，会共用一个渲染进程</li><li>装了扩展的话，扩展也会占用进程<br>这些进程都可以通过Chrome任务管理器来查看</li></ol><ul><li><strong>即使如今多进程架构，还是会碰到单页面卡死的最终崩溃导致所有页面崩溃的情况，讲一讲你的理解？</strong><br>Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。<br>更加简单的来说，就是如果多个页面符合同一站点，这几个页面会分配到一个渲染进程中去,所以有这样子的一种情况,一个页面崩溃了，会导致同一个站点的其他页面也奔溃，这是因为它们使用的是同一个渲染进程。<br>它们在一个渲染进程中的话，它们就会共享JS执行环境，也就是A页面可以直接在B页面中执行脚本了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为前端cv仔和浏览器打交道是最多的，浏览器对我们来说可以说是个黑盒，今天我们就来聊聊浏览器的架构。&lt;br&gt;首先了解一下必要的知识进程和线程。&lt;/p&gt;
&lt;h3 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与
      
    
    </summary>
    
    
    
      <category term="浏览器" scheme="http://lawsan.xyz/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>经典算法以及数据结构</title>
    <link href="http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://lawsan.xyz/2020/07/07/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-07-07T09:31:21.000Z</published>
    <updated>2020-07-12T15:06:48.241Z</updated>
    
    <content type="html"><![CDATA[<p>斐波那契数列在算法题中比较经典，故出此文以此铭记。<br>题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&lt;=39</p><h3 id="暴力递归实现"><a href="#暴力递归实现" class="headerlink" title="暴力递归实现"></a>暴力递归实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n</span><br><span class="line"><span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组保存计算缓存，减少计算"><a href="#数组保存计算缓存，减少计算" class="headerlink" title="数组保存计算缓存，减少计算"></a>数组保存计算缓存，减少计算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> Fib(n)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[n] !== <span class="literal">undefined</span> ) <span class="keyword">return</span> arr[n] <span class="comment">//计算过的不用再计算</span></span><br><span class="line"><span class="keyword">return</span> arr[n] = Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span> <span class="comment">//第一项</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span> <span class="comment">//第二项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i&lt; n;i++ )&#123; <span class="comment">//从第二项开始到n-1项</span></span><br><span class="line">[a,b] = [b,a+b]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉这篇幅有点短，好吧再加几个算法题^_^</p><h3 id="经典算法二分查找"><a href="#经典算法二分查找" class="headerlink" title="经典算法二分查找"></a>经典算法二分查找</h3><p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target,array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span> ;i&lt;array.length;i++)&#123;</span><br><span class="line"><span class="keyword">let</span> low = <span class="number">0</span> <span class="comment">//每行的开始索引</span></span><br><span class="line"><span class="keyword">let</span> height = array[i].length - <span class="number">1</span> <span class="comment">//每行的最大索引</span></span><br><span class="line"><span class="keyword">while</span>(low &lt;= height)&#123;<span class="comment">//对每一行的数组进行二分查找</span></span><br><span class="line"><span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((low+height)/<span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span>(target &gt; array[i][mid])&#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][mid])&#123;</span><br><span class="line">height = mid <span class="number">-1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题还有一种更好的思路：既然是递增数组，那我们就比较一下每一行数组最大的元素，如果此数大于这一行的最大元素则去下一行数组比较，如果此数小于这一行的最大元素则去前一列比较；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">target,array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> row = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> col = array[<span class="number">0</span>].length <span class="number">-1</span></span><br><span class="line"><span class="keyword">let</span> len = array.length</span><br><span class="line"><span class="keyword">while</span>(row &lt; len &amp;&amp; <span class="number">0</span> &lt;= col)&#123; <span class="comment">//row是索引要小于行数，col要大于0</span></span><br><span class="line"><span class="keyword">if</span>(target &gt; array[row][col])&#123;</span><br><span class="line">row++</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[row][col])&#123;</span><br><span class="line">col--</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表也是数据结构中的一种，由指针指向。<br>题目：输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*function ListNode(x)&#123;</span></span><br><span class="line"><span class="comment">    this.val = x;</span></span><br><span class="line"><span class="comment">    this.next = null;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printListFromTailToHead</span>(<span class="params">head</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ArrayList = []</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        ArrayList.push(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList.reverse()</span><br><span class="line">    <span class="keyword">return</span> ArrayList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript实现队列"><a href="#JavaScript实现队列" class="headerlink" title="JavaScript实现队列"></a>JavaScript实现队列</h3><p>队列是数据结构中的一种，先进先出<code>FIFO</code>,我们用数组来实现它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">return</span> arr.shift()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">arr.push(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> Queue()</span><br><span class="line">queue.push(<span class="number">1</span>)</span><br><span class="line">queue.push(<span class="number">2</span>)</span><br><span class="line">queue.push(<span class="number">3</span>)</span><br><span class="line">queue.pop() <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="JavaScript实现栈"><a href="#JavaScript实现栈" class="headerlink" title="JavaScript实现栈"></a>JavaScript实现栈</h3><p>栈是数据结构中的一种，先进先出<code>FILO</code>,我们用数组来实现它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> value = []</span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(value.length &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">return</span> value.pop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">value.push(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.pop() <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>好了此次的文章就写到这了，祝高三学子高考顺利！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;斐波那契数列在算法题中比较经典，故出此文以此铭记。&lt;br&gt;题目：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n&amp;lt;=39&lt;/p&gt;
&lt;h3 id=&quot;暴力递归实现&quot;&gt;&lt;a href=&quot;#暴力递归实现&quot; c
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://lawsan.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>canvas踩坑日记</title>
    <link href="http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/"/>
    <id>http://lawsan.xyz/2020/07/02/canvas%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0/</id>
    <published>2020-07-02T08:25:24.000Z</published>
    <updated>2020-07-12T15:07:41.675Z</updated>
    
    <content type="html"><![CDATA[<p>这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过<code>html2canvas.js</code>转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。</p><h3 id="利用canvas的API进行剪切"><a href="#利用canvas的API进行剪切" class="headerlink" title="利用canvas的API进行剪切"></a>利用canvas的API进行剪切</h3><p>注意：Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。<font color=red>也就是说通过css给canvas添加样式是行不通的</font>（这个坑费了我好多时间)。<br>解决方案：动态添加canvas；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>图片应用:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"scream"</span> <span class="attr">src</span>=<span class="string">"img_the_scream.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>画布:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"150"</span> <span class="attr">style</span>=<span class="string">"border:1px solid #d3d3d3;"</span>&gt;</span></span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"scream"</span>).onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span><br><span class="line">    <span class="keyword">var</span> ctx=c.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    <span class="keyword">var</span> img=<span class="built_in">document</span>.getElementById(<span class="string">"scream"</span>);</span><br><span class="line">    ctx.drawImage(img,<span class="number">90</span>,<span class="number">130</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关于drawImage的使用"><a href="#关于drawImage的使用" class="headerlink" title="关于drawImage的使用"></a>关于drawImage的使用</h3><p>有三种语法的使用：</p><ol><li><code>context.drawImage(img,dx,dy);</code></li><li><code>context.drawImage(img,dx,dy,dw,dh);</code></li><li><code>context.drawImage(img,sx,sy,sw,sh,dx,dy,dw,dh);</code><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://happychuan-pic.oss-cn-shenzhen.aliyuncs.com/2020/7.02/1.jpg" alt="坐标草图" title="">                </div>                <div class="image-caption">坐标草图</div>            </figure>对图片进行剪切<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> IMG = &#123;</span><br><span class="line">file: <span class="number">0</span>, <span class="comment">//图片文件</span></span><br><span class="line">width: <span class="number">0</span>, <span class="comment">//源图片宽度</span></span><br><span class="line">height: <span class="number">0</span>, <span class="comment">//源图片高度</span></span><br><span class="line">firstY: <span class="number">330</span>, <span class="comment">//第一次剪切高度（从0开始）</span></span><br><span class="line">secondY: <span class="number">410</span>, <span class="comment">//第二次剪切高度（第二次开始剪切的y坐标）</span></span><br><span class="line">money: <span class="string">"-588.00"</span>, <span class="comment">//要修改的数字</span></span><br><span class="line">bg: <span class="string">"#f7f7f7"</span>, <span class="comment">//#f5f5f5</span></span><br><span class="line">fontSize:<span class="string">'60px'</span>,</span><br><span class="line">&#125;</span><br><span class="line">pic.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">IMG.height = pic.height;</span><br><span class="line">IMG.width = pic.width;</span><br><span class="line">ctx1.drawImage(pic, <span class="number">0</span>, <span class="number">0</span>, pic.width, IMG.firstY, <span class="number">0</span>, <span class="number">0</span>, pic.width, IMG.firstY);</span><br><span class="line">ctx2.drawImage(pic, <span class="number">0</span>, IMG.secondY, pic.width, (IMG.height - IMG.secondY), <span class="number">0</span>, <span class="number">0</span>, pic.width, (IMG.height -IMG.secondY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对图片要要修改的部分用html代替显示，然后html转图片<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">html2canvas(canvasBox, &#123;</span><br><span class="line">allowTaint: <span class="literal">true</span>, <span class="comment">//允许污染</span></span><br><span class="line">taintTest: <span class="literal">true</span>, <span class="comment">//在渲染前测试图片</span></span><br><span class="line">useCORS: <span class="literal">true</span>, <span class="comment">//使用跨域</span></span><br><span class="line">background:IMG.bg,</span><br><span class="line">dpi: <span class="built_in">window</span>.devicePixelRatio * <span class="number">2</span>, <span class="comment">//分辨率，是图片清晰点</span></span><br><span class="line">scale: <span class="number">2</span>,</span><br><span class="line">height: IMG.height - <span class="number">10</span>, <span class="comment">//截图高度</span></span><br><span class="line">width: IMG.width, <span class="comment">//截图宽度</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">canvas</span>) </span>&#123;</span><br><span class="line"><span class="comment">//显示ps好的图片</span></span><br><span class="line"><span class="keyword">let</span> show = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>);</span><br><span class="line">show.style.display = <span class="string">'block'</span>;</span><br><span class="line">show.src = canvas.toDataURL();</span><br><span class="line">canvasBox.style.display = <span class="string">'none'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>此次是对支付宝账单详情的金额进行ps，整个源码地址==&gt;<a href="https://gitee.com/chuan8905/codes/ds7e8pmfqoajn94yxi6c181" target="_blank" rel="noopener">canvas对支付宝账单详情进行P图</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这次利用canvas主要是对图片进行剪切，再对要修改图片的部分用html显示，然后通过&lt;code&gt;html2canvas.js&lt;/code&gt;转化为图片。这个方法可以对图片进行PS，不过这种方法有局限，需要定制以及移动端适配。&lt;/p&gt;
&lt;h3 id=&quot;利用canvas的API
      
    
    </summary>
    
    
    
      <category term="canvas" scheme="http://lawsan.xyz/tags/canvas/"/>
    
  </entry>
  
</feed>
